[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33123946",
    "html_url": "https://github.com/rust-lang/rust/issues/11751#issuecomment-33123946",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11751",
    "id": 33123946,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTIzOTQ2",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T13:37:49Z",
    "updated_at": "2014-01-28T13:44:08Z",
    "body": "Implementing #9546 would fix this.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33123946/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/45805189",
    "html_url": "https://github.com/rust-lang/rust/issues/11751#issuecomment-45805189",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11751",
    "id": 45805189,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1ODA1MTg5",
    "user": {
      "login": "zwarich",
      "id": 440875,
      "node_id": "MDQ6VXNlcjQ0MDg3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/440875?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zwarich",
      "html_url": "https://github.com/zwarich",
      "followers_url": "https://api.github.com/users/zwarich/followers",
      "following_url": "https://api.github.com/users/zwarich/following{/other_user}",
      "gists_url": "https://api.github.com/users/zwarich/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zwarich/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zwarich/subscriptions",
      "organizations_url": "https://api.github.com/users/zwarich/orgs",
      "repos_url": "https://api.github.com/users/zwarich/repos",
      "events_url": "https://api.github.com/users/zwarich/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zwarich/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-06-11T21:53:33Z",
    "updated_at": "2014-06-14T07:49:19Z",
    "body": "In theory, LLVM should be able to determine that this null check is unnecessary without additional metadata. There are two separate changes to LLVM's optimizer that are required: \n1. An `inbounds` GEP either produces a valid pointer into an allocated object or a poison value. In address space 0, there is no allocated object at the zero address. This implies that any `inbounds` GEP in address space 0 is a poison value. According to the LLVM LangRef, the `icmp` would depend on the poison value, and any instruction that depends on poison values exhibits undefined behavior. However, Dan Gohman (sunfish) tells me that it was only intended to apply to instructions exhibiting externally visible side effects, as otherwise it would mean that any `add` instruction could potentially have undefined behavior. Any chain of `inbounds` GEPs and phis ending with a load of the `inbounds` value should be undefined behavior, because of how poison values behave like `undef`. We can't just assume that an `inbounds` GEP produces a nonnull value, because then that implies that `inbounds` GEPs themselves can have undefined behavior when the runtime value is actually null. Lots of optimizations depend on being able to hoist GEPs, e.g. out of loops, and that wouldn't be possible if they potentially had undefined behavior.\n2. The current LazyValueInfo / CorrelatedValuePropagation passes are not optimistic with respect to control flow. Since there is a phi here, the optimization opportunity would be missed even if LazyValueInfo understood that the pointers are null. This would improve other optimizations as well, but it would probably hurt compile-time a bit. IIRC changes along these lines have been proposed for LLVM in the past, but they have never gone in.\n\nCorrectly implementing the rule for poison values in LazyValueInfo would be quite difficult, because it requires reasoning about control-dependence with respect to poison values. Also, the cost of making LazyValueInfo optimistic might be too high in compile time to get the patch landed.\n\nIn #9546 there is a proposal to add metadata on LLVM instructions that indicates that the instruction produces a nonnull value. There are two reasons why this proposal would be a bit more difficult than it seems at first:\n1. If an instruction is marked with the nonnull metadata, then what happens if the value actually isn't null at runtime? Is it undefined behavior, or is it a poison value? If it is undefined behavior, then this means that any instruction with the nonnull metadata would potentially have side effects, and code motion that modifies control dependence of this instruction would be prohibited. Dan and I realized that this is also a problem with the current range metadata in LLVM that has likely gone unnoticed. It isn't a problem with the existing `nonnull` attribute on function parameters and return values, because the attribute is erased upon inlining.\n2. The nonnull metadata would only tell you that the inputs to the phi are nonnull, but LazyValueInfo would still not be able to propagate that to the phi because of the inadequacy mentioned above. Another pass would have to propagate nonnull on phis.\n\nAnother option would be to write a pass that looks for chains of `inbounds` GEPs, `nonnull` parameters / return values, and phis of these that feed into loads and stores control-dependent on null checks of some intermediate value in the chain. The null checks could be replaced with false, and then hopefully other optimization passes would be able to clean everything up.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/45805189/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/45824623",
    "html_url": "https://github.com/rust-lang/rust/issues/11751#issuecomment-45824623",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11751",
    "id": 45824623,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1ODI0NjIz",
    "user": {
      "login": "pcwalton",
      "id": 157897,
      "node_id": "MDQ6VXNlcjE1Nzg5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pcwalton",
      "html_url": "https://github.com/pcwalton",
      "followers_url": "https://api.github.com/users/pcwalton/followers",
      "following_url": "https://api.github.com/users/pcwalton/following{/other_user}",
      "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions",
      "organizations_url": "https://api.github.com/users/pcwalton/orgs",
      "repos_url": "https://api.github.com/users/pcwalton/repos",
      "events_url": "https://api.github.com/users/pcwalton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pcwalton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-06-12T02:47:49Z",
    "updated_at": "2014-06-12T02:47:49Z",
    "body": "Sounds like the last option is the easiest. I also like the fact that it's a separate pass, meaning that if we have trouble getting it upstream we can maintain it in our branch for a while.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/45824623/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47194958",
    "html_url": "https://github.com/rust-lang/rust/issues/11751#issuecomment-47194958",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11751",
    "id": 47194958,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MTk0OTU4",
    "user": {
      "login": "zwarich",
      "id": 440875,
      "node_id": "MDQ6VXNlcjQ0MDg3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/440875?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zwarich",
      "html_url": "https://github.com/zwarich",
      "followers_url": "https://api.github.com/users/zwarich/followers",
      "following_url": "https://api.github.com/users/zwarich/following{/other_user}",
      "gists_url": "https://api.github.com/users/zwarich/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zwarich/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zwarich/subscriptions",
      "organizations_url": "https://api.github.com/users/zwarich/orgs",
      "repos_url": "https://api.github.com/users/zwarich/repos",
      "events_url": "https://api.github.com/users/zwarich/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zwarich/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-06-26T07:20:01Z",
    "updated_at": "2014-06-26T07:20:01Z",
    "body": "I wrote the optimization pass I described. It is able to optimize the first case (with `&[uint]`), but it is unable to optimize the second case (with `Vec<uint>`). I have an informal inductive argument for why it should still always be nonnull with LLVM IR's poison value semantics, but implementing it as code will be trickier.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47194958/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47323264",
    "html_url": "https://github.com/rust-lang/rust/issues/11751#issuecomment-47323264",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11751",
    "id": 47323264,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MzIzMjY0",
    "user": {
      "login": "zwarich",
      "id": 440875,
      "node_id": "MDQ6VXNlcjQ0MDg3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/440875?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zwarich",
      "html_url": "https://github.com/zwarich",
      "followers_url": "https://api.github.com/users/zwarich/followers",
      "following_url": "https://api.github.com/users/zwarich/following{/other_user}",
      "gists_url": "https://api.github.com/users/zwarich/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zwarich/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zwarich/subscriptions",
      "organizations_url": "https://api.github.com/users/zwarich/orgs",
      "repos_url": "https://api.github.com/users/zwarich/repos",
      "events_url": "https://api.github.com/users/zwarich/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zwarich/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-06-27T09:13:30Z",
    "updated_at": "2014-06-27T09:13:30Z",
    "body": "Unfortunately, my pass causes the compiled `rustc` to segfault when compiling `liblibc`. That might be a pain to track down. The problem could be in my code, or `rustc` could just be marking a GEP `inbounds` when it shouldn't.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47323264/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47420627",
    "html_url": "https://github.com/rust-lang/rust/issues/11751#issuecomment-47420627",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11751",
    "id": 47420627,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NDIwNjI3",
    "user": {
      "login": "zwarich",
      "id": 440875,
      "node_id": "MDQ6VXNlcjQ0MDg3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/440875?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zwarich",
      "html_url": "https://github.com/zwarich",
      "followers_url": "https://api.github.com/users/zwarich/followers",
      "following_url": "https://api.github.com/users/zwarich/following{/other_user}",
      "gists_url": "https://api.github.com/users/zwarich/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zwarich/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zwarich/subscriptions",
      "organizations_url": "https://api.github.com/users/zwarich/orgs",
      "repos_url": "https://api.github.com/users/zwarich/repos",
      "events_url": "https://api.github.com/users/zwarich/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zwarich/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-06-28T07:24:36Z",
    "updated_at": "2014-06-28T07:24:36Z",
    "body": "I found the issue and put a first cut of my pass up as https://github.com/rust-lang/llvm/pull/13.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47420627/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47432803",
    "html_url": "https://github.com/rust-lang/rust/issues/11751#issuecomment-47432803",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11751",
    "id": 47432803,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NDMyODAz",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-06-28T17:02:01Z",
    "updated_at": "2014-06-28T17:02:01Z",
    "body": "\\o/\nOn Jun 28, 2014 12:24 AM, \"Cameron Zwarich\" notifications@github.com\nwrote:\n\n> I found the issue and put a first cut of my pass up as rust-lang/llvm#13\n> https://github.com/rust-lang/llvm/pull/13.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/rust-lang/rust/issues/11751#issuecomment-47420627.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47432803/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47437919",
    "html_url": "https://github.com/rust-lang/rust/issues/11751#issuecomment-47437919",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11751",
    "id": 47437919,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NDM3OTE5",
    "user": {
      "login": "zwarich",
      "id": 440875,
      "node_id": "MDQ6VXNlcjQ0MDg3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/440875?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zwarich",
      "html_url": "https://github.com/zwarich",
      "followers_url": "https://api.github.com/users/zwarich/followers",
      "following_url": "https://api.github.com/users/zwarich/following{/other_user}",
      "gists_url": "https://api.github.com/users/zwarich/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zwarich/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zwarich/subscriptions",
      "organizations_url": "https://api.github.com/users/zwarich/orgs",
      "repos_url": "https://api.github.com/users/zwarich/repos",
      "events_url": "https://api.github.com/users/zwarich/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zwarich/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-06-28T20:38:20Z",
    "updated_at": "2014-06-28T20:38:20Z",
    "body": "The pass that was landed handles the `&[T]` case. There are two obvious remaining things to do:\n1. Generalize to the case of multiple null checks involved in a single branch. This shouldn't be too hard.\n2. Handle the case where the base pointer is not known to be nonnull, but everything else in the recurrence is an `inbounds` GEP. This corresponds to the `Vec<T>` case. In theory, we could add `nonnull` metadata to the load (since loads are allowed to have undefined behavior), but applying the LLVM rules inductively actually lets the checks be removed without that.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47437919/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47438180",
    "html_url": "https://github.com/rust-lang/rust/issues/11751#issuecomment-47438180",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11751",
    "id": 47438180,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NDM4MTgw",
    "user": {
      "login": "zwarich",
      "id": 440875,
      "node_id": "MDQ6VXNlcjQ0MDg3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/440875?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zwarich",
      "html_url": "https://github.com/zwarich",
      "followers_url": "https://api.github.com/users/zwarich/followers",
      "following_url": "https://api.github.com/users/zwarich/following{/other_user}",
      "gists_url": "https://api.github.com/users/zwarich/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zwarich/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zwarich/subscriptions",
      "organizations_url": "https://api.github.com/users/zwarich/orgs",
      "repos_url": "https://api.github.com/users/zwarich/repos",
      "events_url": "https://api.github.com/users/zwarich/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zwarich/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-06-28T20:50:36Z",
    "updated_at": "2014-06-28T20:50:53Z",
    "body": "Actually, that second point applies to the IR generated by `&[T]` as well. I must've oversimplified it when I made test cases. I'll try to solve that soon then.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47438180/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47441919",
    "html_url": "https://github.com/rust-lang/rust/issues/11751#issuecomment-47441919",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11751",
    "id": 47441919,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NDQxOTE5",
    "user": {
      "login": "zwarich",
      "id": 440875,
      "node_id": "MDQ6VXNlcjQ0MDg3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/440875?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zwarich",
      "html_url": "https://github.com/zwarich",
      "followers_url": "https://api.github.com/users/zwarich/followers",
      "following_url": "https://api.github.com/users/zwarich/following{/other_user}",
      "gists_url": "https://api.github.com/users/zwarich/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zwarich/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zwarich/subscriptions",
      "organizations_url": "https://api.github.com/users/zwarich/orgs",
      "repos_url": "https://api.github.com/users/zwarich/repos",
      "events_url": "https://api.github.com/users/zwarich/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zwarich/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-06-28T23:54:42Z",
    "updated_at": "2014-06-28T23:54:42Z",
    "body": "I have local changes that fix those two items. In order to make this apply to `zip()`, I also need to track dominating conditions from other blocks. This shouldn't be that much more work, so maybe I'll hold out until I have that working.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47441919/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47466731",
    "html_url": "https://github.com/rust-lang/rust/issues/11751#issuecomment-47466731",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11751",
    "id": 47466731,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NDY2NzMx",
    "user": {
      "login": "zwarich",
      "id": 440875,
      "node_id": "MDQ6VXNlcjQ0MDg3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/440875?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zwarich",
      "html_url": "https://github.com/zwarich",
      "followers_url": "https://api.github.com/users/zwarich/followers",
      "following_url": "https://api.github.com/users/zwarich/following{/other_user}",
      "gists_url": "https://api.github.com/users/zwarich/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zwarich/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zwarich/subscriptions",
      "organizations_url": "https://api.github.com/users/zwarich/orgs",
      "repos_url": "https://api.github.com/users/zwarich/repos",
      "events_url": "https://api.github.com/users/zwarich/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zwarich/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-06-29T18:41:02Z",
    "updated_at": "2014-06-29T18:41:02Z",
    "body": "Those changes are up as https://github.com/rust-lang/llvm/pull/14/. I'll need to add less conservative control dependence checking, and then it should be able to handle arbitrary chaining of zipped iterators.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47466731/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
