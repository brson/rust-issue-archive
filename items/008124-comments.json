[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21803520",
    "html_url": "https://github.com/rust-lang/rust/issues/8124#issuecomment-21803520",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8124",
    "id": 21803520,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxODAzNTIw",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-30T16:26:52Z",
    "updated_at": "2013-07-30T16:26:52Z",
    "body": "I think that this is a legit error, although perhaps the error message could be improved. The problem is that the compiler doesn't know what `borrow_part` is borrowing. If it returned `&mut stuff.y`, then if the compiler allowed the call to `copy_out_of_immutable` you could possibly create an alias to the `y` field.\n\nThe error message makes you think that `(*stuff).y` was borrowed by the call to `borrow_part`, which is technically true but the whole truth is that _all_ of `(*stuff)` was borrowed with the call to `borrow_part` because the compiler can't actually determine what was borrowed from that function.\n\nThat's also why the first case works, it's because the compiler knows exactly what's been borrowed `stuff.x` so it knows it can also give out a loan on `stuff.y`.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21803520/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21807057",
    "html_url": "https://github.com/rust-lang/rust/issues/8124#issuecomment-21807057",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8124",
    "id": 21807057,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxODA3MDU3",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-30T17:19:05Z",
    "updated_at": "2013-07-30T17:19:05Z",
    "body": "> That's also why the first case works, it's because the compiler knows exactly what's been borrowed stuff.x so it knows it can also give out a loan on stuff.y.\n\nThat's true. \n\nHowever, I still think it would be completely safe to allow for passing the immutable reference to `copy_out_of_immutable` because there is no way that an alias to `stuff.y` could leak out of the call.\nI don't see a problem with temporarily treating an `&mut` reference as an immutable `&` reference, given of course, that the immutable reference goes out of scope before the mutable one is used again. In a case like this one (where the reference is passed to a function as immutable and the function returns a type that does not contain any references) this should also be provable locally at the call-site.\n(Thinking about it, this case reminds me of the [Uniqueness and Reference Immutability for Safe Parallelism](http://research.microsoft.com/pubs/170528/msr-tr-2012-79.pdf) paper)\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21807057/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21811633",
    "html_url": "https://github.com/rust-lang/rust/issues/8124#issuecomment-21811633",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8124",
    "id": 21811633,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxODExNjMz",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-30T18:25:24Z",
    "updated_at": "2013-07-30T18:25:24Z",
    "body": "10 brownie points to @alexcrichton for saying exactly what I wanted to say\n\n@michaelwoerister -- Before 'pure' was removed, the old borrow-checker used to be able to reason about what `copy_out_of_immutable` could do with its alias to y. The problem is that if (for example) you added extra arguments to `copy_out_of_immutable`, you could explode if you passed the result of `borrow_part` as a second argument. (I think you maybe could achieve the same effect with a Cell inside a &-pointer.) The `pure` keyword guaranteed that a function wouldn't mutate such arguments if they existed, which allowed extra permissiveness for \"borrowing-if-pure\".\n\n@nikomatsakis, is this a motivating use case for keeping &const in the language?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21811633/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21816181",
    "html_url": "https://github.com/rust-lang/rust/issues/8124#issuecomment-21816181",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8124",
    "id": 21816181,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxODE2MTgx",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-30T19:27:42Z",
    "updated_at": "2013-07-30T19:27:42Z",
    "body": "@bblum I think the compiler can still do some reasoning about that now (although it may not be exactly the same as was possible with 'pure'). \nI'll list the assumptions I am working under, perhaps I have something wrong here.\n\nAn `&` reference\n  (1) guarantees that there exists no mutable alias to the referenced object,\n  (2)  it allows that there are other `&` references to the referenced object\n\nFrom (1) and (2) follows that:\n  (3) no mutable reference to an `&` referenced object exists as long as there is _any_ `&` reference to it,\n  (4) one cannot _upgrade_ an `&` reference to an `&mut` reference because it cannot be guaranteed that there is no other `&` reference to the same object somewhere else.\n\nAn `&mut` reference\n  (5) guarantees that it is the only reference to the object, be it mutable or immutable,\n  (6) it brings with it the right to mutate the object,\n  (7) but it does not say anything about reading from the object.\n\nSo if I have a function taking only `&` references it is guaranteed to\n  (8) never introduce any mutable references to its arguments (or their interiors) because of (4)\n\nA function not returning any references (`&` or `&mut`) \n  (9) cannot not create any references that outlive the functions stack frame.\n\nFrom (8) and (9) follows that a function not returning a reference and taking only immutable reference cannot violate any of '&mut' guarantees (5, 6, 7).\n\nI am not sure how all this relates to `@` and `@mut` pointers, but for the case above, I think the reasoning should be sound.\n\nThe reason for my longwinded argumentation is that this is a pretty common case and I think it might be off-putting to people if they can't do something that they know to be safe and that is no problem in other languages.\n\nConcerning `&const`, I think refining the rules for `&` and `&mut` a little more might make removing it easier. \n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21816181/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21877496",
    "html_url": "https://github.com/rust-lang/rust/issues/8124#issuecomment-21877496",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8124",
    "id": 21877496,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxODc3NDk2",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-31T16:50:47Z",
    "updated_at": "2013-07-31T16:50:47Z",
    "body": "Hmm, I think your reasoning is right (and the motivation to make the borrow-checker more permissible is definitely right).\n\nThe best counterexample I came up with would be something like:\n\n```\nfn use_immutably(x: &Option<T>, blk: &fn(&T)) { blk(x.get_ref()); } // this borrowchecks today\n\nlet x = Some(...);\nlet y = &mut x;\ndo use_immutably(&x) |inner_ptr| {\n    *y = None; // inner_ptr invalidated\n}\n```\n\nBut the catch is that the closure captures a mutable borrow in its environment, so is secretly a mutable borrow itself. (And we are already planning to track whether stack closures are 'secretly mutable borrows', so we would be able to notice this case.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21877496/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21877729",
    "html_url": "https://github.com/rust-lang/rust/issues/8124#issuecomment-21877729",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8124",
    "id": 21877729,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxODc3NzI5",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-31T16:54:08Z",
    "updated_at": "2013-07-31T16:55:03Z",
    "body": "The risk with adding this sort of permissiveness is that, while it allows more cases, it makes the set of cases that are allowed defined by more complicated rules and hence more difficult to fully understand. (I think the same has come up regarding making the borrow-checker more flow-sensitive.) As I see it the tradeoff is between confusing people earlier by forbidding seemingly-legal code and confusing people later with a more complex overall model.\n\n(Personally I am fine with this suggested rule, but others may see it differently?)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21877729/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21891161",
    "html_url": "https://github.com/rust-lang/rust/issues/8124#issuecomment-21891161",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8124",
    "id": 21891161,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxODkxMTYx",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-31T20:01:36Z",
    "updated_at": "2013-07-31T20:01:36Z",
    "body": "@bblum Thanks for taking the time to think about this. I am aware of the trade off. However, I think this case could be okay because it is kind of _intuitive_ (\"I hold the exclusive right to modify something right now, I should be able to temporarily give somebody else the right to read from it\") and all information needed is available _statically_ (no need to know the current runtime state of something) and _locally_ (no need to look anywhere else but the current function body to know what's going on---well, except one has to know that the return type of the function does not contain any references). \n\nRegarding your example: This would be a different case from the one above because the mutable and the immutable reference are both accessible at the same time, while in my example the mutable reference would not be accessible during the execution of the function taking the immutable reference (which is the crucial condition for making this safe).\n\nBut I do hear you about making the overall ruleset more complicated.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21891161/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21892451",
    "html_url": "https://github.com/rust-lang/rust/issues/8124#issuecomment-21892451",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8124",
    "id": 21892451,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxODkyNDUx",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-31T20:19:19Z",
    "updated_at": "2013-07-31T20:19:19Z",
    "body": "There are certainly ways we could make the compiler smarter. In this particular case, one issue is that we have generally tried to draw the line at \"alias analysis\"---that is, we make no effort to determine what set of values is \"reachable\" from a called function, but instead assume that it can somehow connive its way into accessing everything. I am not opposed to extending the borrow checker to make it smarter, but I am wary of doing so now, since we are still finishing up the corner cases on the current set of rules.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21892451/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21915306",
    "html_url": "https://github.com/rust-lang/rust/issues/8124#issuecomment-21915306",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8124",
    "id": 21915306,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxOTE1MzA2",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-01T05:25:37Z",
    "updated_at": "2013-08-01T05:25:37Z",
    "body": "I thought about this a bit more. The big challenge here is that (1) we do not currently treat borrows for calls differently than other borrows in the borrow checker and (2) we do not track nor know of the connection between `a` and `self.x` here:\n\n```\nfn borrow_mut_to_immutable(stuff: &mut Stuff)\n{ // lifetime 'a\n    let a: &'a mut Foo = borrow_part(&'a mut *stuff);\n    let c = copy_out_of_immutable(&'b stuff.y); // call has lifetime 'b\n}\n```\n\nHere I made the implicit stuff more explicit. What winds up happening from the borrow checker's point of view is that `*stuff` gets borrowed for the lifetime `'a`, which makes `stuff` and `*stuff` inaccessible for that lifetime. Then, separately and independently, this new pointer `a` comes into existence that has the lifetime `'a`. It  does not know of any explicit connection between them. (Of course, the type system rules will guarantee that any pointer derived from the input to `borrow_part()` must have the same lifetime or smaller, but the connection between the return value and the input is not declared to the caller)\n\nSo now what would have to happen is that when `&stuff.y` is borrowed for `'b`, we must ensure that any mutable pointers pointing into `stuff` are frozen for `'b`, but we don't know what those pointers are. `*stuff` is already borrowed (hence the current error) so it wouldn't change anything to freeze that. Note that none of this reasoning was specific to calls. We haven't even gotten to the call yet, just the creation of the pointer that was going to be given as argument.\n\nWhat we _could_ do in such a situation is, in lieu of reporting an error, just go and effectively freeze _everything_, since we can't know for sure what we need to freeze. This is effectively what the old purity rules did. We'd want to think hard about the precise mechanism for doing this. We can of course get away with not freezing some stuff, and we'd have to decide where to draw the line. This is what I meant before by \"alias analysis\", since effectively we're trying to write some rules to decide what might and might not alias `stuff.y`.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21915306/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21919203",
    "html_url": "https://github.com/rust-lang/rust/issues/8124#issuecomment-21919203",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8124",
    "id": 21919203,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxOTE5MjAz",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-01T07:18:56Z",
    "updated_at": "2013-08-01T07:18:56Z",
    "body": "> So now what would have to happen is that when &stuff.y is borrowed for 'b, we must ensure that any mutable pointers pointing into stuff are frozen for 'b, but we don't know what those pointers are.\n\nYes, this probably is the hole in my argumentation. I thought we statically knew--- _by construction_ ---that the initial `&mut Stuff` reference would not have any aliases in the program (which should be true for `& [mut]` aliases). That is, there is no other `&mut` or `&` pointer to the object behind `stuff` or any of its interior objects because otherwise borrow checking should have failed already earlier. What I did not properly take into account though are `@mut` boxes where this can't be verified at compile time. I need to think a little more about this, but I guess my initial mental model of the situation was a bit too simplistic.\n\nIf it were necessary to add another restriction, that no `@mut` boxes must be reachable from the `&` argument to `copy_out_of_immutable()`, then I guess it just gets to complicated for the user and the whole new set of rules jumps the shark. \n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21919203/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21921654",
    "html_url": "https://github.com/rust-lang/rust/issues/8124#issuecomment-21921654",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8124",
    "id": 21921654,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxOTIxNjU0",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-01T08:19:29Z",
    "updated_at": "2013-08-01T08:19:29Z",
    "body": "@michaelwoerister Your model was a bit simplistic, but it is not the problem here. You were correct that `&mut` is _effectively_ unaliased -- there may be `@mut` aliases out there, which can be used for _reading_, but if there is an attempt to _write_ via such an alias a dynamic error is thrown. \n\nThe problem is more in the details of how much information the borrow checker has. At the point where, in your example, you do `&stuff.x`, all that it knows is that `stuff` was already borrowed, but it doesn't know which other `&mut` pointers correspond to data in `stuff` vs somewhere else. This is why I said we would have to conservatively block access to _all_ accessible data.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21921654/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21921668",
    "html_url": "https://github.com/rust-lang/rust/issues/8124#issuecomment-21921668",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8124",
    "id": 21921668,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxOTIxNjY4",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-01T08:19:43Z",
    "updated_at": "2013-08-01T08:19:43Z",
    "body": "Or at least block _write_ access, I should say.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21921668/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/26361482",
    "html_url": "https://github.com/rust-lang/rust/issues/8124#issuecomment-26361482",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8124",
    "id": 26361482,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzYxNDgy",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-10-15T18:47:54Z",
    "updated_at": "2013-10-15T18:47:54Z",
    "body": "@nikomatsakis says this is a wontfix.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/26361482/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
