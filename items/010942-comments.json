[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30469364",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-30469364",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 30469364,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwNDY5MzY0",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-12T22:38:22Z",
    "updated_at": "2013-12-12T22:38:22Z",
    "body": "> std, extra, etc. libraries can't be cross-compiled\n\nI thought they could? Or do you just mean \"they can't be cross-compiled to the platforms in this patch\"?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30469364/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30486566",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-30486566",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 30486566,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwNDg2NTY2",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-13T04:37:35Z",
    "updated_at": "2013-12-13T04:37:35Z",
    "body": "I'm nervous about landing something like this. There are _a lot_ of special cases for this. I don't really understand how well the compiler can target an \"unknown os\" because there are many things which don't make sense if you have an OS (i.e. dynamic linking). There are some weird defines like `DLL_EXTENSION = \".so\"` for the \"none\" os, but does that really make sense? We've also been very hesitant to remove generation of segmented stacks in the past. \n\nThis use case seems so specialized it seems like it would be more useful to compile to LLVM bytecode and then use `llc` manually to create an object file.\n\nI'd need to think about this some more and talk it over with others before merging.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30486566/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30494495",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-30494495",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 30494495,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwNDk0NDk1",
    "user": {
      "login": "neykov",
      "id": 3612111,
      "node_id": "MDQ6VXNlcjM2MTIxMTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3612111?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/neykov",
      "html_url": "https://github.com/neykov",
      "followers_url": "https://api.github.com/users/neykov/followers",
      "following_url": "https://api.github.com/users/neykov/following{/other_user}",
      "gists_url": "https://api.github.com/users/neykov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/neykov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/neykov/subscriptions",
      "organizations_url": "https://api.github.com/users/neykov/orgs",
      "repos_url": "https://api.github.com/users/neykov/repos",
      "events_url": "https://api.github.com/users/neykov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/neykov/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-13T08:47:55Z",
    "updated_at": "2013-12-13T08:48:50Z",
    "body": "> > std, extra, etc. libraries can't be cross-compiled\n> \n> I thought they could? Or do you just mean \"they can't be cross-compiled to the platforms in this patch\"?\n\nYes, I meant the None OS in particular. There is no POSIX API, dynamic memory allocation is optional, so large parts of the libraries don't even make sense in this context.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30494495/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30500081",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-30500081",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 30500081,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwNTAwMDgx",
    "user": {
      "login": "neykov",
      "id": 3612111,
      "node_id": "MDQ6VXNlcjM2MTIxMTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3612111?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/neykov",
      "html_url": "https://github.com/neykov",
      "followers_url": "https://api.github.com/users/neykov/followers",
      "following_url": "https://api.github.com/users/neykov/following{/other_user}",
      "gists_url": "https://api.github.com/users/neykov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/neykov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/neykov/subscriptions",
      "organizations_url": "https://api.github.com/users/neykov/orgs",
      "repos_url": "https://api.github.com/users/neykov/repos",
      "events_url": "https://api.github.com/users/neykov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/neykov/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-13T10:34:28Z",
    "updated_at": "2013-12-13T10:34:28Z",
    "body": "> alexcrichton commented \n\nAs a first cut at the patch I wanted to have it working and put it for comments first before making any major changes. I followed the existing approach for adding new operating system which of course isn't entirely applicable to the no OS case but works fine for normal usage.\n\n> This use case seems so specialized\n\nRust seems like a very good fit for such environments. From embedded systems to operating systems and kernel modules, GPU processors. I don't agree that it is specialized. It might be currently the case but everywhere C is used Rust has the qualities to replace it. Why limit it because of the status quo.\n\n> There are a lot of special cases for this.\n\nYou are in a better position than me to assess what parts of the compiler would need special treatment, but from my experience so far it is not that much different. Some of the cases could be served by adding new options which would be useful anyways. So far the custom changes which are needed in my specific case are:\n- No PIC - can be used but just doesn't make sense when the locations are static.\n- Disable segmented stack (see below for details)\n- Disable exception handling since no unwinding will be performed - no std library, no tasks. The goal here is not to pull in C++ features which would just consume memory without actually being used.\n- Add option for hard FP, again not a strict requirement, just taking advantage of the hardware.\n\n> We've also been very hesitant to remove generation of segmented stacks in the past. \n\nIn the embedded case dynamic memory allocation should be optional. When static stack memory is used we known the end of the stack and can detect when an overflow will occur which still is a nice guarantee.\n\nIn case a memory allocator is present segmented stacks may have benefits on embedded as well, leading to reduced memory consumption because of the reduced stack requirements.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30500081/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30523897",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-30523897",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 30523897,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwNTIzODk3",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-13T16:48:01Z",
    "updated_at": "2013-12-13T16:48:01Z",
    "body": "> Rust seems like a very good fit for such environments\n\nI certainly hope so! I would very much love to see rust in as many places as C, but we need to be careful. I don't think that the best way to start compiling for embedded applications is to just do the first thing that works and then continue to power through. I believe that these changes all need to be thought out and considered before committing them. Some specific concerns I have are:\n\n> No PIC\n\nSure, it makes sense to compile code without this, but it also doesn't make sense to compile a dynamic library with this. I don't see any verification that the output is not a dynamic library. There may also be many other complications about mixing PIC/non-PIC code that I'm not aware of, and I'd want to explore what happens with different flavors of compilation.\n\n> Disable segmented stacks\n\nWe have discussed this before, and we have previously reached the conclusion that this is not the answer. We may be wrong in our conclusion, but our reasoning is that just because you're in an embedded environment it doesn't mean that you no longer should care about overflowing your stack. Stack overflow is still a very real problem that should be addressed, and this is why we haven't added an option to disable segmented stack generation in the compiler today.\n\nRemember that we don't actually have segmented stacks in the segmented sense. All rust tasks have one monolithic stack that they run on. We use the `__morestack` prologue generation to detect stack overflow.\n\n> Disable exception handling since no unwinding will be performed\n\nI agree that this is a useful compiling option, but this is much more nuanced than \"just compiling some code with no landing pads\". If this is added to the compiler, then all of a sudden we're going to start seeing some libraries compiled with landing pads and others not compiled with landing pads, and these libraries cannot be safely linked together. Right now we have a `-Z no-landing-pads` option, and sadly we don't verify that libraries linked together all have the same mode of landing pads, but that is a bug in the compiler that should be fixed. As a small (possibly too slow) way of doing this, I have modified the LTO pass in https://github.com/mozilla/rust/pull/10916 to remove all landing pads entirely from all dependent libraries regardless of how they were compiled.\n\n> The goal here is not to pull in C++ features\n\nYay! I very much want to be able to drop our dependency on libstdc++ (see #10469). As with landing pads, this is a tricky situation though. Your use case may not want unwinding, but there are still many many use cases for unwinding. We need to carefully think about a model for disabling unwinding instead of \"just not linking to libstdc++\".\n\n> Add option for hard FP\n\nThis sounds like it should be a compiler flag because all it does is affect codegen a little bit. I'm not too worried about this.\n\n> When static stack memory is used we known the end of the stack and can detect when an overflow will occur which still is a nice guarantee\n\nIf that is true, then there's no reason for the morestack prologues to be omitted. The relevant mechanisms that morestack uses should be configured to know about these bounds of the stack (so stack overflow can be detected).\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30523897/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30623607",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-30623607",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 30623607,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwNjIzNjA3",
    "user": {
      "login": "neykov",
      "id": 3612111,
      "node_id": "MDQ6VXNlcjM2MTIxMTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3612111?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/neykov",
      "html_url": "https://github.com/neykov",
      "followers_url": "https://api.github.com/users/neykov/followers",
      "following_url": "https://api.github.com/users/neykov/following{/other_user}",
      "gists_url": "https://api.github.com/users/neykov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/neykov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/neykov/subscriptions",
      "organizations_url": "https://api.github.com/users/neykov/orgs",
      "repos_url": "https://api.github.com/users/neykov/repos",
      "events_url": "https://api.github.com/users/neykov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/neykov/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-15T22:26:45Z",
    "updated_at": "2013-12-15T22:26:45Z",
    "body": "After the above discussion I went back and checked what really are the hard requirements for the code to run on the embedded system.\n\n> No PIC\n\nNot required, though nice to have. Can we discuss it in another issue or pull request? Shared libraries must be PIC, static libraries and executables can be both.\n\n> Disable segmented stacks\n\n I will add support for this feature in the patch. I haven't realized that the project has already moved to static stack with overflow check only. This will require customizing the emitted function prologue since TLS is not available.\n\n> Disable exception handling since no unwinding will be performed\n\nI mistakenly concluded that the C++ library is pulled into my build if this is enabled. This is not the case, instead libgcc provides the needed symbols at the expense of requiring dynamic memory allocation, but this can be overcome. So the executable can be compiled with exception handling but it will never be used because the runtime is not referenced at all.\nI tried compiling with -Z no-landing-pads but the fnstart/fnend ops still appear in the assembly file. I suggest to skip the -arm-enable-ehabi\\* flags in case no-landing-pads is set?\n\n> Add option for hard FP\n\nThe existing implementation is fine for the time being. It will trigger default FP behavior which in this specific case is the hard ABI. In the future it would be nice to be able to control it mostly when linking with existing C libraries.\n\nTo sum up, after adding the new target and none OS the compiler generated code will work as is, with the exception of the segmented stack prologue which needs adapting for embedded targets.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30623607/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30636642",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-30636642",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 30636642,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwNjM2NjQy",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-16T05:52:39Z",
    "updated_at": "2013-12-16T05:52:39Z",
    "body": "> This will require customizing the emitted function prologue since TLS is not available\n\nNot necessarily. This code does not access TLS in the normal sense. On x86, this check happens through the segment selector registers. I would encourage you to inspect the output for the architecture you're compiling to and see if you can't arrange for the world to be in such a state that stack checks will be enabled and will work as usual. I am personally unfamiliar with how stack checks work on arm, so I do not know what the actual codegen looks like.\n\n> I suggest to skip the -arm-enable-ehabi\\* flags in case no-landing-pads is set?\n\nSounds reasonable to me!\n\n> after adding the new target and none OS the compiler generated code will work as is\n\nI am still wary of adding the concept of a \"none\" OS. Right now the segmented stack prologue will change depending on whatever platform (arch/os) you're compiling for, and we wouldn't know what to generate in the \"none\" case. I still believe that the segmented stack prologue should not be disabled at this time, and the selection of OS in your case will dictate the flavor of the segmented stack prologue that is generated.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30636642/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31188228",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-31188228",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 31188228,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMTg4MjI4",
    "user": {
      "login": "emberian",
      "id": 704250,
      "node_id": "MDQ6VXNlcjcwNDI1MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emberian",
      "html_url": "https://github.com/emberian",
      "followers_url": "https://api.github.com/users/emberian/followers",
      "following_url": "https://api.github.com/users/emberian/following{/other_user}",
      "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emberian/subscriptions",
      "organizations_url": "https://api.github.com/users/emberian/orgs",
      "repos_url": "https://api.github.com/users/emberian/repos",
      "events_url": "https://api.github.com/users/emberian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emberian/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-25T00:26:39Z",
    "updated_at": "2013-12-25T00:26:39Z",
    "body": "@neykov I've written about the stack safety issue in http://cmr.github.io/blog/2013/10/21/on-stack-safety/\n\nI think the best path forward for cases where dynamic checks (even memory mapping) is not acceptable is a whole-program stack size analysis.\n\nLLVM really needs to be taught to have a custom stack check prelude, too, for cases where that isn't acceptable and there still isn't an MMU or MMU-lite that provides memory protection.\n\nI'm in favor of the sentiment but agree with @alexcrichton that the easiest path forward is not the best.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31188228/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31316252",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-31316252",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 31316252,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMzE2MjUy",
    "user": {
      "login": "whitequark",
      "id": 54771,
      "node_id": "MDQ6VXNlcjU0Nzcx",
      "avatar_url": "https://avatars.githubusercontent.com/u/54771?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitequark",
      "html_url": "https://github.com/whitequark",
      "followers_url": "https://api.github.com/users/whitequark/followers",
      "following_url": "https://api.github.com/users/whitequark/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitequark/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitequark/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitequark/subscriptions",
      "organizations_url": "https://api.github.com/users/whitequark/orgs",
      "repos_url": "https://api.github.com/users/whitequark/repos",
      "events_url": "https://api.github.com/users/whitequark/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitequark/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-29T12:35:56Z",
    "updated_at": "2013-12-29T12:35:56Z",
    "body": "Side note: there is no need to duplicate the ARM ABI as `abi::Thumb`, since Thumb is just a compressed instruction encoding, not a distinct ABI. The only thing you possibly need to do is to emit `-mthumb` flag instead of `-marm` for the linker. I say \"possibly\" because as far as I know, that flag is completely unnecessary; it would affect compiled code, but Rust only invokes `cc` as linker.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31316252/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31911131",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-31911131",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 31911131,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTExMTMx",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T08:24:18Z",
    "updated_at": "2014-01-09T08:24:18Z",
    "body": "Closing due to a lack of activity, but if you have a rebased version with my last comment addressed, feel free to reopen!\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31911131/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31980375",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-31980375",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 31980375,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTgwMzc1",
    "user": {
      "login": "neykov",
      "id": 3612111,
      "node_id": "MDQ6VXNlcjM2MTIxMTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3612111?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/neykov",
      "html_url": "https://github.com/neykov",
      "followers_url": "https://api.github.com/users/neykov/followers",
      "following_url": "https://api.github.com/users/neykov/following{/other_user}",
      "gists_url": "https://api.github.com/users/neykov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/neykov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/neykov/subscriptions",
      "organizations_url": "https://api.github.com/users/neykov/orgs",
      "repos_url": "https://api.github.com/users/neykov/repos",
      "events_url": "https://api.github.com/users/neykov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/neykov/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T21:48:22Z",
    "updated_at": "2014-01-09T21:48:22Z",
    "body": "I haven't given up on the patch, just the time available for working on it is a bit short lately. I will re-open once I have an updated version.\n\nFrom what I've done so far I can confidently say that it is not possible to use the existing code for loading the stack limit due to the missing hardware. Both approaches used in the existing code are not applicable, one depends on MMU and the other on co-processor 15 (system control) being present. The change needed is not big, but nevertheless the LLVM code will need modification (one case for thumb and another for thumb2). The approach I am taking is to use the stack limit which is already laid out in the linker file. Since the stack is only one (no parallel processes) the limit is known at compile time. Any interrupts grow the same stack pointer. There is a more complex case where interrupts may have a separate stack space (i.e. when using an OS) but this is out of scope for the current implementation.\n\nRegarding the \"none\" OS, if we follow the LLVM convention there is no such an OS, instead \"unknown\" is used as a catch-all value. My opinion is that for this and similar cases there should be a different option than the existing Linux/Windows/Android OSes. Perhaps the best way is to use \"unknown\" OS and have a mechanism for requesting specific behavior from the compiler depending on the current instance of \"unknown\" - in my case bare metal. For example requesting alternative stack guard function prologue, no unwinding support, etc. by various options. This will keep the supported triples in sync with the LLVM support.\n\n@cmr I see one additional benefit of analyzing the stack requirements at compile time in the case of restricted memory - only the needed memory will be allocated with the rest available to dynamic allocation. \n\n@whitequark \"there is no need to duplicate the ARM ABI as abi::Thumb\": From the point of view of the Rust compiler there is no difference between the two (now). From LLVM standpoint they are different architectures. To trigger thumb mode in LLVM one must pass it a thumb architecture either through the triple or overriding it using the -march flag (which will change the triple internally). I think it is better to have abi::Thumb, than to keep only abi::Arm and add an option to pass -march=thumb to LLVM (which is different from the -mthumb option). It really depends on whether keeping the triple format support between Rust and LLVM is a priority or the Rust triple behavior may deviate from LLVM's.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31980375/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31980770",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-31980770",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 31980770,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTgwNzcw",
    "user": {
      "login": "whitequark",
      "id": 54771,
      "node_id": "MDQ6VXNlcjU0Nzcx",
      "avatar_url": "https://avatars.githubusercontent.com/u/54771?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitequark",
      "html_url": "https://github.com/whitequark",
      "followers_url": "https://api.github.com/users/whitequark/followers",
      "following_url": "https://api.github.com/users/whitequark/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitequark/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitequark/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitequark/subscriptions",
      "organizations_url": "https://api.github.com/users/whitequark/orgs",
      "repos_url": "https://api.github.com/users/whitequark/repos",
      "events_url": "https://api.github.com/users/whitequark/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitequark/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T21:52:31Z",
    "updated_at": "2014-01-09T21:52:31Z",
    "body": "@neykov the following one-line [patch](https://gist.github.com/whitequark/06101cfa9250b8358a7c) does the job because passing the triple is sufficient. try it yourself.\n\nAlso, I doubt that your choice of verifying the stack limit against symbols is correct. I for one can easily see an use case for multiple stacks on bare-metal hardware: an RTOS.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31980770/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31984598",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-31984598",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 31984598,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTg0NTk4",
    "user": {
      "login": "neykov",
      "id": 3612111,
      "node_id": "MDQ6VXNlcjM2MTIxMTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3612111?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/neykov",
      "html_url": "https://github.com/neykov",
      "followers_url": "https://api.github.com/users/neykov/followers",
      "following_url": "https://api.github.com/users/neykov/following{/other_user}",
      "gists_url": "https://api.github.com/users/neykov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/neykov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/neykov/subscriptions",
      "organizations_url": "https://api.github.com/users/neykov/orgs",
      "repos_url": "https://api.github.com/users/neykov/repos",
      "events_url": "https://api.github.com/users/neykov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/neykov/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T22:36:30Z",
    "updated_at": "2014-01-09T22:36:30Z",
    "body": "@whitequark Thanks, I will use this approach instead of introducing abi::Thumb.\n\n> Also, I doubt that your choice of verifying the stack limit against symbols is correct. I for one can easily see an use case for multiple stacks on bare-metal hardware: an RTOS.\n\nYes, I have listed this as option, but it is really not clear what to do in such a case. It is OS-dependent how the stack will be organized. And it is not bare metal really then - still embedded though. I don't believe it is possible to handle the single stack vs the multiple stacks + OS in a single common prologue. My intent is to make the bare metal case available. Afterwards alternative prologue implementations can be implemented as needed for the concrete OS requirements.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31984598/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31984993",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-31984993",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 31984993,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTg0OTkz",
    "user": {
      "login": "whitequark",
      "id": 54771,
      "node_id": "MDQ6VXNlcjU0Nzcx",
      "avatar_url": "https://avatars.githubusercontent.com/u/54771?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitequark",
      "html_url": "https://github.com/whitequark",
      "followers_url": "https://api.github.com/users/whitequark/followers",
      "following_url": "https://api.github.com/users/whitequark/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitequark/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitequark/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitequark/subscriptions",
      "organizations_url": "https://api.github.com/users/whitequark/orgs",
      "repos_url": "https://api.github.com/users/whitequark/repos",
      "events_url": "https://api.github.com/users/whitequark/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitequark/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T22:41:40Z",
    "updated_at": "2014-01-09T22:47:24Z",
    "body": "@neykov I think it is possible, you just need a single level of indirection. Logically it works like this: a symbol located in RW memory points to a memory block. (This is analogous to TLS, except instead of some OS magic, the address is simply switched explicitly by RTOS). Prologue loads the first word from the block and assumes it's the stack limit.\n\nBasically you would need to point the prologue to the \"current task\" structure, and make sure the first word is the stack limit. Not very flexible, but generic enough and allows easy retrofitting of even existing RTOSes (a global alias + some struct member rearranging).\n\nYou could even make it fallback to the simple case you have mentioned by using weak symbols in a creative way.\n\nMy main point is, modifying LLVM and rebuilding it and rustc for multiple platforms and updating them is a gigantic pain, we shouldn't require users to do that for everything that may require multiple threads. Especially in a language which begets threads by its very structure.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31984993/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32042471",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-32042471",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 32042471,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDQyNDcx",
    "user": {
      "login": "neykov",
      "id": 3612111,
      "node_id": "MDQ6VXNlcjM2MTIxMTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3612111?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/neykov",
      "html_url": "https://github.com/neykov",
      "followers_url": "https://api.github.com/users/neykov/followers",
      "following_url": "https://api.github.com/users/neykov/following{/other_user}",
      "gists_url": "https://api.github.com/users/neykov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/neykov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/neykov/subscriptions",
      "organizations_url": "https://api.github.com/users/neykov/orgs",
      "repos_url": "https://api.github.com/users/neykov/repos",
      "events_url": "https://api.github.com/users/neykov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/neykov/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-10T16:34:00Z",
    "updated_at": "2014-01-10T16:34:00Z",
    "body": "@whitequark I don't mind implementing it in the way you describe, but I am not convinced such an abstraction would serve even a single RTOS without any modifications. Even the port to android required changes in the prologue generator and it is all Linux. If even a single change is required it makes the whole effort worthless. This is why I am wary of implementing more advanced concepts without evidence that it will be worth it.\n\n> modifying LLVM and rebuilding it and rustc for multiple platforms and updating them is a gigantic pain\n\nI agree and didn't have in mind that the users themselves should re-build Rust for their target RTOS. What I meant is that the prologue logic will evolve but only when a need with concrete requirements arises.\n\nAnyway I hope that I will get even more feedback once I have a concrete patch, the difference between the two variants really isn't that much in terms of code so why not have both for review. \n\nYour input is much appreciated.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32042471/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32044185",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-32044185",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 32044185,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDQ0MTg1",
    "user": {
      "login": "whitequark",
      "id": 54771,
      "node_id": "MDQ6VXNlcjU0Nzcx",
      "avatar_url": "https://avatars.githubusercontent.com/u/54771?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitequark",
      "html_url": "https://github.com/whitequark",
      "followers_url": "https://api.github.com/users/whitequark/followers",
      "following_url": "https://api.github.com/users/whitequark/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitequark/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitequark/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitequark/subscriptions",
      "organizations_url": "https://api.github.com/users/whitequark/orgs",
      "repos_url": "https://api.github.com/users/whitequark/repos",
      "events_url": "https://api.github.com/users/whitequark/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitequark/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-10T16:51:33Z",
    "updated_at": "2014-01-10T16:52:26Z",
    "body": "@neykov I haven't expected this, but FreeRTOS actually already has exactly this arrangement!\n\n```\ntypedef struct tskTaskControlBlock\n{\n    volatile portSTACK_TYPE *pxTopOfStack;      /*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */\n```\n\nSo the only thing one would need to make Rust cooperate with FreeRTOS is to alias `pxCurrentTCB` to whatever symbol the prologue uses.\n\nI would also expect another RTOSes to have compatible task structure layouts, if only to remain compatible with this technique.\n\n(Also, I'm currently writing an RTOS in Rust, intended to closely resemble libstd's API. This is why I originally started to think about handling stack overflow. I'll publish it in a few days.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32044185/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32044778",
    "html_url": "https://github.com/rust-lang/rust/pull/10942#issuecomment-32044778",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10942",
    "id": 32044778,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDQ0Nzc4",
    "user": {
      "login": "whitequark",
      "id": 54771,
      "node_id": "MDQ6VXNlcjU0Nzcx",
      "avatar_url": "https://avatars.githubusercontent.com/u/54771?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitequark",
      "html_url": "https://github.com/whitequark",
      "followers_url": "https://api.github.com/users/whitequark/followers",
      "following_url": "https://api.github.com/users/whitequark/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitequark/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitequark/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitequark/subscriptions",
      "organizations_url": "https://api.github.com/users/whitequark/orgs",
      "repos_url": "https://api.github.com/users/whitequark/repos",
      "events_url": "https://api.github.com/users/whitequark/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitequark/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-10T16:57:38Z",
    "updated_at": "2014-01-10T16:57:38Z",
    "body": "@neykov Actually, I misread the FreeRTOS code above, it stores the top of stack there, not stack limit, so it's not compatible.\n\nI would still argue that the required modifications to existing code are trivial.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32044778/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
