[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35720238",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35720238",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35720238,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NzIwMjM4",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-21T10:52:53Z",
    "updated_at": "2014-02-21T10:57:27Z",
    "body": "> However it is less known that we rarely need the total ordering in reality, and the standard library has only two cases requiring the total ordering (sorting and `TreeMap`).\n\nIs there any generic code built on `Eq` and `Ord` that's correct in the presence of floating point types? If the answer is no, then the traits are not useful. I think the answer is no, because even `min`, `max` and `clamp` require specialized versions for floating point. The `HashMap` implementation is also incorrect as it really requires `TotalEq` (#5283).\n\nThe #12435 pull request is intended to remove a set of useless traits from the standard library, and make the usable ones into the default. The standard library is simply too complex, and needs to limit the usage of traits to cases where they're helpful for writing generic code. It's silly to have a set of traits for overloading operators not usable by generic code and then another set of traits with real guarantees but no operating overloading. Floating point types do have a total ordering available, so providing a terrible API for the sake of floating point seems silly.\n\nI think it's important to keep in mind that if traits only have type signatures but no laws, then the advantage of explicitly declaring type bounds instead of inferring the requirements from the implementation is pretty much gone. The traits aren't really documenting anything about the API if they don't provide either a strict weak order or total order.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35720238/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35808312",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35808312",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35808312,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODA4MzEy",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T17:23:27Z",
    "updated_at": "2014-02-22T17:23:27Z",
    "body": "> \"It's silly to have a set of traits for overloading operators not usable by generic code and then another set of traits with real guarantees but no operating overloading\"\n\nIf each trait that provided the guarantees extended the trait that defined the overloaded operator, then I'm not sure that's totally silly.  (I mean, it would be a little silly, in that the use of a trait to define the operator is solely an artifact of how Rust does operator-overloading.  But not completely silly.)\n\nE.g. I'm thinking something like this:\n\n``` rust\n#[lang=\"ord\"]\n/// This trait is solely to provide access to {<, >, <=, >=} sugared operators,\n///  but there are no guarantees about their semantics.  It has an intentionally ugly\n/// name to discourage use as an accidental trait-bound on type parameters.\npub trait OrdOps {\n    fn lt(&self, other: &Self) -> bool;\n    #[inline]\n    fn le(&self, other: &Self) -> bool { !other.lt(self) }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool {  other.lt(self) }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool { !self.lt(other) }\n\n    // FIXME (#12068): Add min/max/clamp default methods\n}\n\n/// This trait provides concrete guarantees about ordering.\n/// Note that f32/f64 does not impl this trait, but most other numerics do.\ntrait Ord : OrdOps {  }\n```\n\nNote that then `#[deriving(Ord)]` would need to be changed to inject definitions for both `OrdOps` and `Ord`.\n\nHaving said that, I do not do enough floating-point work myself to push hard to support {<, >, <=, >=} as built-in operators for `f32`/`f64`.  This was just something I thought of this morning that I thought might resolve this issue.  (Its possible that someone had already suggested this elsewhere.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35808312/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35808417",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35808417",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35808417,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODA4NDE3",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T17:27:35Z",
    "updated_at": "2014-02-22T17:27:35Z",
    "body": "@pnkfelix: IEEE754 defines a total ordering and we are going to implement it, so leaving out an implementation of the total ordering trait for floating point isn't a good option. This means the traits can't have any inheritance relationship if the operators are overloaded with the weak ordering for floating point types. So, there's a trait for generic code and a trait for operator overloading with the overloaded operators not usable in generic code.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35808417/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35808492",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35808492",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35808492,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODA4NDky",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T17:29:58Z",
    "updated_at": "2014-02-22T17:30:22Z",
    "body": "@thestinger my assumption is/was that people working with floating point might prefer to use the operator notation for the non-total-ordering.  But I admit this would make it hard/impossible to mix generic-code that uses the `Ord` bound with structures that are employing floats (since the whole point of my suggestion was to make `f32`/`f64` implement `OrdOps` and _not_ `Ord`).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35808492/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35808557",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35808557",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35808557,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODA4NTU3",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T17:32:32Z",
    "updated_at": "2014-02-22T17:43:38Z",
    "body": "@thestinger Oh wait, maybe I misunderstood part of your response.\n\nYou said: \"So, there's a trait for generic code and a trait for operator overloading with the overloaded operators not usable in generic code.\"\n\nDoes this mean you can have more than one trait providing access to the same overloaded operators?  (And presumably choose between them via appropriate use of `use`).  If so, (1.) I did not know that, and (2.) Rust gets cooler every day.\n\n(Update: rust may get cooler every day, but the above hypothesis is flawed, because you cannot currently have more than one trait with the `#[lang=\"ord\"]` attribute.  Not sure at the moment if that idea is forever impossible or if we might be able to hack it in post 1.0.  It does not matter terribly for now.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35808557/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35808617",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35808617",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35808617,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODA4NjE3",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T17:35:14Z",
    "updated_at": "2014-02-22T17:37:50Z",
    "body": "I mean that as long as the floating point numbers use the non-total-ordering for the comparison operators, Rust won't have usable comparison operator overloading in generic code. Even the `min` and `max` functions are not correct for floating point types, and need to be switched to `TotalOrd`. The `HashMap` container needs to be switched to `TotalEq` and ordered maps/sets and sorting already use `TotalOrd`. I think it's a real disaster at the moment.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35808617/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35808782",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35808782",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35808782,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODA4Nzgy",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T17:42:04Z",
    "updated_at": "2014-02-22T18:01:34Z",
    "body": "@thestinger So just to be clear, when you said \"So, there's a trait for generic code and a trait for operator overloading with the overloaded operators not usable in generic code.\", this second trait, not usable in generic code (which presumably would be solely for `f32`/`f64`): you did _not_ mean that it would provide access to infix {<, >, <=, >=} for `f32`/`f64`, right?  Just that it would provide access to methods with names like `float_lt`, `float_gt`, etc (or something along those lines) that use the hardware's floating point comparison operations?\n\n(I took your use of the word \"overloaded operators\" to mean \"infix sugar\", but it seems you could not have meant that.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35808782/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35809031",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35809031",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35809031,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODA5MDMx",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T17:49:58Z",
    "updated_at": "2014-02-22T17:49:58Z",
    "body": "No, I think you're misunderstanding what I'm saying. I am only saying that today, `TotalOrd` is for generic code and `Ord` is used only for the operator overloads. The situation today is that `Eq` and `Ord` are nearly useless traits, simply bloating the API documentation and causing confusion. These traits are unspecified, without any guarantees, so generic code can't make use of them. Floating point types would cause nearly any generic code to be _incorrect_ since as generic code it's not going to include the necessary handling of `NaN` like `fmin`, `fmax`, a float-specific `clamp`, etc. \n\nThe `TotalEq` and `TotalOrd` traits are the ones usable by generic code, but do not provide operator overloads. Operators have to be tied to be a specific trait (in this case, `Eq` and `Ord`) or there will be coherency issues. It's not possible for these to inherit from `Eq` and `Ord` for the operator overloads because floating point types will not be implementing the same operations for both. Therefore, generic code has not access to operator overloads at the moment. There aren't convenience methods either (names taken by `Ord`), so it has to call `cmp` and compare against the `Ordering` variants.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35809031/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35809331",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35809331",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35809331,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODA5MzMx",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T17:59:53Z",
    "updated_at": "2014-02-22T18:01:15Z",
    "body": "@thestinger Okay.  You may not believe this, but I _have_ understood the issues you have describing about `Ord` and `Eq` not providing any built-in guarantees that all-implementors adhere to, and I agree with the philosophy you have been espousing (namely that `Ord`/`Eq` are useless as trait bounds unless they do have some semantic laws associated with them).\n\nI was just musing about a way to try to keep the operator-sugar available for floating-point hackers.  I acknowledge that the separation I was proposing has similar problems to that of the existing `Ord`/`TotalOrd` separation; I was mostly just hoping that it would be less confusing (since the distinct roles of \"provide operator sugar\" and \"provide semantic guarantees\" would be better distinguished).\n\nBut I am fine with forcing people who want the hardware `f32`/`f64` operations to have to use different methods without infix sugar.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35809331/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35809523",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35809523",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35809523,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODA5NTIz",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T18:06:58Z",
    "updated_at": "2014-02-22T18:10:02Z",
    "body": "The previously existing proposal is #12435. The `Eq` and `Ord` traits provide the strong guarantees and operator overloads. There will be no need for partial or total ordering traits as it's simply _not possible_ to provide this with a sane trait hierarchy. Floating point types will implement `Eq` and `Ord` with the IEEE754 totalOrder predicate, so deriving and generic code will work correctly.\n\nThe faster hardware floating point ordering can be provided by the `Float` trait as `fcmp`, `fmin`, `fmax`, `fclamp`, `feq`, `fne`, `flt`, [...]. It doesn't need to introduce complexity into the trait hierarchy.\n- generic code should able to use operator overloads\n- **generic** hash tables, ordered maps/sets, min, max, clamp and sorting require more than the hardware floating point comparisons can provide - some of these can be done with it, but doing it correctly requires deviating from a fast implementation (checks for NaN, inability to use three-way comparison functions like `memcmp`)\n- floating point types have both the weak partial ordering **and** a totalOrder predicate defined in IEEE754\n\nFrom a purely performance point of view, LLVM needs you to mark floating point operations with the permitted error and relax the restrictions on floating point transformations to allow generating fast code anyway.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35809523/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35809558",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35809558",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35809558,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODA5NTU4",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T18:08:22Z",
    "updated_at": "2014-02-22T18:08:22Z",
    "body": "(nevermind the above, it was written before you posted the latest comment)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35809558/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35809637",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35809637",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35809637,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODA5NjM3",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T18:11:36Z",
    "updated_at": "2014-02-22T18:12:29Z",
    "body": "I believe the situation can be summarized as, out of the following:\n1. Allow use of comparison operator overloads in generic code (rather than methods),\n2. Have the comparison operators on `f32` and `f64` do what people are accustomed to, and what hardware implements (rather than the total ordering defined separately by IEEE754),\n3. Allow use of generic code with `f32` and `f64`\n\nChoose any two. @thestinger chooses 1. + 3., @pnkfelix is proposing 1. + 2.\n\n 1. + 2. is possible if we have separate a `trait OrdOps` for the operator overloads, and a `trait Ord: OrdOps` which decrees a total order and that if a type impls `Ord`, its `OrdOps` impl must  also be consistent with that order. `f32` and `f64` implement `OrdOps` according to the usual hardware-provided semantics, which do not provide a total order, and do _not_ implement `Ord`. We then separately have newtypes such as `struct TotalF32(f32)` and `struct TotalF64(f64)`, which implement both `OrdOps` and `Ord` according to the IEEE754 total ordering.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35809637/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35810057",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35810057",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35810057,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODEwMDU3",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T18:27:59Z",
    "updated_at": "2014-02-22T18:31:46Z",
    "body": "@glaebhoerl to be honest, when I proposed 1. + 2., I had not thought through the consequences w.r.t. e.g. structs that have `f32`/`f64` fields (which would then not be able to do `deriving(Ord)` under my proposal).  ((I do acknowledge that your newtype wrappers would be a way to accommodate those cases.))\n\nI think I'd prefer 1. + 3. over 1. + 2., given our current set of constraints.  The only person, I think, who suffers under 1.+3. is the poor floating-point hacker, and while I would love to say \"oh haven't they suffered enough?\", I think if we choose nice-looking + short names for the methods then we will be okay.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35810057/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35810234",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35810234",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35810234,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODEwMjM0",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T18:34:05Z",
    "updated_at": "2014-02-22T18:36:37Z",
    "body": "How much potential is there for people who are not \"floating-point hackers\" per se, but happen to have stumbled into using `f32`/`f64` for some particular task, to be bitten by this?\n\nEssentially, I think that means, if you're not aware of the intricacies of floating-point math and just (naively) expect the comparison operators to do something reasonable, does the IEEE754 total ordering qualify?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35810234/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35810368",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35810368",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35810368,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODEwMzY4",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T18:39:30Z",
    "updated_at": "2014-02-22T18:39:30Z",
    "body": "@glaebhoerl do you mean bitten w.r.t. the unexpected performance hit, or bitten w.r.t. the difference in semantics of the results of the operators?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35810368/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35810371",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35810371",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35810371,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODEwMzcx",
    "user": {
      "login": "zkamsler",
      "id": 944662,
      "node_id": "MDQ6VXNlcjk0NDY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/944662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zkamsler",
      "html_url": "https://github.com/zkamsler",
      "followers_url": "https://api.github.com/users/zkamsler/followers",
      "following_url": "https://api.github.com/users/zkamsler/following{/other_user}",
      "gists_url": "https://api.github.com/users/zkamsler/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zkamsler/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zkamsler/subscriptions",
      "organizations_url": "https://api.github.com/users/zkamsler/orgs",
      "repos_url": "https://api.github.com/users/zkamsler/repos",
      "events_url": "https://api.github.com/users/zkamsler/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zkamsler/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T18:39:42Z",
    "updated_at": "2014-02-22T18:39:42Z",
    "body": "For situations that do not involve sorting or containers, the default ieee754 comparison semantics may be preferable, or at least surprising. Having `-0` not be equal to `0` is is usually more trouble than its worth unless you really care about which infinity you are going to get when dividing by zero.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35810371/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35810399",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35810399",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35810399,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODEwMzk5",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T18:40:32Z",
    "updated_at": "2014-02-22T18:40:32Z",
    "body": "@pnkfelix the latter\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35810399/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35810424",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35810424",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35810424,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODEwNDI0",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T18:41:21Z",
    "updated_at": "2014-02-22T22:51:23Z",
    "body": "I think it has been proposed to put in a lint for people using the infix operators directly on `f32`/`f64`, so that you'd have to opt in or be warned about the distinction here.\n\nedit: well, maybe it hasn't been previously proposed.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35810424/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35810770",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35810770",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35810770,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODEwNzcw",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T18:52:17Z",
    "updated_at": "2014-02-22T19:06:30Z",
    "body": "But if it's a footgun to use them at all, it seems suboptimal to leave it lying around and loaded. \n\n(Disclaimer: I'm very much _not_ a floating-point hacker, which is why I'm asking how much of a footgun it is. I'm inferring from the idea that it deserves a lint that it's a significant one.)\n\n> I had not thought through the consequences w.r.t. e.g. structs that have `f32`/`f64` fields (which would then not be able to do `deriving(Ord)` under my proposal).\n\nWhich is just as well! However, they could still do `deriving(OrdOps)`, which is what they would want, I think?\n\n(In theory, if we had something like [GHC's Coercible](http://www.haskell.org/ghc/docs/7.8.1-rc1/html/libraries/base-4.7.0.0/GHC-Exts.html#g:8), it would also allow zero-cost conversions between generic types instantiated with `f32` and `TotalF32` (resp. `f64` and `TotalF64`), which of course we don't yet.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35810770/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35812974",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35812974",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35812974,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODEyOTc0",
    "user": {
      "login": "zkamsler",
      "id": 944662,
      "node_id": "MDQ6VXNlcjk0NDY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/944662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zkamsler",
      "html_url": "https://github.com/zkamsler",
      "followers_url": "https://api.github.com/users/zkamsler/followers",
      "following_url": "https://api.github.com/users/zkamsler/following{/other_user}",
      "gists_url": "https://api.github.com/users/zkamsler/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zkamsler/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zkamsler/subscriptions",
      "organizations_url": "https://api.github.com/users/zkamsler/orgs",
      "repos_url": "https://api.github.com/users/zkamsler/repos",
      "events_url": "https://api.github.com/users/zkamsler/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zkamsler/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-22T20:03:37Z",
    "updated_at": "2014-02-22T20:03:37Z",
    "body": "I just want to remind everyone that there is a reason that the IEEE754 comparison predicates were not defined in terms of the totalOrder predicate. Floating point numbers are not intrinsically totally ordered. One can construct a total ordering over them, but that does not imply that the ordering is appropriate for most uses.\n\nI am not aware of any languages that use the total ordering predicate over the standard comparison predicates. Even those that provide an auxiliary total ordering usually do not fully conform to that defined by IEEE754.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35812974/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35822500",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35822500",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35822500,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODIyNTAw",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T03:07:38Z",
    "updated_at": "2014-02-23T03:07:38Z",
    "body": "@zkamsler: They are not intrinsically weakly ordered either. There are two valid orderings defined by the standard, and Rust can and should provide both. The comparison operators are defined by the `Eq` and `Ord` traits, so if those traits require a total order then that's what floating point types need to implement.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35822500/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35822524",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35822524",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35822524,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODIyNTI0",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T03:10:06Z",
    "updated_at": "2014-02-23T03:11:28Z",
    "body": "@glaebhoerl: Defining the operators with the total ordering predicate is very unlikely to cause any bugs. Nearly all software working with floating point is completely ignoring these kinds of issues anyway, and software written with attention spent on these things has far bigger problems to worry about. It will be far more convenient to be able to sort arrays of floating point numbers and derive `Eq` and `Ord` for types containing them. If anything, it will prevent more bugs than it causes.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35822524/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35825870",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35825870",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35825870,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODI1ODcw",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T07:38:52Z",
    "updated_at": "2014-02-23T07:38:52Z",
    "body": "@glaebhoerl to be honest when I wondered about a lint, I was thinking it would be about the performance pitfall anyway.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35825870/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35839253",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35839253",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35839253,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODM5MjUz",
    "user": {
      "login": "zkamsler",
      "id": 944662,
      "node_id": "MDQ6VXNlcjk0NDY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/944662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zkamsler",
      "html_url": "https://github.com/zkamsler",
      "followers_url": "https://api.github.com/users/zkamsler/followers",
      "following_url": "https://api.github.com/users/zkamsler/following{/other_user}",
      "gists_url": "https://api.github.com/users/zkamsler/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zkamsler/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zkamsler/subscriptions",
      "organizations_url": "https://api.github.com/users/zkamsler/orgs",
      "repos_url": "https://api.github.com/users/zkamsler/repos",
      "events_url": "https://api.github.com/users/zkamsler/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zkamsler/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T18:50:05Z",
    "updated_at": "2014-02-23T18:52:40Z",
    "body": "@thestinger I would argue that it is (although weak is perhaps not the right, word having specific meanings). `NaN` are not numbers, and as such have no logical order relative to anything else, even themselves.\n\nThe thing to realize is that an ordering is _not_ the same thing as a comparison. An ordering is free to over-specify. If one is sorting a vector of floats, it does not matter if `-0` always goes before `0` and denormals that represent the same number are ordered by their exponents. And `NaN`s can placed in any arbitrary location, since there is no natural place that they belong. But sorting `a` before `b` does not imply that that `a` is less than `b`, merely that `a` is not greater than `b`. That is the root of the problem.\n\nI do not suggest that the total ordering should not be exposed, but one should not claim that it should be the default basis for the comparison operators.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35839253/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35839482",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35839482",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35839482,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODM5NDgy",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T18:58:52Z",
    "updated_at": "2014-02-23T19:08:12Z",
    "body": "@zkamsler: The total ordering guarantee is what generic code requires. If the comparison operators do not use the total ordering traits, then generic code is unable to use the operator overloads. It's not possible to write generic code with an ordering trait when basic guarantees about ordering do not hold.\n\n> but one should not claim that it should be the default basis for the comparison operators.\n\nIt's not up to you to say what one should or should not claim. IEEE754 specifies a total ordering, and Rust's generic code needs the total ordering. Traits exist for generic code, so it's going to end up being a requirement for the traits and floating point types might as well implement it so they're usable with generic code and deriving. The traditional ordering will still be available along with functions like `min`, `max`, `clamp` and `cmp` special-cased to handle `NaN` properly unlike the generic ones.\n\nI'm open to an alternative solution but no one is offering a viable one. Crippling the comparison traits to the point where they're unusable for the sake of traditional floating point semantics isn't acceptable. Having 2 traits that aren't really ever usable along with 2 more traits that _are_ usable but lack the convenience is a bit ridiculous...\n\nIf you think the comparison operators are valuable, then push for including user-defined operators, infix call syntax or built-in operators for this. The regular comparison operators belong to `Eq` and `Ord` and they need to provide an ordering usable by generic code.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35839482/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35840004",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35840004",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35840004,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODQwMDA0",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T19:17:16Z",
    "updated_at": "2014-02-23T19:17:48Z",
    "body": "Rust already uses `Option` to represent a lack of information in many places, with `None == None` evaluating to `true`. You've already lost the battle if you think a lack of information should be considered as inequality in Rust. The only reason it's going to have `NaN` at all is to support fast hardware floating point. IEEE754 is not the only approximation of real number arithmetic and may not always be the only kind implemented it hardware. A rustic API for `sqrt` for a non-IEEE754 real number approximation would return `Option` or fail due to a violated precondition.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35840004/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35840066",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35840066",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35840066,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODQwMDY2",
    "user": {
      "login": "zkamsler",
      "id": 944662,
      "node_id": "MDQ6VXNlcjk0NDY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/944662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zkamsler",
      "html_url": "https://github.com/zkamsler",
      "followers_url": "https://api.github.com/users/zkamsler/followers",
      "following_url": "https://api.github.com/users/zkamsler/following{/other_user}",
      "gists_url": "https://api.github.com/users/zkamsler/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zkamsler/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zkamsler/subscriptions",
      "organizations_url": "https://api.github.com/users/zkamsler/orgs",
      "repos_url": "https://api.github.com/users/zkamsler/repos",
      "events_url": "https://api.github.com/users/zkamsler/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zkamsler/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T19:19:32Z",
    "updated_at": "2014-02-23T19:19:32Z",
    "body": "I am cognizant of the needs of generic code, at least to avoid pathological cases involving `NaN`s, but an ordering is not the same as comparison. The expression `a < b` should be true if and only if `a` is a number that is less than `b`. This is no longer true if you base the comparison off of the IEEE754 totalOrder predicate.\n\nEven in generic code, the specific totalOrdering specified in the standard may not be the most appropriate. A float-keyed hashtable should probably not put `-0` and `0` in different buckets, for example.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35840066/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35840296",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35840296",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35840296,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODQwMjk2",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T19:26:29Z",
    "updated_at": "2014-02-23T19:28:50Z",
    "body": "> I am cognizant of the needs of generic code, at least to avoid pathological cases involving `NaN`s, but an ordering is not the same as comparison. The expression `a < b` should be true if and only if `a` is a number that is less than `b`. This is no longer true if you base the comparison off of the IEEE754 totalOrder predicate.\n\nIt will remain true with the `totalOrder` predicate. It's a different ordering, but it's still a valid ordering. You may not be happy that `-0.0` will be considered less than `0.0` with the operators but it's just different, not invalid. `Ord` needs to provide a sane ordering and anything else can be implemented separately.\n\n> Even in generic code, the specific totalOrdering specified in the standard may not be the most appropriate. A float-keyed hashtable should probably not put `-0` and `0` in different buckets, for example.\n\nIt needs to put them in different buckets if the hash isn't the same. The new floating point hash doesn't hash these to the same value. The non-totalOrder comparisons are also broken for a hash table due to `x == x` returning `false` for `NaN`.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35840296/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35840343",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35840343",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35840343,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODQwMzQz",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T19:27:58Z",
    "updated_at": "2014-02-23T19:27:58Z",
    "body": "The comparison operators in Rust come from the `Ord` trait because they correspond to an ordering. It doesn't make to any sense to claim otherwise in the context of Rust. If you want to change how operator overloads work or introduce user-defined operators, then that's a separate issue.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35840343/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35840540",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35840540",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35840540,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODQwNTQw",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T19:33:26Z",
    "updated_at": "2014-02-23T19:39:05Z",
    "body": "> I'm open to an alternative solution but no one is offering a viable one. Crippling the comparison traits to the point where they're unusable for the sake of traditional floating point semantics isn't acceptable. \n\nDid you grok the plan in my [earlier comment](https://github.com/mozilla/rust/issues/12442#issuecomment-35809637)? It would allow non-crippled `Eq` and `Ord` traits _and_ use of comparison operators in generic code abstracted over them _and_ the \"usual\" weak order semantics on floating-point comparisons in non-generic code. The price is that if you want to use `f32` and `f64` with code abstracted over `Eq` or `Ord`, you need to wrap them in a newtype first.\n\n> Having 2 traits that aren't really ever usable along with 2 more traits that are usable but lack the convenience is a bit ridiculous...\n\nOnly two of the traits would ever be used for abstraction, the other two (`EqOps` / `OrdOps`) would only exist to define the mechanism for overloading the operators. Or you could go further and make one trait per operator: just like the situation with `Num` and its \"constituents\".\n\n(Note: I'm not _necessarily_ in favor of this scheme (I'm not really sure myself), I'm arguing for it to help give it proper consideration.)\n\n> Rust already uses Option to represent a lack of information in many places, with None == None evaluating to true. You've already lost the battle if you think a lack of information should be considered as inequality in Rust. \n\n`None` in `Option` doesn't mean lack of information, it is more like an empty container (so not lack of knowledge, but knowledge of lack). You could make another type where it does mean that, and where `Eq` is defined that way. (Or rather you couldn't, if `Eq` had the laws we want to give it. But you know what I mean.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35840540/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35840754",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35840754",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35840754,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODQwNzU0",
    "user": {
      "login": "zkamsler",
      "id": 944662,
      "node_id": "MDQ6VXNlcjk0NDY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/944662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zkamsler",
      "html_url": "https://github.com/zkamsler",
      "followers_url": "https://api.github.com/users/zkamsler/followers",
      "following_url": "https://api.github.com/users/zkamsler/following{/other_user}",
      "gists_url": "https://api.github.com/users/zkamsler/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zkamsler/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zkamsler/subscriptions",
      "organizations_url": "https://api.github.com/users/zkamsler/orgs",
      "repos_url": "https://api.github.com/users/zkamsler/repos",
      "events_url": "https://api.github.com/users/zkamsler/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zkamsler/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T19:40:25Z",
    "updated_at": "2014-02-23T19:40:49Z",
    "body": "It is invalid in the sense that it represents the same number for (almost) all intents and purposes, and it is difficult to suggest that multiple subnormal representations of the same number should not be treated as equal.\n\nas an example:\n\n```\nif a < b {\n    c = 1 / (b - a);\n}\n// or similarly\nif x < 0 {\n    c = 1 / x;\n}\n```\n\nWith the standard comparison predicates, `c` is guaranteed to be valid if `a` and `b` are finite. But if you use the total ordering predicate, you could easily get get a division by zero.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35840754/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35840888",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35840888",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35840888,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODQwODg4",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T19:44:46Z",
    "updated_at": "2014-02-23T19:44:46Z",
    "body": "> `None` in `Option` doesn't mean lack of information, it is more like an empty container. You could make another type where it does mean that, and where `Eq` is defined that way.\n\nIt's idiomatic to use it to represent lack of information - this is often how the standard library uses it.\n\n> Did you grok the plan in my [earlier comment][1]? It would allow non-crippled `Eq` and `Ord` traits _and_ use of comparison operators in generic code abstracted over them _and_ the \"usual\" weak order semantics on floating-point comparisons in non-generic code. The price is that if you want to use `f32` and `f64` with code abstracted over `Eq` or `Ord`, you need to wrap them in a newtype first.\n\nThis issue is opposed to landing #12435. I'm fine with having two sets of floating point types, but there's no way we're going to have more than the `Eq` and `Ord` traits. Any idea involving more comparison traits is an idea that I'm going to shoot down. There's already another issue open about floating point types in a post-#12435 world.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35840888/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35841073",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35841073",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35841073,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODQxMDcz",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T19:50:33Z",
    "updated_at": "2014-02-23T19:50:33Z",
    "body": "Sure, if you don't want to continue discussing the situation using logical arguments then I'll go find something else to do. Carry on.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35841073/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35841640",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35841640",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35841640,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODQxNjQw",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T20:08:04Z",
    "updated_at": "2014-02-23T20:08:04Z",
    "body": "> Sure, if you don't want to continue discussing the situation using logical arguments then I'll go find something else to do. Carry on.\n\nI don't understand why you're saying this. I haven't seen any reasons to keep around 4 comparison traits so I edited #12434 to reflect that there's no consensus on how to fix floating point. There's no reason for it to block changes to the comparison traits because the existing `Eq` and `Ord` have proven to be unusable in generic ordered containers, sorting and convenience functions.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35841640/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35841922",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35841922",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35841922,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODQxOTIy",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T20:16:38Z",
    "updated_at": "2014-02-23T20:16:38Z",
    "body": "@thestinger I'm not willing to shut the discussion down like that, so I'm re-opening the issue.\n\n@glaebhoerl and I were not, IMO, suggesting having 4 comparison traits.  We were suggesting _decoupling_ the comparison trait from the overloaded infix operators.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35841922/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35841943",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35841943",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35841943,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODQxOTQz",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-23T20:17:31Z",
    "updated_at": "2014-02-23T20:23:47Z",
    "body": "@pnkfelix: There was already a previous issue open about floating point. Decoupling the comparison overloads is suggesting having 4 comparison traits because they are comparison overloads. It's not different than the current situation of having an overly complex API without the ability for generic code to make use of the overloads.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35841943/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35878234",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35878234",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35878234,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODc4MjM0",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-24T11:39:11Z",
    "updated_at": "2014-02-24T11:49:19Z",
    "body": "@thestinger I wholeheartedly agree that `Eq` and `Ord` should have meaningful laws, and that code generic over `Eq` and `Ord` should be able to use the comparison operators , knowing that they will respect the laws. The thing is that, as far as I can tell, we don't seem to be disagreeing on the merits, rather we don't seem to be on the same page with regards to the facts of the alternative proposal.\n\n> Decoupling the comparison overloads is suggesting having 4 comparison traits because they are comparison overloads. \n\nThis is true. (Perhaps even more than 4, if we decide to make one trait per operator (as with `Add`, `Sub`, etc.).)\n\n> without the ability for generic code to make use of the overloads\n\nThis is not true. `Eq` and `Ord` would inherit the traits providing the operator overloads, _and would add laws_ stating that e.g. to impl `Ord` for a type, the comparison operators for the type must also be consistent with the total order. A function that's generic over `Ord` would then be able to use the operators, because `Ord` would bring them into scope by way of its supertraits, and could also expect that they behave correctly, because of the laws.\n\nTo be very explicit, let me sketch code:\n\n```\n#[lang(\"eq_ops\")]\ntrait EqOps {\n    fn eq(&self, other: &Self) -> bool;\n    fn ne etc.\n}\n\n#[lang(\"ord_ops\")]\ntrait OrdOps { fn lt, gt, etc. }\n\n// Laws: \n// `a == a`\n// `a == b` <=> `b == a`\n// `(a == b) && (b == c)` => `a == c`\n// `a != b` <=> `!(a == b)`\ntrait Eq: EqOps { }\n\n// Laws:\n// cmp() must implement a total order\n// `a < b` <=> `a.cmp(b) == Less`\n// `a <= b` <=> `a.cmp(b) != Greater`\n// `a == b` <=> `a.cmp(b) == Equal`\n// etc. etc.\ntrait Ord: Eq, OrdOps {\n    fn cmp(&self, other: &Self) -> Ordering;\n}\n\nimpl EqOps for f32 { /* not an equivalence relation */  }\nimpl EqOps for f64 { /* not an equivalence relation */ }\nimpl OrdOps for f32 { /* weak order */ }\nimpl OrdOps for f64 { /* weak order */ }\n\nstruct TotalF32(f32)\nstruct TotalF64(f64)\n\nimpl EqOps for TotalF32 { /* equivalence relation */ }\nimpl EqOps for TotalF64 { /* equivalence relation */ }\nimpl OrdOps for TotalF32 { /* total order */ }\nimpl OrdOps for TotalF64 { /* total order */ }\nimpl Eq for TotalF32 { }\nimpl Eq for TotalF64 { }\nimpl Ord for TotalF32 { fn cmp... }\nimpl Ord for TotalF64 { fn cmp... }\n```\n\nYou're right that this superficially resembles the current situation if we rename `Eq` => `EqOps`, `Ord` => `OrdOps`, `TotalEq` => `Eq`, `TotalOrd` => `Ord`. However, unlike the current situation, `EqOps` and `OrdOps` would not ever be used for abstraction, they would be required to be consistent with `Eq` and `Ord` when they exist, which would inherit them, and code abstracting over `Eq` and `Ord` could safely use the operators and assume the laws.\n\nAre you philosophically opposed to having separate traits just to define operator overloads? If so, do you have the same objection against `Add`, `Sub`, `Mul`, `BitAnd`, `BitOr`, and so on?\n\nApart from that (which I don't consider a significant issue), the main tradeoffs are around the ergonomics for floating-point types.\n\nVersion A:\n- The comparison operators on `f32` and `f64` use the total order, which may be surprising and undesirable (as detailed by @zkamsler)\n- The usual weak order operations are available separately through the `Floating` trait\n- `f32` and `f64` can be used with code requiring `Eq` and `Ord` \"out of the box\"\n\nVersion B:\n- The comparison operators on `f32` and `f64` use the same weak order semantics as every other language\n- `f32` and `f64` can't be used with code requiring `Eq` and `Ord`, instead you must use `TotalF32`/`TotalF64` (which are freely convertible)\n- structs containing `f32`/`f64` could only derive `EqOps` and `OrdOps`, not `Eq` and `Ord`. structs containing `TotalF32`/`TotalF64` could derive `Eq` and `Ord` as usual.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35878234/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35881443",
    "html_url": "https://github.com/rust-lang/rust/issues/12442#issuecomment-35881443",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/12442",
    "id": 35881443,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODgxNDQz",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-24T12:30:12Z",
    "updated_at": "2014-02-24T12:30:52Z",
    "body": "I closed the pull request and corresponding RFC. The current design of a separate trait for the operator overloads and total ordering can remain in place. I've opened #12517 to cover renaming the traits to reflect the semantics as they are today (as proposed by @glaebhoerl but using `Cmp` instead of `OrdOps` as it's unrelated to ordering) and adding trait inheritance so the operators are available in generic code.\n\nI've edited the description in #5585 to reflect that the total ordering needs to be implemented via wrapper types in order to implement the traits. This is a long-standing issue and fixing it isn't a priority, as long as generic code is updated to stop using the operator overloading traits when it needs stronger guarantees.\n\nI don't think we need more than these 2 issues. There is clearly no perfect solution to this, and I am not interested in trying to drastically change the design anymore. It just needs to be clearly defined with the existing generic code fixed.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/35881443/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
