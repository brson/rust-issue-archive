[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8799104",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-8799104",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 8799104,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg3OTkxMDQ=",
    "user": {
      "login": "jesse99",
      "id": 425055,
      "node_id": "MDQ6VXNlcjQyNTA1NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/425055?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jesse99",
      "html_url": "https://github.com/jesse99",
      "followers_url": "https://api.github.com/users/jesse99/followers",
      "following_url": "https://api.github.com/users/jesse99/following{/other_user}",
      "gists_url": "https://api.github.com/users/jesse99/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jesse99/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jesse99/subscriptions",
      "organizations_url": "https://api.github.com/users/jesse99/orgs",
      "repos_url": "https://api.github.com/users/jesse99/repos",
      "events_url": "https://api.github.com/users/jesse99/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jesse99/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-09-23T14:47:35Z",
    "updated_at": "2012-09-23T14:47:53Z",
    "body": "I'm planning on writing four of these:\n- (ascii art) shapes: traits, structs, operator overloading\n- find-bad-words: io, tasks, rendezvous\n- json-config: multi-file exe, command line parsing, pattern matching, io, json\n- simple-lib: multi-file lib (this one probably won't do anything useful)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8799104/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8800841",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-8800841",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 8800841,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg4MDA4NDE=",
    "user": {
      "login": "jesse99",
      "id": 425055,
      "node_id": "MDQ6VXNlcjQyNTA1NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/425055?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jesse99",
      "html_url": "https://github.com/jesse99",
      "followers_url": "https://api.github.com/users/jesse99/followers",
      "following_url": "https://api.github.com/users/jesse99/following{/other_user}",
      "gists_url": "https://api.github.com/users/jesse99/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jesse99/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jesse99/subscriptions",
      "organizations_url": "https://api.github.com/users/jesse99/orgs",
      "repos_url": "https://api.github.com/users/jesse99/repos",
      "events_url": "https://api.github.com/users/jesse99/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jesse99/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-09-23T17:56:16Z",
    "updated_at": "2012-09-23T17:56:16Z",
    "body": "Here's the ascii art example. I decided not to include operator overloading:\n\n```\n// ASCII art renderer.\n// Demonstrates traits, impls, non-copyable struct, unit testing.\n// To run execute: rustc --test art.rs && ./art\n\n// Rust's core library is tightly bound to the language itself so it is automatically linked in.\n// However the std library is designed to be optional (for code that must run on constrained\n// environments like embedded devices or special environments like kernel code) so it must\n// be explicitly linked in.\nextern mod std;\n\n// Extern mod controls linkage. Use controls the visibility of names to modules that are\n// already linked in. Using WriterUtil allows us to use the write_line method.\nuse io::WriterUtil;\n\n// Represents a position on a canvas.\nstruct Point\n{\n    x: int,\n    y: int,\n}\n\n// Represents an offset on a canvas. (This has the same structure as a Point.\n// but different semantics). In a real app we could implement traits like core::ops::Add\n// to allow points and rectangles to be offset using code like: `pt + delta`.\nstruct Size\n{\n    width: int,\n    height: int,\n}\n\n// Represents a rectangle on a canvas.\nstruct Rect\n{\n    top_left: Point,\n    size: Size,\n}\n\n// Contains the information needed to do shape rendering via ASCII art.\nstruct AsciiArt\n{\n    // Fields are immutable, by default, so making them public won't\n    // cause problems (except for making it more difficult to change\n    // the names or types of fields).\n    width: uint,\n    height: uint,\n    fill: char,\n    priv lines: ~[~[mut char]],\n\n    // This struct can be quite large so we'll disable copying: developers need\n    // to either pass these structs around via borrowed pointers or move them.\n    drop {}\n}\n\n// It's common to define a constructor sort of function to create struct instances.\n// If there is a canonical constructor it is typically named the same as the type.\n// Other constructor-ish functions are typically named from_foo, from_bar, etc. \nfn AsciiArt(width: uint, height: uint, fill: char) -> AsciiArt\n{\n    // Use anonymous functions to build a vector of vectors containing\n    // blank characters for each position in our canvas.\n    let lines = do vec::build_sized(height)\n        |push|\n        {\n            for height.times\n            {\n                let mut line = ~[mut];\n                vec::grow_set(line, width-1, '.', '.');\n                push(line);\n            }\n        };\n\n    // Rust code often returns values by omitting the trailing semi-colon\n    // instead of using an explicit return statement.\n    move AsciiArt {width: width, height: height, fill: fill, lines: lines}\n}\n\n// Methods particular to the AsciiArt struct.\nimpl AsciiArt\n{\n    fn add_pt(x: int, y: int)\n    {\n        if x >= 0 && x < self.width as int\n        {\n            if y >= 0 && y < self.height as int\n            {\n                // Note that numeric types don't implicitly convert to each other.\n                let v = y as uint;\n                let h = x as uint;\n\n                // Vector subscripting will normally copy the element, but &v[i]\n                // will return a reference which is what we need because the\n                // element is: 1) potentially large 2) needs to be modified.\n                let row = &self.lines[v];\n                row[h] = self.fill;\n            }\n        }\n    }\n}\n\n// Allows AsciiArt to be converted to a string using the libcore ToStr trait.\n// Note that the %s fmt! specifier will not call this automatically.\nimpl AsciiArt : ToStr\n{\n    fn to_str() -> ~str\n    {\n        // Convert each line into a string.\n        let lines = do self.lines.map |line| {str::from_chars(line)};\n\n        // Concatenate the lines together using a new-line.\n        str::connect(lines, \"\\n\")\n    }\n}\n\n// This is similar to an interface in other languages: it defines a protocol which\n// developers can implement for arbitrary concrete types.\ntrait Canvas\n{\n    fn add_point(shape: Point);\n    fn add_rect(shape: Rect);\n\n    // Unlike interfaces traits support default implementations.\n    // Which currently ICEs: see https://github.com/mozilla/rust/issues/3563\n//    fn add_points(shapes: &[Point])\n//    {\n//        for shapes.each |pt| {self.add_point(pt)};\n//    }\n}\n\n// Here we provide an implementation of the Canvas methods for AsciiArt.\n// Other implementations could also be provided (e.g. for PDF or Apple's Quartz)\n// and code can use them polymorphically via the Canvas trait.\nimpl AsciiArt : Canvas\n{\n    fn add_point(shape: Point)\n    {\n        self.add_pt(shape.x, shape.y);\n    }\n\n    fn add_rect(shape: Rect)\n    {\n        // Add the top and bottom lines.\n        for int::range(shape.top_left.x, shape.top_left.x + shape.size.width)\n        |x|\n        {\n            self.add_pt(x, shape.top_left.y);\n            self.add_pt(x, shape.top_left.y + shape.size.height - 1);\n        }\n\n        // Add the left and right lines.\n        for int::range(shape.top_left.y, shape.top_left.y + shape.size.height)\n        |y|\n        {\n            self.add_pt(shape.top_left.x, y);\n            self.add_pt(shape.top_left.x + shape.size.width - 1, y);\n        }\n    }\n}\n\n// Rust's unit testing framework is currently a bit under-developed so we'll use\n// this little helper. The cfg is a conditional compilation attribute that enables\n// check_strs only for unit testing builds.\n#[cfg(test)]\npub fn check_strs(actual: &str, expected: &str) -> bool\n{\n    if actual != expected\n    {\n        io::stderr().write_line(fmt!(\"Found:\\n%s\\nbut expected\\n%s\", actual, expected));\n        return false;\n    }\n    return true;\n}\n\n#[test]\nfn test_ascii_art_ctor()\n{\n    let art = AsciiArt(3, 3, '*');\n    assert check_strs(art.to_str(), \"...\\n...\\n...\");\n}\n\n#[test]\nfn test_add_pt()\n{\n    let art = AsciiArt(3, 3, '*');\n    art.add_pt(0, 0);\n    art.add_pt(0, -10);\n    art.add_pt(1, 2);\n    assert check_strs(art.to_str(), \"*..\\n...\\n.*.\");\n}\n\n#[test]\nfn test_shapes()\n{\n    let art = AsciiArt(4, 4, '*');\n    art.add_rect(Rect {top_left: Point {x: 0, y: 0}, size: Size {width: 4, height: 4}});\n    art.add_point(Point {x: 2, y: 2});\n    assert check_strs(art.to_str(), \"****\\n*..*\\n*.**\\n****\");\n}\n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8800841/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8803285",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-8803285",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 8803285,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg4MDMyODU=",
    "user": {
      "login": "jesse99",
      "id": 425055,
      "node_id": "MDQ6VXNlcjQyNTA1NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/425055?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jesse99",
      "html_url": "https://github.com/jesse99",
      "followers_url": "https://api.github.com/users/jesse99/followers",
      "following_url": "https://api.github.com/users/jesse99/following{/other_user}",
      "gists_url": "https://api.github.com/users/jesse99/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jesse99/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jesse99/subscriptions",
      "organizations_url": "https://api.github.com/users/jesse99/orgs",
      "repos_url": "https://api.github.com/users/jesse99/repos",
      "events_url": "https://api.github.com/users/jesse99/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jesse99/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-09-23T21:35:28Z",
    "updated_at": "2012-09-23T21:35:28Z",
    "body": "Here's a task example:\n\n```\n// Searches text files for \"bad\" words.\n// Demonstrates tasks and sharing large objects across tasks (ARC).\n// To run execute: rustc --test bad_words.rs && ./bad_words\nextern mod std;\n\nuse comm::{Chan, Port};\nuse io::WriterUtil;\nuse mod std::arc;\nuse std::arc::{ARC};\n\n// Contains details about a file (or the unit test equivalent).\nstruct Contents\n{\n    fname: ~str,\n    lines: ~[~str],\n}\n\n// Used to lazily load file contents.\ntype FileLoader = fn~ () -> ~Contents;\n\n// This function runs within a dedicated task, scans through lines\n// looking for words in bad, and sends a report with the results\n// using chan.\nfn scan_words(loader: FileLoader, bad: &~[~str], chan: Chan<~str>)\n{\n    let mut results = ~\"\";\n\n    // Defer loading files until it's neccesary (we don't want to read in \n    // thousands of files before we even spin up a task).\n    let contents = loader();\n    for contents.lines.eachi\n    |i, line|\n    {\n        for bad.each\n        |b|\n        {\n            if line.contains(*b)\n            {\n                // TODO: is it efficient to concantenate strings like this?\n                results += fmt!(\"%s:%? found %s\\n\", contents.fname, i+1, b.trim_right());\n            }\n        }\n    }\n\n    chan.send(move results);\n}\n\n// Uses multiple tasks to find the bad words in each file. Reports from tasks\n// that find bad words are returned.\nfn scan_files(+loaders: ~[FileLoader], +bad: ~[~str]) -> ~str\n{\n    fn massage_results(result: ~[@~str]) -> ~str\n    {\n        // We'll get the results back in a non-deterministic order so to simplify unit testing\n        // we'll do a sort.\n        let result = std::sort::merge_sort(|x, y| {x <= y}, result);\n\n        // Convert to ~str so that connect works. This does do a copy, but it's not a copy\n        // of a full line from a file.\n        let result = do result.map |r| {copy *r};\n\n        move str::connect(result, \"\")\n    }\n\n    let mut outstanding_tasks = loaders.len();\n    let port = Port();\n    let chan = Chan(port);\n\n    // We take care throughout to avoid copying potentially large objects. Sending \n    // objects to tasks is especially delicate for the bad word vector because we\n    // need to share it across tasks and tasks do not normally share state. However\n    // we can use the std::arc module to share immutable data across tasks.\n    let bad = ARC(bad);\n\n    // Kick off a task to process each file. This can potentially kick off thousands\n    // of tasks, but that's OK because tasks are much lighter-weight than threads\n    // and tasks run until they finish or block (in which case another task on the\n    // thread wakes up).\n    //\n    // We use consume here which acts like eachi except that the elements are moved \n    // into the closure instead of copied (and the vector is emptied afterwards).\n    do vec::consume(loaders)\n    |_i, loader|\n    {\n        // arc::clone is efficient because it clones the ARC, not the data the ARC contains.\n        let bad = arc::clone(&bad);\n\n        do task::spawn |move loader, move bad| {scan_words(loader, arc::get(&bad), chan)};\n    }\n\n    // Collect results until every task has finished.\n    let mut result = ~[];\n    while outstanding_tasks > 0\n    {\n        let r = port.recv();\n        if r.is_not_empty()\n        {\n            // Push an @~str onto result so that sort will work (sort requires implicitly copyable strings).\n            vec::push(result, @r);\n        }\n        outstanding_tasks -= 1;\n    }\n\n    move massage_results(result)\n}\n\n#[cfg(test)]\npub fn check_strs(actual: &str, expected: &str) -> bool\n{\n    if actual != expected\n    {\n        io::stderr().write_line(fmt!(\"Found:\\n%s\\nbut expected\\n%s\", actual, expected));\n        return false;\n    }\n    return true;\n}\n\n// Make files large enough that the tasks actually have to do a significant amount of work.\n#[cfg(test)]\nfn make_good_file(fname: &str) -> FileLoader\n{\n    const num_files: uint = 20_000;    // underscores are ignored in numeric literals\n\n    let fname = fname.to_unique();\n    let f: FileLoader =\n    ||\n    {\n        move ~Contents\n        {\n            fname: fname,\n            lines: do vec::build_sized(num_files)\n                |push|\n                {\n                    for num_files.times {push(move ~\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\")}\n                },\n        }\n    };\n    f\n}\n\n// Type inference usually works very well, but closures sometimes need help which\n// is why we have these two helper functions.\n#[cfg(test)]\nfn make_bad1(fname: &str) -> FileLoader\n{\n    let fname = fname.to_unique();\n    let f: FileLoader = || {move ~Contents {fname: copy fname, lines: ~[~\"this line is ok\", ~\"but ugh is not\", ~\"another good line\"]}};\n    f\n}\n\n#[cfg(test)]\nfn make_bad2(fname: &str) -> FileLoader\n{\n    let fname = fname.to_unique();\n    let f: FileLoader = || {move ~Contents {fname: copy fname, lines: ~[~\"this line is ok\", ~\"another good line\", ~\"ack is not cool\"]}};\n    f\n}\n\n// Load num_times files (and spawn that many tasks). Up to two files\n// will include bad words.\n#[cfg(test)]\nfn run_test(num_files: uint)\n{\n    let mut files = do vec::build_sized(num_files)\n        |push|\n        {\n            for num_files.timesi\n            |i|\n            {\n                let fname = fmt!(\"f%?\", i);\n                let loader: FileLoader =\n                    match i\n                    {\n                        1  => make_bad1(fname),\n                        42 => make_bad2(fname),\n                        _  => make_good_file(fname),\n                    };\n                push(move loader);\n            }\n        };\n\n    let bad = ~[~\"ugh \", ~\"ack\"];\n    let actual = scan_files(files, bad);\n    if num_files >= 42\n    {\n        assert check_strs(actual, \"f1:2 found ugh\\nf42:3 found ack\\n\");\n    }\n    else if num_files >= 1\n    {\n        assert check_strs(actual, \"f1:2 found ugh\\n\");\n    }\n    else\n    {\n        assert check_strs(actual, \"\");\n    }\n}\n\n#[test]\nfn test_empty()\n{\n    assert check_strs(scan_files(~[], ~[~\"ack\", ~\"ugh\"]), \"\");\n}\n\n#[test]\nfn test_few()\n{\n    run_test(4);\n}\n\n#[test]\nfn test_many()\n{\n    // On an 8-core Mac 10 system threads are created to run these 200 tasks.\n    run_test(200);\n}\n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8803285/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8803363",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-8803363",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 8803363,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg4MDMzNjM=",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-09-23T21:43:33Z",
    "updated_at": "2012-09-23T21:43:33Z",
    "body": "This sounds like a great idea to me. To keep it up building we will need to put it in the repo (at least for now - I'd also like to scrape the wiki for test cases).\n\nFWIW, I updated the [FAQ](https://github.com/mozilla/rust/wiki/Doc-language-FAQ) recently to link to interesting bits of code around the Rust-sphere.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8803363/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8804338",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-8804338",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 8804338,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg4MDQzMzg=",
    "user": {
      "login": "jesse99",
      "id": 425055,
      "node_id": "MDQ6VXNlcjQyNTA1NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/425055?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jesse99",
      "html_url": "https://github.com/jesse99",
      "followers_url": "https://api.github.com/users/jesse99/followers",
      "following_url": "https://api.github.com/users/jesse99/following{/other_user}",
      "gists_url": "https://api.github.com/users/jesse99/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jesse99/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jesse99/subscriptions",
      "organizations_url": "https://api.github.com/users/jesse99/orgs",
      "repos_url": "https://api.github.com/users/jesse99/repos",
      "events_url": "https://api.github.com/users/jesse99/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jesse99/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-09-23T23:48:00Z",
    "updated_at": "2012-09-23T23:48:00Z",
    "body": "I figured they'd go into the repo at some point. But I'd like to see some example code on the wiki for 0.4, even if there isn't time to integrate them with git and testing.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8804338/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8806416",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-8806416",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 8806416,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg4MDY0MTY=",
    "user": {
      "login": "jesse99",
      "id": 425055,
      "node_id": "MDQ6VXNlcjQyNTA1NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/425055?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jesse99",
      "html_url": "https://github.com/jesse99",
      "followers_url": "https://api.github.com/users/jesse99/followers",
      "following_url": "https://api.github.com/users/jesse99/following{/other_user}",
      "gists_url": "https://api.github.com/users/jesse99/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jesse99/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jesse99/subscriptions",
      "organizations_url": "https://api.github.com/users/jesse99/orgs",
      "repos_url": "https://api.github.com/users/jesse99/repos",
      "events_url": "https://api.github.com/users/jesse99/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jesse99/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-09-24T03:08:01Z",
    "updated_at": "2012-09-24T03:09:03Z",
    "body": "Here is a multi-file crate example.\n\ncrate.rc:\n\n```\n// Multi file crates use an rc file to tell the compiler about various pieces of\n// metadata and about which modules are part of the crate.\n\n// This is the required bit of meta-data for a crate.\n// The uuid should be generated using uuidgen (or the equivalent).\n#[link(name = \"json-config\", vers = \"1.0\", uuid = \"60B3CC26-037D-443A-891A-FB265232BE8D\")];\n\n// These attributes are used by rustdoc and rustc --ls.\n#[author = \"Jesse Jones\"];\n#[license = \"MIT\"];\n#[doc = \"Multi-file crate exe example\"];\n\n// These control various compiler lint passes. You can see them all by doing\n// `rustc -W help`.\n#[warn(unused_imports)];\n#[warn(deprecated_pattern)];\n\n// Link in the rust std library.\nextern mod std;\n\n// List our modules. When this crate is compiled the files with the same names\n// will be automatically compiled into the crate.\nmod main;\nmod options;\n```\n\nmain.rs:\n\n```\n// Uses a JSON file to store configuration options.\n// Demonstrates a multi-file crate, command line parsing, pattern matching, and file IO.\n// To run the executable: rustc -o json-config crate.rc && ./json-config -v\n\n// Note that main in rust does not return an error code. If you want to return\n// a non-zero exit code then use libc::exit.\nfn main(args: ~[~str])\n{\n    let options = options::parse_command_line(args);\n    io::println(fmt!(\"Working for %s\", options.user));\n\n    if options.verbose\n    {\n        io::println(fmt!(\"Options: %?\", options));\n    }\n}\n```\n\noptions.rs:\n\n```\nuse json = std::json;\nuse Json = std::json::Json;\nuse std::map::{HashMap};\nuse io::WriterUtil;\nuse std::getopts::*;\n\n// Various options used to control the behavior of the exe.\nstruct Options\n{\n    // these are from the config file\n    user: ~str,\n    poll_rate: float,\n\n    // these are from the command line\n    verbose: bool,\n}\n\n// Parses the command line, reads in a json config file, and returns the results\n// using an Options struct.\n#[allow(implicit_copies)]    // args is full of non-implicitly copyable\n#[allow(non_implicitly_copyable_typarams)]\nfn parse_command_line(args: ~[~str]) -> Options\n{\n    // It's good practice to do this before invoking getopts because getopts\n    // will fail if a required option is missing (although at the moment all\n    // of our arguments are optional).\n    if args.contains(~\"-h\") || args.contains(~\"--help\")\n    {\n        print_usage();\n        libc::exit(0);\n    }\n\n    let opts = ~[\n        optopt(~\"config\"),        // *opt's take an optional argument\n        optflag(~\"h\"),            // *flag's take no arguments\n        optflag(~\"help\"),\n        optflag(~\"v\"),\n        optflag(~\"verbose\"),\n        optflag(~\"V\"),\n        optflag(~\"version\"),\n    ];\n    let matched = match getopts(vec::tail(args), opts)   // first argument is the exe name\n    {\n        result::Ok(copy m) => {m}\n        result::Err(ref f) => {io::stderr().write_line(fail_str(*f)); libc::exit(1)}\n    };\n    if opt_present(matched, ~\"version\")\n    {\n        io::println(fmt!(\"json-config %s\", exe_version));\n        libc::exit(0);\n    }\n    else if matched.free.len() != 0\n    {\n        io::stderr().write_line(fmt!(\"Unexpected positional argument(s): %?\", matched.free));\n        libc::exit(1);\n    }\n\n    let config = if opt_present(matched, ~\"config\") {opt_str(matched, ~\"config\")} else {~\"config.json\"};\n    let options = Options\n    {\n        user: ~\"\",\n        poll_rate: 0.0,\n        verbose: opt_present(matched, ~\"v\") || opt_present(matched, ~\"verbose\"),\n    };\n    let options = add_config(&path::Path(config), &options);\n    validate_options(&options);\n    move options\n}\n\n// https://github.com/mozilla/rust/issues/3567\npriv const exe_version: &str = \"1.0\";\n\n// Items currently default to public (package and external visibility).\n// Private items are private to their module (these semantics may change in the future).\npriv fn validate_options(config: &Options)\n{\n    if config.user.is_empty()\n    {\n        io::stderr().write_line(\"user isn't set\");\n        libc::exit(1);\n    }\n    if config.poll_rate <= 0.0\n    {\n        io::stderr().write_line(fmt!(\"poll_rate should be positive but is %f\", config.poll_rate));\n        libc::exit(1);\n    }\n}\n\npriv fn print_usage()\n{\n    io::println(fmt!(\"json-config %s - rust sample app\", exe_version));\n    io::println(\"\");\n    io::println(\"./json-config [options]\");\n    io::println(\"--config=FILE  use a custom JSON config file (defaults to config.json)\");\n    io::println(\"-h, --help     print this message and exits\");\n    io::println(\"-v, --verbose  enable extra output\");\n    io::println(\"--version      print the version number and exits\");\n}\n\n// Add informatiom from the config file to config and return a new config.\npriv fn add_config(path: &Path, config: &Options) -> Options\n{\n    // Comments are not part of the JSON spec, but they are awfully nice\n    // to have in config files so we'll pre-process the json files and strip\n    // them out ourselves.\n    fn read_json(reader: io::Reader) -> ~str\n    {\n        let mut contents = ~\"\";\n\n        for reader.each_line\n        |line|\n        {\n            if !line.trim_left().starts_with(\"#\")\n            {\n                contents += line;\n            }\n        }\n\n        return contents;\n    }\n\n    match io::file_reader(path)\n    {\n        result::Ok(reader) =>\n        {\n            match json::from_str(read_json(reader))\n            {\n                result::Ok(std::json::Dict(data)) =>\n                {\n                    move Options\n                    {\n                        user: get_config_str(path, data, ~\"user\"),\n                        poll_rate: get_config_float(path, data, ~\"poll_rate\"),\n                        .. *config   // this is the functional update syntax for structs\n                    }\n                }\n                result::Ok(x) =>\n                {\n                    io::stderr().write_line(fmt!(\"Error parsing '%s': expected json::Dict but found %?.\", path.to_str(), x));\n                    libc::exit(1)\n                }\n                result::Err(err) =>\n                {\n                    io::stderr().write_line(fmt!(\"Error parsing '%s' on line %?: %s.\", path.to_str(), err.line, *err.msg));\n                    libc::exit(1)\n                }\n            }\n        }\n        result::Err(ref err) =>\n        {\n            io::stderr().write_line(fmt!(\"Error reading '%s': %s.\", path.to_str(), *err));\n            libc::exit(1)\n        }\n    }\n}\n\n// Search the json for a String named key.\n#[allow(implicit_copies)]    // json needs to stop using ~str, see https://github.com/mozilla/rust/issues/3350\n#[allow(non_implicitly_copyable_typarams)]\npriv fn get_config_str(path: &Path, data: HashMap<~str, Json>, key: ~str) -> ~str\n{\n    match data.find(key)\n    {\n        option::Some(json::String(value)) =>\n        {\n            copy *value\n        }\n        option::Some(x) =>\n        {\n            io::stderr().write_line(fmt!(\"In '%s' %s was expected to be a json::String but was %?.\", path.to_str(), key, x));\n            libc::exit(1)\n        }\n        option::None =>\n        {\n            io::stderr().write_line(fmt!(\"Expected to find %s in '%s'.\", key, path.to_str()));\n            libc::exit(1)\n        }\n    }\n}\n\n// Search the json for a Num named key.\n#[allow(implicit_copies)]\n#[allow(non_implicitly_copyable_typarams)]\npriv fn get_config_float(path: &Path, data: HashMap<~str, Json>, key: ~str) -> float\n{\n    match data.find(key)\n    {\n        option::Some(json::Num(value)) =>\n        {\n            value\n        }\n        option::Some(x) =>\n        {\n            io::stderr().write_line(fmt!(\"In '%s' %s was expected to be a json::Num but was %?.\", path.to_str(), key, x));\n            libc::exit(1)\n        }\n        option::None =>\n        {\n            io::stderr().write_line(fmt!(\"Expected to find %s in '%s'.\", key, path.to_str()));\n            libc::exit(1)\n        }\n    }\n}\n```\n\nconfig.json:\n\n```\n{\n    \"user\": \"Joe Bob\",\n    # poll_rate is in seconds\n    \"poll_rate\": 100\n}\n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8806416/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8900331",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-8900331",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 8900331,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg5MDAzMzE=",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-09-26T18:38:00Z",
    "updated_at": "2012-09-26T18:38:00Z",
    "body": "Putting these in doc/example-foo.md and hooking them up to the test driver in mk/tests.mk would be a good way to keep them building. The multi-file example would need some new support in extract-tests.py. They could be linked from the 'What next?' section of the tutorial.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8900331/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8999861",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-8999861",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 8999861,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg5OTk4NjE=",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-09-29T01:57:00Z",
    "updated_at": "2012-09-29T01:57:00Z",
    "body": "Somebody posted a nice example http://www.reddit.com/r/rust/comments/10lmg0/example_in_rust_04_conways_game_of_life/\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/8999861/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/9210203",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-9210203",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 9210203,
    "node_id": "MDEyOklzc3VlQ29tbWVudDkyMTAyMDM=",
    "user": {
      "login": "jesse99",
      "id": 425055,
      "node_id": "MDQ6VXNlcjQyNTA1NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/425055?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jesse99",
      "html_url": "https://github.com/jesse99",
      "followers_url": "https://api.github.com/users/jesse99/followers",
      "following_url": "https://api.github.com/users/jesse99/following{/other_user}",
      "gists_url": "https://api.github.com/users/jesse99/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jesse99/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jesse99/subscriptions",
      "organizations_url": "https://api.github.com/users/jesse99/orgs",
      "repos_url": "https://api.github.com/users/jesse99/repos",
      "events_url": "https://api.github.com/users/jesse99/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jesse99/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-10-07T17:31:55Z",
    "updated_at": "2012-10-07T17:31:55Z",
    "body": "Here is another:\n\n```\n// Fixed size buffer: when it is at capacity push will drop the oldest element.\n// Demonstrates custom data structure, custom iteration, operator overloading, struct encapsulation.\n// To run execute: rustc --test ring_buffer.rs && ./ring_buffer\nextern mod std;\n\n// This contains the data that represents our ring buffer. In general only one \n// allocation occurs: when the struct is first created and buffer is allocated.\n// Copying a RingBuffer will cause a heap allocation but the compiler will\n// warn us on attempts to copy it implicitly.\nstruct RingBuffer<T: Copy>\n{\n    priv mut buffer: ~[T],\n    priv capacity: uint,            // number of elements the buffer is able to hold (can't guarantee that vec capacity is exactly what we set it to)\n    priv mut size: uint,            // number of elements with legit values in the buffer\n    priv mut next: uint,            // index at which new elements land\n}\n\n// By convention structs are created with a function named after the type\n// or with functions like from_foo.\nfn RingBuffer<T: Copy>(capacity: uint) -> RingBuffer<T>\n{\n    let ring = RingBuffer {buffer: ~[], capacity: capacity, size: 0, next: 0};\n    vec::reserve(ring.buffer, capacity);\n    ring\n}\n\n// This is an impl which does not implement a trait: it merely provides some\n// methods for our struct.\nimpl<T: Copy> RingBuffer<T>\n{\n    pure fn len() -> uint\n    {\n        self.size\n    }\n\n    pure fn is_empty() -> bool\n    {\n        self.size == 0\n    }\n\n    pure fn is_not_empty() -> bool\n    {\n        self.size != 0\n    }\n\n    pure fn buffer() -> uint\n    {\n        self.size\n    }\n\n    fn clear()\n    {\n        vec::truncate(self.buffer, 0);\n        self.size = 0;\n        self.next = 0;\n    }\n\n    fn push(element: T)\n    {\n        assert self.capacity > 0;\n\n        if self.size < self.capacity\n        {\n            vec::push(self.buffer, element);\n            self.size += 1;\n        }\n        else\n        {\n            self.buffer[self.next] = element;\n        }\n        self.next = (self.next + 1) % self.capacity;\n    }\n}\n\n// This is how rust handles operator overloading. Here we provide\n// an implementation for ops::Index which allows users to subscript\n// a RingBuffer using the [] operator.\nimpl<T: Copy> RingBuffer<T> : ops::Index<uint, T>\n{\n    // The && represents an argument mode (in this case pass by pointer).\n    // These are going away in rust 0.4.\n    pure fn index(&&index: uint) -> T\n    {\n        assert index < self.size;\n\n        if self.size < self.capacity\n        {\n            self.buffer[index]\n        }\n        else\n        {\n            self.buffer[(self.next + index) % self.capacity]\n        }\n    }\n}\n\n// Here we provide support for basic iteration. Doing this allows use of a bunch of\n// handy functions from the iter module: eachi, all, any, filter_to_vec, map_to_vec, etc.\nimpl<T: Copy> RingBuffer<T> : BaseIter<T>\n{\n    // Typically iteration functions like each are called with the aid of the for keyword\n    // which provides some sugar for looping: the closure used with for returns (),\n    // break aborts the loop, loop skips to the start of the loop, and return returns a\n    // value from the named function the loop was defined within.\n    pure fn each(callback: fn(v: &T) -> bool)\n    {\n        let mut i = 0;\n        while i < self.size\n        {\n            // T may be large or something that requires a heap allocation to copy.\n            // So, by convention, each methods pass a borrowed pointer into the\n            // closure.\n            if !callback(&self[i])\n            {\n                break;\n            }\n            i += 1;\n        }\n    }\n\n    pure fn size_hint() -> option::Option<uint>\n    {\n        option::Some(self.size)\n    }\n}\n\n// Users can always use the %? format specifier to display the full details of\n// structs (and any other type). But because of the way that elements wrap\n// around this can be confusing. Here we provide a to_str method that shows\n// the elements in the same order as they appear to users.\n//\n// Note that in this case we constrain T to be both a copyable type and a type\n// that implements the ToStr trait. (The later allows the e.to_str() call to compile).\nimpl<T: Copy ToStr> RingBuffer<T> : ToStr\n{\n    fn to_str() -> ~str\n    {\n        let elements = do iter::map_to_vec(self) |e| {e.to_str()};\n        fmt!(\"[%s]\", str::connect(elements, \", \"))\n    }\n}\n\n#[test]\nfn test_basics()\n{\n    // size 0\n    let buffer: RingBuffer<int> = RingBuffer(0);    // rust type inference works very well, but not in this case\n    assert buffer.len() == 0;\n\n    // size 1\n    let buffer = RingBuffer(1);\n    assert buffer.len() == 0;\n\n    buffer.push(2);\n    assert buffer.len() == 1;\n    assert buffer[0] == 2;\n\n    buffer.push(3);\n    assert buffer.len() == 1;\n    assert buffer[0] == 3;\n\n    // size 4\n    let buffer = RingBuffer(4);\n    assert buffer.len() == 0;\n\n    buffer.push(1);\n    assert buffer.len() == 1;\n    assert buffer[0] == 1;\n\n    buffer.push(2);\n    assert buffer.len() == 2;\n    assert buffer[0] == 1;\n    assert buffer[1] == 2;\n\n    buffer.push(3);\n    assert buffer.len() == 3;\n    assert buffer[0] == 1;\n    assert buffer[1] == 2;\n    assert buffer[2] == 3;\n\n    buffer.push(4);\n    assert buffer.len() == 4;\n    assert buffer[0] == 1;\n    assert buffer[1] == 2;\n    assert buffer[2] == 3;\n    assert buffer[3] == 4;\n\n    // At this point the elements have wrapped around.\n    buffer.push(5);\n    assert buffer.len() == 4;\n    assert buffer.buffer[0] == 5;\n\n    // But the public API hides this from clients (and the private fields\n    // can only be used within this module).\n    assert buffer[0] == 2;\n    assert buffer[1] == 3;\n    assert buffer[2] == 4;\n    assert buffer[3] == 5;\n    assert buffer.to_str() == ~\"[2, 3, 4, 5]\";\n\n    // clear\n    buffer.clear();\n    assert buffer.len() == 0;\n\n    buffer.push(2);\n    assert buffer.len() == 1;\n    assert buffer[0] == 2;\n\n    buffer.push(3);\n    assert buffer.len() == 2;\n    assert buffer[0] == 2;\n    assert buffer[1] == 3;\n}\n\n// Rust uses a lot of functional programming idioms. One that takes some getting\n// used to for imperative programmers is an avoidance of loops (loops rely on\n// mutation of a loop variable which is not functional style). Instead looping is\n// typically done with functions taking closures, the most common of which are: \n// each, map, filter, and fold.\n#[test]\nfn test_functional()\n{\n    let buffer: RingBuffer<int> = RingBuffer(4);\n    buffer.push(1);\n    buffer.push(3);\n    buffer.push(5);\n    buffer.push(2);\n\n    // each calls a closure with each element\n    // it is more functional than an explicit loop, but requires side effects in order to\n    // do anything useful (because the closures user's give to each don't return values)\n    let mut max = 0;\n    for buffer.each |element|\n    {\n        if *element > max {max = *element}    // dereference because each returns elements by reference\n    }\n    assert max == 5;\n\n    // map uses a closure to convert elements (possibly to different types)\n    let odd = do iter::map_to_vec(buffer) |element| {element & 1 == 1};\n    assert odd == ~[true, true, true, false];\n\n    // filter returns elements for which the closure returns true\n    let odd = do iter::filter_to_vec(buffer) |element| {element & 1 == 1};\n    assert odd == ~[1, 3, 5];\n\n    // fold uses the closure to combine elements together (possibly into a different type)\n    // either forwards (foldl) or in reverse (foldr)\n    let sum = do iter::foldl(buffer, 0) |current, element| {current + element};\n    assert sum == 1 + 3 + 5 + 2;\n}\n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/9210203/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/9892323",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-9892323",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 9892323,
    "node_id": "MDEyOklzc3VlQ29tbWVudDk4OTIzMjM=",
    "user": {
      "login": "jesse99",
      "id": 425055,
      "node_id": "MDQ6VXNlcjQyNTA1NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/425055?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jesse99",
      "html_url": "https://github.com/jesse99",
      "followers_url": "https://api.github.com/users/jesse99/followers",
      "following_url": "https://api.github.com/users/jesse99/following{/other_user}",
      "gists_url": "https://api.github.com/users/jesse99/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jesse99/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jesse99/subscriptions",
      "organizations_url": "https://api.github.com/users/jesse99/orgs",
      "repos_url": "https://api.github.com/users/jesse99/repos",
      "events_url": "https://api.github.com/users/jesse99/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jesse99/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-10-30T01:34:22Z",
    "updated_at": "2012-10-30T01:34:22Z",
    "body": "Forgot to add this one. It's an example of how to create and use a multi-file rust library.\n\nFirst the library.\n\nsxml.rc\n\n```\n// Multi file crates use an rc file to tell the compiler about various pieces of\n// metadata and about which modules are part of the crate.\n\n// This is the required bit of meta-data for a crate.\n// The uuid should be generated using uuidgen (or the equivalent).\n#[link(name = \"sxml\", vers = \"1.0\", uuid = \"333BE970-5A76-40CD-A101-3DD27CB469E5\")];\n#[crate_type = \"lib\"];\n\n// These attributes are used by rustdoc and rustc --ls.\n#[author = \"Jesse Jones\"];\n#[license = \"MIT\"];\n#[doc = \"Multi-file crate library example\"];\n\n// These control various compiler lint passes. You can see them all by doing\n// `rustc -W help`.\n#[warn(unused_imports)];\n#[warn(deprecated_pattern)];\n\n// Link in the rust std library.\nextern mod std;\n\n// List our modules. When this crate is compiled the files with the same names\n// will be automatically compiled into the crate.\npub mod parsing;\npub mod validation;\n```\n\nxsml.rs\n\n```\n//! Parser for (an empty) subset of the XML specification.\n//! Demonstrates a multi-file library and doc comments\n//! To build the library: cd sxml && rustc sxml.rc\n\n// Modules named the same as the rc file are special in at least the following ways:\n// 1) Items listed here are automatically used by other modules in the crate (e.g. Xml in this case).\n// 2) This module does not need to be listed in the rc file.\n// 3) Public items go into the library module, not a module nested inside the library.\n\nuse result::{Err, Ok, Result};\nuse std::map::{HashMap};\n\n// We do this to export our public API to clients of our library. This allows\n// clients to use our library without worrying about the details of how it\n// organizes sub-modules.\npub use parsing::*;\npub use validation::*;\n\npub type Attributes = HashMap<@~str, @~str>;\n\n/// Recursive enum which vaguely resembles XML.\npub enum Xml\n{\n    /// Text content\n    Content(@~str),\n\n    /// Element only content: element name, attributes, and child elements\n    Element(@~str, Attributes, @[@Xml]),\n}\n\n// The /// doc comment applies to the next item.\n// The //! doc comment applies to the thing the comment is within (e.g. a module or a function).\n// Doc comments use markdown syntax, see http://daringfireball.net/projects/markdown/syntax\n\n/// Parses and validates XML.\n/// # Usage\n///     match sxml::from_str(content)\n///     {\n///         Ok(xml) => process(xml),\n///         Err(mesg) => fail mesg,\n///     }\npub fn from_str(text: &str) -> Result<Xml, @~str>\n{\n    do parse_str(text).chain\n    |xml|\n    {\n        match validate_xml(&xml)\n        {\n            @~\"\"   => Ok(xml),\n            errors => Err(errors),\n        }\n    }\n}\n\n```\n\nparsing.rs\n\n```\n//! The code that handles parsing of XML strings.\n\n/// If the text is syntactically correct then an Xml enum is returned.\n/// Otherwise an error message is returned.\npub fn parse_str(_text: &str) -> Result<Xml, @~str>  // _foo suppresses the unused variable warning\n{\n    Err(@~\"not implemented\")\n}\n\n// Lots of private items would go here.\n```\n\nvalidation.rs\n\n```\n//! The code that checks to see if XML is valid.\n\n/// If the XML satisifies the DTD or schema an empty string is returned.\n/// Otherwise a non-empty error message is returned.\npub fn validate_xml(_xml: &Xml) -> @~str\n{\n    @~\"\"\n}\n\n// Lots of private items would go here.\n```\n\nThen an exe that pulls in the library.\n\nclient.rc\n\n```\n// Exe which uses the sxml library.\n// Demonstrates linking against and using a custom rust library.\n// To run the executable: cd xml-client && rustc -L ../sxml --test client.rc && ./client\n#[link(name = \"client\", vers = \"0.2\", uuid = \"D71AEFEB-650C-46E5-91C3-36E9406AEE8E\")];\n\n#[author = \"Jesse Jones\"];\n#[license = \"MIT\"];\n\n#[forbid(unused_imports)];\n#[forbid(implicit_copies)];\n#[forbid(deprecated_pattern)];\n#[allow(structural_records)];   // TODO: enable some of these\n#[allow(deprecated_mode)];\n#[allow(non_implicitly_copyable_typarams)];\n\n// Tell rustc which libraries to link in.\nextern mod std;\nextern mod sxml (name = \"sxml\", vers = \"1.0\");\n\nmod client;\n\n```\n\nclient.rs\n\n```\nuse sxml::*;\n\n#[test]\nfn test_high_level_api()\n{\n    // sxml returns \"not implemented\" for everything...\n    match sxml::from_str(\"<hmm/>\")\n    {\n        Ok(*) => assert false,\n        Err(mesg) => assert *mesg == ~\"not implemented\",\n    }\n}\n\n// https://github.com/mozilla/rust/issues/3505\n#[test]\nfn test_low_level_api()\n{\n    match sxml::parse_str(\"<hmm/>\")\n    {\n        Ok(*) => assert false,\n        Err(mesg) => assert *mesg == ~\"not implemented\",\n    }\n}\n\n#[test]\nfn test_inner_modules()\n{\n    info!(\"hmm\");\n    match sxml::parsing::parse_str(\"<hmm/>\")\n    {\n        Ok(*) => assert false,\n        Err(mesg) => assert *mesg == ~\"not implemented\",\n    }\n}\n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/9892323/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/10733648",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-10733648",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 10733648,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNzMzNjQ4",
    "user": {
      "login": "secunit64",
      "id": 849211,
      "node_id": "MDQ6VXNlcjg0OTIxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/849211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/secunit64",
      "html_url": "https://github.com/secunit64",
      "followers_url": "https://api.github.com/users/secunit64/followers",
      "following_url": "https://api.github.com/users/secunit64/following{/other_user}",
      "gists_url": "https://api.github.com/users/secunit64/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/secunit64/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/secunit64/subscriptions",
      "organizations_url": "https://api.github.com/users/secunit64/orgs",
      "repos_url": "https://api.github.com/users/secunit64/repos",
      "events_url": "https://api.github.com/users/secunit64/events{/privacy}",
      "received_events_url": "https://api.github.com/users/secunit64/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-11-26T21:01:18Z",
    "updated_at": "2012-11-26T21:01:18Z",
    "body": "FWIW, I am building a set of examples starting from simple ones & evolving them into more complex examples. You can find them here: https://github.com/smadhueagle/rustlings. I am also creating a utils module of various helper functions here: https://github.com/smadhueagle/rustils.\n\nVery early stages, but I am picking up the language real fast, so expect more to come. All are based on rust-v0.4\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/10733648/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/18315850",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-18315850",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 18315850,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE4MzE1ODUw",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-05-22T23:59:15Z",
    "updated_at": "2013-05-22T23:59:15Z",
    "body": "Nominating for milestone 4, well-covered\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/18315850/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19370204",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-19370204",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 19370204,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE5MzcwMjA0",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-06-13T03:30:21Z",
    "updated_at": "2013-06-13T03:30:21Z",
    "body": "I guess I concur, though I think this bug might be too vague to know when to close.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19370204/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19770888",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-19770888",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 19770888,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE5NzcwODg4",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-06-20T17:57:59Z",
    "updated_at": "2013-06-20T17:57:59Z",
    "body": "just a bug, removing milestone/nomination.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19770888/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22112137",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-22112137",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 22112137,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMTEyMTM3",
    "user": {
      "login": "emberian",
      "id": 704250,
      "node_id": "MDQ6VXNlcjcwNDI1MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emberian",
      "html_url": "https://github.com/emberian",
      "followers_url": "https://api.github.com/users/emberian/followers",
      "following_url": "https://api.github.com/users/emberian/following{/other_user}",
      "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emberian/subscriptions",
      "organizations_url": "https://api.github.com/users/emberian/orgs",
      "repos_url": "https://api.github.com/users/emberian/repos",
      "events_url": "https://api.github.com/users/emberian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emberian/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-05T15:04:41Z",
    "updated_at": "2013-08-05T15:04:41Z",
    "body": "Visiting for triage, nothing to add.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22112137/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31124463",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-31124463",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 31124463,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMTI0NDYz",
    "user": {
      "login": "emberian",
      "id": 704250,
      "node_id": "MDQ6VXNlcjcwNDI1MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emberian",
      "html_url": "https://github.com/emberian",
      "followers_url": "https://api.github.com/users/emberian/followers",
      "following_url": "https://api.github.com/users/emberian/following{/other_user}",
      "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emberian/subscriptions",
      "organizations_url": "https://api.github.com/users/emberian/orgs",
      "repos_url": "https://api.github.com/users/emberian/repos",
      "events_url": "https://api.github.com/users/emberian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emberian/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-23T15:25:26Z",
    "updated_at": "2013-12-23T15:25:26Z",
    "body": "Nothing to add, although https://github.com/Hoverbear/rust-rosetta is starting to pick up some examples.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31124463/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34134517",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-34134517",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 34134517,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MTM0NTE3",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-05T03:26:42Z",
    "updated_at": "2014-02-05T03:26:42Z",
    "body": "I'm collecting external example sites https://github.com/mozilla/rust/wiki/Doc-examples\n\nWould love for somebody to consolidate this stuff, put it in the official repo for maintenance.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34134517/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/42146372",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-42146372",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 42146372,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMTQ2Mzcy",
    "user": {
      "login": "gsingh93",
      "id": 1012677,
      "node_id": "MDQ6VXNlcjEwMTI2Nzc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1012677?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gsingh93",
      "html_url": "https://github.com/gsingh93",
      "followers_url": "https://api.github.com/users/gsingh93/followers",
      "following_url": "https://api.github.com/users/gsingh93/following{/other_user}",
      "gists_url": "https://api.github.com/users/gsingh93/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gsingh93/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gsingh93/subscriptions",
      "organizations_url": "https://api.github.com/users/gsingh93/orgs",
      "repos_url": "https://api.github.com/users/gsingh93/repos",
      "events_url": "https://api.github.com/users/gsingh93/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gsingh93/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-05-04T21:49:57Z",
    "updated_at": "2014-05-04T21:49:57Z",
    "body": "I'm working on writing some programs from coreutils here: https://github.com/gsingh93/rust-coreutils\n\nI'm still pretty new to rust and I'm writing these just for practice, but at some point there might be some good examples in there.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/42146372/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/42802542",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-42802542",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 42802542,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyODAyNTQy",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-05-12T07:23:17Z",
    "updated_at": "2014-05-12T07:23:17Z",
    "body": "http://rustbyexample.com/\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/42802542/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/46865169",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-46865169",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 46865169,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODY1MTY5",
    "user": {
      "login": "steveklabnik",
      "id": 27786,
      "node_id": "MDQ6VXNlcjI3Nzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/steveklabnik",
      "html_url": "https://github.com/steveklabnik",
      "followers_url": "https://api.github.com/users/steveklabnik/followers",
      "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}",
      "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions",
      "organizations_url": "https://api.github.com/users/steveklabnik/orgs",
      "repos_url": "https://api.github.com/users/steveklabnik/repos",
      "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/steveklabnik/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-06-23T16:04:18Z",
    "updated_at": "2014-06-23T16:04:18Z",
    "body": "I am not sure this is exactly relevant anymore. I think it should be closed.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/46865169/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/46865470",
    "html_url": "https://github.com/rust-lang/rust/issues/3562#issuecomment-46865470",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3562",
    "id": 46865470,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODY1NDcw",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-06-23T16:06:31Z",
    "updated_at": "2014-06-23T16:06:31Z",
    "body": "I agree. We have made a lot of progress since this was opened, and I think that more specific issues should be opened if there are any lingering points to address.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/46865470/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
