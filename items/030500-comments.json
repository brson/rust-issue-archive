[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166134499",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166134499",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166134499,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjEzNDQ5OQ==",
    "user": {
      "login": "steveklabnik",
      "id": 27786,
      "node_id": "MDQ6VXNlcjI3Nzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/steveklabnik",
      "html_url": "https://github.com/steveklabnik",
      "followers_url": "https://api.github.com/users/steveklabnik/followers",
      "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}",
      "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions",
      "organizations_url": "https://api.github.com/users/steveklabnik/orgs",
      "repos_url": "https://api.github.com/users/steveklabnik/repos",
      "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/steveklabnik/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-20T16:45:16Z",
    "updated_at": "2015-12-20T16:45:16Z",
    "body": "/cc @rust-lang/lang \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166134499/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166156547",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166156547",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166156547,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjE1NjU0Nw==",
    "user": {
      "login": "eefriedman",
      "id": 12769964,
      "node_id": "MDQ6VXNlcjEyNzY5OTY0",
      "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eefriedman",
      "html_url": "https://github.com/eefriedman",
      "followers_url": "https://api.github.com/users/eefriedman/followers",
      "following_url": "https://api.github.com/users/eefriedman/following{/other_user}",
      "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions",
      "organizations_url": "https://api.github.com/users/eefriedman/orgs",
      "repos_url": "https://api.github.com/users/eefriedman/repos",
      "events_url": "https://api.github.com/users/eefriedman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eefriedman/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-20T21:37:45Z",
    "updated_at": "2015-12-20T21:37:45Z",
    "body": "> This cannot be because memcpy will read padding bytes which are undef.\n\nI'm not sure what you mean here; the fact that rustc sometimes generates a call to memcpy is mostly irrelevant to the semantics of Rust code.\n\n> z will be 0xab00 and not undef.\n\nThe LLVM `add` instruction behaves this way, but the rustc \"+\" operator isn't guaranteed to translate directly to the LLVM add instruction.  In fact, it doesn't in overflow checking mode.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166156547/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166156665",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166156665",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166156665,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjE1NjY2NQ==",
    "user": {
      "login": "mahkoh",
      "id": 1882250,
      "node_id": "MDQ6VXNlcjE4ODIyNTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1882250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mahkoh",
      "html_url": "https://github.com/mahkoh",
      "followers_url": "https://api.github.com/users/mahkoh/followers",
      "following_url": "https://api.github.com/users/mahkoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/mahkoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mahkoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mahkoh/subscriptions",
      "organizations_url": "https://api.github.com/users/mahkoh/orgs",
      "repos_url": "https://api.github.com/users/mahkoh/repos",
      "events_url": "https://api.github.com/users/mahkoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mahkoh/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-20T21:40:44Z",
    "updated_at": "2015-12-20T21:40:44Z",
    "body": "@eefriedman \n1. Not if memcpy is itself written in rust code.\n2. It doesn't make a difference. `x as u16` will have the upper byte zeroed.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166156665/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166157296",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166157296",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166157296,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjE1NzI5Ng==",
    "user": {
      "login": "mahkoh",
      "id": 1882250,
      "node_id": "MDQ6VXNlcjE4ODIyNTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1882250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mahkoh",
      "html_url": "https://github.com/mahkoh",
      "followers_url": "https://api.github.com/users/mahkoh/followers",
      "following_url": "https://api.github.com/users/mahkoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/mahkoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mahkoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mahkoh/subscriptions",
      "organizations_url": "https://api.github.com/users/mahkoh/orgs",
      "repos_url": "https://api.github.com/users/mahkoh/repos",
      "events_url": "https://api.github.com/users/mahkoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mahkoh/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-20T21:51:07Z",
    "updated_at": "2015-12-20T21:51:07Z",
    "body": "The reason for the current rule seems to be: \"I don't know how to formulate the real rules so I'll simply disallow it completely.\"\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166157296/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166158074",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166158074",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166158074,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjE1ODA3NA==",
    "user": {
      "login": "eefriedman",
      "id": 12769964,
      "node_id": "MDQ6VXNlcjEyNzY5OTY0",
      "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eefriedman",
      "html_url": "https://github.com/eefriedman",
      "followers_url": "https://api.github.com/users/eefriedman/followers",
      "following_url": "https://api.github.com/users/eefriedman/following{/other_user}",
      "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions",
      "organizations_url": "https://api.github.com/users/eefriedman/orgs",
      "repos_url": "https://api.github.com/users/eefriedman/repos",
      "events_url": "https://api.github.com/users/eefriedman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eefriedman/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-20T22:04:40Z",
    "updated_at": "2015-12-20T22:04:40Z",
    "body": "> Not if memcpy is itself written in rust code.\n\nThere isn't any fundamental need for it to be legal to write memcpy in Rust... it's part of the runtime.  Granted, it would be convenient in some cases.  Maybe we can add a special-case for \"copying\" an undef `Copy` value .\n\n> It doesn't make a difference. x as u16 will have the upper byte zeroed.\n\nYou're not looking at this at the right level.  \"add\" is opaque; in theory, it could involve indexing into an array using the values of the operands, which could crash the program if `undef` is involved.\n\nAnyway, trying to make promises about how exactly arithmetic is implemented leads down a path which isn't really productive.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166158074/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166158541",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166158541",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166158541,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjE1ODU0MQ==",
    "user": {
      "login": "mahkoh",
      "id": 1882250,
      "node_id": "MDQ6VXNlcjE4ODIyNTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1882250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mahkoh",
      "html_url": "https://github.com/mahkoh",
      "followers_url": "https://api.github.com/users/mahkoh/followers",
      "following_url": "https://api.github.com/users/mahkoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/mahkoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mahkoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mahkoh/subscriptions",
      "organizations_url": "https://api.github.com/users/mahkoh/orgs",
      "repos_url": "https://api.github.com/users/mahkoh/repos",
      "events_url": "https://api.github.com/users/mahkoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mahkoh/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-20T22:12:30Z",
    "updated_at": "2015-12-20T22:12:49Z",
    "body": "> There isn't any fundamental need for it to be legal to write memcpy in Rust\n\nWhew\n\n> Maybe we can add a special-case for \"copying\" an undef Copy value .\n\nThat's the opposite of what should be done. The formulation must be more abstract so that everything legal can be done with undef while still disallowing all that that causes the behavior to be undefined. Maybe one even has to go so far as to add a primitive size one type that cannot be interpreted as any other type (without transmute) and has exactly one value that spans all u8 values. One might interpret it as a one byte type with one byte padding but it's not really padding.\n\n> You're not looking at this at the right level.\n\nI see that adding an example did more harm than good.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166158541/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166162157",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166162157",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166162157,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjE2MjE1Nw==",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-20T23:06:43Z",
    "updated_at": "2015-12-20T23:11:28Z",
    "body": "It seems like spec'ing the example of addition/bitmasks would also require expanding the notion of \"undefined value\" to be at the bit level, and for the language to have some idea about results of (special cases of) operators. The latter seems like a rather open ended space, with very complicated properties encodable. This isn't a blocker, but it does mean touching this requires some care.  (Byte-level undef would work for that specific example, but it seems restrictive---what if `u8` was `bool` and `0xFF00` was `0xFFFE`---and even then, operators still need to be understood at the byte level.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166162157/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166162527",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166162527",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166162527,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjE2MjUyNw==",
    "user": {
      "login": "mahkoh",
      "id": 1882250,
      "node_id": "MDQ6VXNlcjE4ODIyNTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1882250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mahkoh",
      "html_url": "https://github.com/mahkoh",
      "followers_url": "https://api.github.com/users/mahkoh/followers",
      "following_url": "https://api.github.com/users/mahkoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/mahkoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mahkoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mahkoh/subscriptions",
      "organizations_url": "https://api.github.com/users/mahkoh/orgs",
      "repos_url": "https://api.github.com/users/mahkoh/repos",
      "events_url": "https://api.github.com/users/mahkoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mahkoh/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-20T23:13:51Z",
    "updated_at": "2015-12-20T23:13:51Z",
    "body": "> require expanding the notion of \"undefined value\" to be at the bit level\n\nDoes the rust manual define undef at all? IIRC it only links to the llvm manual which already talks about undef at the bit level.\n\n> It seems like spec'ing the example of addition/bitmasks would also \n\nThe example is not important. It's just supposed to show that, at the llvm level, working with undef can lead to definite results and doesn't necessarily lead to undef propagation. Actually using undef values in rust code for anything remotely complicated can easily lead to UB because of undef propagation. However, there is no reason for the manual to claim that reading undef always leads to UB which is much stricter than what llvm requires.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166162527/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166165365",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166165365",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166165365,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjE2NTM2NQ==",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-20T23:41:05Z",
    "updated_at": "2015-12-20T23:41:05Z",
    "body": "Rust isn't LLVM, and we don't necessarily want to make every guarantee that it does. I'm personally not that happy that we defer to LLVM for many definitions for convenience, and I expect this to not be the case in the future e.g. if an actual spec is written. (Feel free to read it as if I said \"introducing a more formal Rust undef, which is tracked at the bit level\" in place of \"expanding the notion ... bit level\".)\n\nOn the point of undefined values, you're right that we just link to LLVM's definition of undef, but we do so in the context of reading undef memory, which doesn't say anything about an in-register value as we'd have for arithmetic, so even the most pedantic reading is vague. Also, I don't recall any team discussion featuring undef values where anything other than the whole value was considered undef. Summary: this is under-spec'd and the existing underlying/assumed sense of this area at the Rust level is almost certainly not for individual bits.\n\nOf course, you're also right that using LLVM's undef can lead to definite results even without tracking bits (e.g. `let x = if undef { 0 } else { 0 };` will always give `x == 0`), but see the first sentence.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166165365/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166359478",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166359478",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166359478,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjM1OTQ3OA==",
    "user": {
      "login": "mahkoh",
      "id": 1882250,
      "node_id": "MDQ6VXNlcjE4ODIyNTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1882250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mahkoh",
      "html_url": "https://github.com/mahkoh",
      "followers_url": "https://api.github.com/users/mahkoh/followers",
      "following_url": "https://api.github.com/users/mahkoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/mahkoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mahkoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mahkoh/subscriptions",
      "organizations_url": "https://api.github.com/users/mahkoh/orgs",
      "repos_url": "https://api.github.com/users/mahkoh/repos",
      "events_url": "https://api.github.com/users/mahkoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mahkoh/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-21T17:00:08Z",
    "updated_at": "2015-12-21T17:02:23Z",
    "body": "> I'm personally not that happy that we defer to LLVM for many definitions for convenience, and I expect this to not be the case in the future e.g. if an actual spec is written. \n\nYou're already de facto guaranteeing the current behavior by having it work. Significant changes cannot be made without silently (!) breaking code which is the complete opposite of stability.\n\nEven if you had reliable normative information, undefined operations that have behaved reliably for some time cannot always be made behave differently without causing many problems (e.g. signed integer overflow in C.)\n\nBut there is no reliable normative information and thus people have to rely on what works in the current implementation for just about everything. E.g. the only official information about the behavior of `transmute` that can be found is\n\n> Unsafely transforms a value of one type into a value of another type.\n> \n> Both types must have the same size.\n\nThis doesn't even guarantee that the returned value has anything to do with the input value. Precisely because transmute is completely unspecified, the current implementation must be treated as normative.\n\nThe same applies to `undef`: memcpy works now and it works according to llvm so it has to continue to work.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166359478/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166362485",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166362485",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166362485,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjM2MjQ4NQ==",
    "user": {
      "login": "mahkoh",
      "id": 1882250,
      "node_id": "MDQ6VXNlcjE4ODIyNTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1882250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mahkoh",
      "html_url": "https://github.com/mahkoh",
      "followers_url": "https://api.github.com/users/mahkoh/followers",
      "following_url": "https://api.github.com/users/mahkoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/mahkoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mahkoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mahkoh/subscriptions",
      "organizations_url": "https://api.github.com/users/mahkoh/orgs",
      "repos_url": "https://api.github.com/users/mahkoh/repos",
      "events_url": "https://api.github.com/users/mahkoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mahkoh/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-21T17:11:47Z",
    "updated_at": "2015-12-21T17:11:47Z",
    "body": "For example, the following is discouraged by a lint but does not cause any problems:\n\n``` rust\nfn f(&self) -> &Self;\n\nfn f_mut(&mut self) -> &mut Self {\n    unsafe { transmute(self.f()) }\n}\n```\n\nAt the same time there is other, unreliable information flying around that says that transmuting `&` to `&mut` is always undefined. Strictly speaking this is correct because `transmute` is mostly undefined, but if that's the argument then transmuting `&mut` to `&` is equally undefined.\n\nThe lack of any kind of information regarding `transmute` means that you have no way to distinguish between safe, dangerous, and forbidden operations. All of them are equally undefined.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166362485/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166369633",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166369633",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166369633,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjM2OTYzMw==",
    "user": {
      "login": "steveklabnik",
      "id": 27786,
      "node_id": "MDQ6VXNlcjI3Nzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/steveklabnik",
      "html_url": "https://github.com/steveklabnik",
      "followers_url": "https://api.github.com/users/steveklabnik/followers",
      "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}",
      "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions",
      "organizations_url": "https://api.github.com/users/steveklabnik/orgs",
      "repos_url": "https://api.github.com/users/steveklabnik/repos",
      "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/steveklabnik/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-21T17:39:51Z",
    "updated_at": "2015-12-21T17:39:51Z",
    "body": "> Precisely because transmute is completely unspecified, the current implementation must be treated as normative.\n\nI strongly disagree with this. We should be seeking to specify such things, not just accepting whatever random behavior happens to work in these corners.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166369633/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166411367",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166411367",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166411367,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjQxMTM2Nw==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-21T20:40:42Z",
    "updated_at": "2015-12-21T20:40:42Z",
    "body": "@mahkoh \n\nThere's a difference between what we _specify_ and what we allow LLVM to _assume_. \n\nThe reason there is a lint about transmuting `&` to `&mut` is because that causes instant death by aliasing rule violations - we basically allow ourselves to add MIR optimizations that will destroy your code in that case.\n\nWe still have not really decided how much \"instant aliasing death\" is a thing - @thestinger preferred to have access-based aliasing rules and I think he's got a point - but we didn't specify that it was _not_ a thing.\n\nOn the `memcpy` issue: the part of C's semantics that allows `memcpy` to be implemented in C code is quite ugly. I would prefer not to specify anything like that.\nsne point that I would like to make clear is the difference between _well-defined_, _unspecified_ and _undefined_ behaviour:\n- _well-defined_ behaviour refers to things that _ordinary programs_ are allowed to assume. The compiler must not break it.\n- _undefined_ behaviour refers to things that _the compiler_ is allowed to assume (to not happen). All programs must not try to provoke it.\n- _unspecified_ behaviour refers to things that are not a part of the specification. The compiler is not granted a carte blanche to abuse them, but neither do applications.\n\nThere might very well be some other specification that defines some unspecified behaviour (either to something well-defined or undefined). For example, system calls are specified by your favourite OS's documentation.\n\nAt this moment, we have no plans to publicly specify everything that is needed by a stable `libcore`. This means that anyone who wants to implement one (currently that's either us or you) must look at the compiler source for a specification and coordinate with us to avoid breakage. This of course does not mean that undefined behaviour is triggered - that would give the compiler a license to destroy all Rust code. There are boundaries, they are just somewhat unclear. I am sorry that this interferes with your project.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166411367/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166413405",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166413405",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166413405,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjQxMzQwNQ==",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-21T20:46:07Z",
    "updated_at": "2015-12-21T20:46:07Z",
    "body": "@mahkoh \n\n> You're already de facto guaranteeing the current behavior by having it work. Significant changes cannot be made without silently (!) breaking code which is the complete opposite of stability.\n\nThis same reasoning can be used to argue that, e.g., we should never change our sorting algorithm, because it may invoke the comparator in a different order, and so forth. We've also made it clear that various low-level details are expected to change, and that authors of unsafe code (in particular) will need to track the language as it evolves.\n\n_That said,_ we should definitely consider \"common practice\" when deciding what kinds of things are undefined behavior. This is only partially because of existing code -- what I am most concerned about is just that if the rules are too complex and abstract (that is, too divorced from some abstract model of how the machine operators), people won't be able to keep them in their head, and so they will write noncomformant code that does surprising things when optimized.\n\nFrom what I can see, C has this problem in spades. Infinite loops, TBAA, etc all lead to making it actually surprisingly hard to write \"correct\" C code that does anything clever. But of course people write all kinds of clever things in C, many of which are compiler issues waiting to happen.\n\nI think @mahkoh has a point that it would be nice to affirm that particular idioms (e.g., a naively written memcpy that \"seems right\") will work without leading to undefined behavior. I'm just not sure if that's an urgent priority: it's a rather complex equation, since we must also consider what LLVM will do (and to what extent we can control that), and so forth, and we don't want to wind up guaranteeing too much. Put another way, I am sympathetic with the aims of this RFC, but I also wonder if it would be better to try to tackle the problem of \"stabilizing\" unsafe code patterns in a more wholesale fashion, rather than going at it piecemeal.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166413405/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166432845",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166432845",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166432845,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjQzMjg0NQ==",
    "user": {
      "login": "mahkoh",
      "id": 1882250,
      "node_id": "MDQ6VXNlcjE4ODIyNTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1882250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mahkoh",
      "html_url": "https://github.com/mahkoh",
      "followers_url": "https://api.github.com/users/mahkoh/followers",
      "following_url": "https://api.github.com/users/mahkoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/mahkoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mahkoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mahkoh/subscriptions",
      "organizations_url": "https://api.github.com/users/mahkoh/orgs",
      "repos_url": "https://api.github.com/users/mahkoh/repos",
      "events_url": "https://api.github.com/users/mahkoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mahkoh/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-21T21:45:24Z",
    "updated_at": "2015-12-21T21:48:28Z",
    "body": "@arielb1\n\n> The reason there is a lint about transmuting & to &mut is because that causes instant death by aliasing rule violations - we basically allow ourselves to add MIR optimizations that will destroy your code in that case.\n\nThere is no lint against transmuting `(&, &)` to `(&mut, &mut)` and the manual only talks about llvm's aliasing rules that must not be violated. If you're saying that you might break such things freely in the future, then this certainly doesn't just affect \"my project\".\n\n> On the memcpy issue: the part of C's semantics that allows memcpy to be implemented in C code is quite ugly.\n\nThere are many special cases for char but apart from that I don't recall anything particularly ugly. It would certainly be better if memcpy did not have to be written with u8's and then rely on LLVM to optimize it.\n\n> The point that I would like to make clear is the difference between well-defined, unspecified and undefined behaviour:\n\nI disagree with your definitions. Here are mine:\n- _undefined behavior_ is behavior upon an operation that has not been explicitly defined by the specification\n- _unspecified behavior_ is behavior that depends on the implementation and that the implementation need not specify\n- _implementation defined behavior_ is behavior that is defined by each implementation\n\nWith these definitions, undefined behavior is what you called unspecified behavior. I think the C++11 standard agrees with my definition:\n\n> **undefined behavior**\n> behavior for which this International Standard imposes no requirements\n> [ Note: Undefined behavior may be expected when this International Standard omits any explicit definition of behavior ...\n\nThere is a significant difference between undefined behavior and unspecified behavior so we have to agree on what we're talking about.\n\n> At this moment, we have no plans to publicly specify everything that is needed by a stable libcore\n\nI don't think anything in this issue is restricted to code in a libcore. In fact, libcore doesn't contain a memcpy so I'm not sure how libcore is related to this issue. A memcpy might be written in many situations: when you write a kernel; when you need a particularly optimized memcpy; when you need a memcpy that can be inlined; etc. And transmutes are certainly used in lots of code.\n\n@nikomatsakis \n\n> We've also made it clear that various low-level details are expected to change, and that authors of unsafe code (in particular) will need to track the language as it evolves.\n\nI don't recall this and breaking random unsafe code seems to go completely against the rest of your stability guarantees. Please link to the text where you said this.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166432845/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166434775",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166434775",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166434775,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjQzNDc3NQ==",
    "user": {
      "login": "mahkoh",
      "id": 1882250,
      "node_id": "MDQ6VXNlcjE4ODIyNTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1882250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mahkoh",
      "html_url": "https://github.com/mahkoh",
      "followers_url": "https://api.github.com/users/mahkoh/followers",
      "following_url": "https://api.github.com/users/mahkoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/mahkoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mahkoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mahkoh/subscriptions",
      "organizations_url": "https://api.github.com/users/mahkoh/orgs",
      "repos_url": "https://api.github.com/users/mahkoh/repos",
      "events_url": "https://api.github.com/users/mahkoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mahkoh/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-21T21:55:43Z",
    "updated_at": "2015-12-21T21:59:40Z",
    "body": "@nikomatsakis \n\nMore specifically: I'll be greatly surprised if you've actually said that authors of unsafe must track the language or else their working code might break without a compiler warning or error, which is what this issue is about.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166434775/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166436482",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166436482",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166436482,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjQzNjQ4Mg==",
    "user": {
      "login": "aturon",
      "id": 709807,
      "node_id": "MDQ6VXNlcjcwOTgwNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aturon",
      "html_url": "https://github.com/aturon",
      "followers_url": "https://api.github.com/users/aturon/followers",
      "following_url": "https://api.github.com/users/aturon/following{/other_user}",
      "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aturon/subscriptions",
      "organizations_url": "https://api.github.com/users/aturon/orgs",
      "repos_url": "https://api.github.com/users/aturon/repos",
      "events_url": "https://api.github.com/users/aturon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aturon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-21T22:04:11Z",
    "updated_at": "2015-12-21T22:08:21Z",
    "body": "@mahkoh I believe https://github.com/rust-lang/rfcs/blob/master/text/1122-language-semver.md#underspecified-language-semantics is the relevant bit.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166436482/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166436678",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166436678",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166436678,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjQzNjY3OA==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-21T22:05:09Z",
    "updated_at": "2015-12-21T22:05:09Z",
    "body": "@mahkoh \n\nThat there is no lint against something only means that there is no lint against it, but we may be forced to grandfather some way for `(&,&) -> (&mut,&mut)` to work (the optimizations we want to do here is that if rustc gets to inline both `f` and `f_mut` then it may move some reads in `f` to ahead of the return). IIRC C got its `memcpy` rules in basically this way.\n\nThe \"memcpy hack\" is basically that the representation of types is somehow both undefined and well-defined at the same moment. I don't really want to have that hack in Rust.\n\n> With these definitions, undefined behavior is what you called unspecified behavior.\n\nCompiler writers have traditionally taken \"imposes no requirements\" to mean that they are allowed to make the program do whatever they want in that case, which is basically equivalent to being allowed to assume that it does not happen (because if they assume wrong, _something_ happens, which satisfies the empty set of requirements imposed).\n\n> A memcpy might be written in many situations: when you write a kernel; when you need a particularly optimized memcpy; when you need a memcpy that can be inlined; etc. \n\nIn that case you would want to write your `memcpy` in assembly or LLVM IR and use the ABI specification to communicate.\n\n> And transmutes are certainly used in lots of code.\n\nThat is certainly a very big problem. C's strict aliasing rules are a pretty similar rat's nest, but we need to do something to get out of it.\n\n> I don't recall this and breaking random unsafe code seems to go completely against the rest of your stability guarantees. Please link to the text where you said this.\n\nLLVM can already randomly break unsafe code by becoming smarter about exploiting some UB. We only reserve the right to do similar things on our side.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166436678/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166680341",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166680341",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166680341,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NjY4MDM0MQ==",
    "user": {
      "login": "mahkoh",
      "id": 1882250,
      "node_id": "MDQ6VXNlcjE4ODIyNTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1882250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mahkoh",
      "html_url": "https://github.com/mahkoh",
      "followers_url": "https://api.github.com/users/mahkoh/followers",
      "following_url": "https://api.github.com/users/mahkoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/mahkoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mahkoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mahkoh/subscriptions",
      "organizations_url": "https://api.github.com/users/mahkoh/orgs",
      "repos_url": "https://api.github.com/users/mahkoh/repos",
      "events_url": "https://api.github.com/users/mahkoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mahkoh/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-22T17:28:15Z",
    "updated_at": "2015-12-22T17:29:30Z",
    "body": "> but we may be forced to grandfather some way for `(&,&) -> (&mut,&mut)` to work\n\nWhy are you forced to keep this working but are free to break `& -> &mut`? Don't tell me it's because of some random lint that can be easily circumvented by going `(&,) -> (&mut,)`.\n\n> The \"memcpy hack\" is basically that the representation of types is somehow both undefined and well-defined at the same moment. \n\nI'm not sure what you're going on about some hack. There is no hack except for what I already mentioned regarding chars.\n\n> Compiler writers have traditionally taken \"imposes no requirements\" to mean that they are allowed to make the program do whatever they want in that case, which is basically equivalent to being allowed to assume that it does not happen\n\nI've not said anything contradicting this. The point was that that what you categorize under \"unspecified behavior\" is already \"undefined behavior\" and that for something to be unspecified it has to be explicitly mentioned in the spec. I realize that this might be confusing so let me refer you again to the definitions of those terms in the C++11 standard.\n\n> In that case you would want to write your memcpy in assembly or LLVM IR and use the ABI specification to communicate.\n\nAt the same time you're telling people that matching on an empty enum is the _official_ way to get an llvm unreachable instruction. Who made it official? Can you point me to the official documentation containing this? If anything, this is even less valid than writing your favorite memcpy in rust code.\n\n> [transmutes are] certainly a very big problem.\n\nMaybe people should just write them in assembly or LLVM IR.\n\n> C's strict aliasing rules are a pretty similar rat's nest, but we need to do something to get out of it.\n\nNeither LLVM nor Rust use TBAA which is the main source of UB related to C's aliasing rules. How is this in any way related to the current discussion?\n\n> LLVM can already randomly break unsafe code by becoming smarter about exploiting some UB. We only reserve the right to do similar things on our side.\n\nSo you only reserve the right to break just about everything because just about everything is UB in rust (see above). LLVM can do this because they actually have a decent amount of documentation allowing people to write code without having to rely on UB.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166680341/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166761422",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166761422",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166761422,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2Njc2MTQyMg==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-22T23:26:27Z",
    "updated_at": "2015-12-22T23:26:27Z",
    "body": "> Why are you forced to keep this working but are free to break & -> &mut? Don't tell me it's because of some random lint that can be easily circumvented by going (&,) -> (&mut,).\n\n\"grandfather\" = be required to figure out some way to not break it because there are already programs using it and we don't want to release Rust 2.0. Maybe we will be forced to grandfather `(&,) -> (&mut,)` too, and maybe that will flow out naturally from the previous one, but I strongly prefer to minimize the amount of hacks required to make existing code work.\n\n> I'm not sure what you're going on about some hack. There is no hack except for what I already mentioned regarding chars.\n\nC requires that every data structure have a representation as an array of integers (characters) in a round-trippable way, while making that representation basically \"undefined\" in many ways. That frustrates \"symbolic\" implementations. I would prefer that Rust's specification be implementable symbolically (note that this does not mean that all the code in `libcore` works symbolically - `libcore` is allowed to rely on unspecified behaviour).\n\n> The point was that that what you categorize under \"unspecified behavior\" is already \"undefined behavior\" and that for something to be unspecified it has to be explicitly mentioned in the spec.\n\nThe C specification tries hard not to have any things that are not defined anywhere. On the other hand, the precise sequence of assembly instructions emitted by a C compiler is not defined in any place, but saying that it is something the compiler is allowed to assume makes no sense. When we improve our spec, we should try to make sure that all cases of \"in that other case, behaviour is unspecified\" are explicitly stated.\n\n> At the same time you're telling people that matching on an empty enum is the official way to get an llvm unreachable instruction. Who made it official? Can you point me to the official documentation containing this? If anything, this is even less valid than writing your favorite memcpy in rust code.\n\nRust's codegen is quite explicitly unspecified. Even intrinsics are basically \"emit the designated instruction, along with all necessary wrappers\", so specifying that something lowers to exactly an `unreachable` is basically impossible (especially because `unreachable` is UB, so from an operational specification point of view we can emit _everything we like_). The \"official\" part basically meant that this is basically the Rust-Team-sanctioned way of generating an `unreachable`.\n\n> Maybe people should just write them in assembly or LLVM IR.\n\nThe issues caused by `transmute` are mostly the values created that don't actually inhabit their types. Doing the `transmute` itself in assembly would not help. If you can hide your `transmute` behind an API/ABI boundary, then there is no problem with writing that code in Rust.\n\nFor example, you can write `f_mut` safely as\n\n``` Rust\nfn f_mut(&mut self) -> &mut Self {\n    unsafe { &mut *(self.f() as *const Self as *mut Self) }\n}\n```\n\nAt least, that is _supposed_ to be non-UB.\n\n> Neither LLVM nor Rust use TBAA which is the main source of UB related to C's aliasing rules. How is this in any way related to the current discussion?\n\nRust has lifetime-based alias analysis, which has the same \"utter the right incantations to guard against the evil optimizer\" problems as TBAA. \n\n> So you only reserve the right to break just about everything because just about everything is UB in rust (see above). LLVM can do this because they actually have a decent amount of documentation allowing people to write code without having to rely on UB.\n\nRust's specification is in a _very_ sorry state, with many things left unspecified. Incidentally, what is important for future compatibility is not the _specification_ but rather the _stability guarantee_, which explicitly says that underspecified areas are not stable and can change between releases.\n\nThis means that code using these underspecified areas (including type punning) is unfortunately subject to breakage between releases. We try to avoid causing silent breakage, but we prefer that our users will be careful around these areas.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166761422/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166858835",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-166858835",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 166858835,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2Njg1ODgzNQ==",
    "user": {
      "login": "mahkoh",
      "id": 1882250,
      "node_id": "MDQ6VXNlcjE4ODIyNTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1882250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mahkoh",
      "html_url": "https://github.com/mahkoh",
      "followers_url": "https://api.github.com/users/mahkoh/followers",
      "following_url": "https://api.github.com/users/mahkoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/mahkoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mahkoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mahkoh/subscriptions",
      "organizations_url": "https://api.github.com/users/mahkoh/orgs",
      "repos_url": "https://api.github.com/users/mahkoh/repos",
      "events_url": "https://api.github.com/users/mahkoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mahkoh/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-23T10:34:23Z",
    "updated_at": "2015-12-23T10:55:01Z",
    "body": "> we don't want to release Rust 2.0\n\nSeems like a reasonable idea. Write a spec, break all the unspecified things you want (but not more), release 2.0. It's not like an increase of the major has to break lots of things. I'd be fine with it breaking unsafe code as long as I get a real spec in return.\n\n> Maybe we will be forced to grandfather (&,) -> (&mut,) too, and maybe that will flow out naturally from the previous one, but I strongly prefer to minimize the amount of hacks required to make existing code work.\n\nIt seems that if you keep every transmute of `&->&mut` working in tuples and structs, then actually breaking the only one you're \"allowed to\" (which is questionable) is more work than keeping that one working to.\n\n> C requires that every data structure have a representation as an array of integers (characters) in a round-trippable way, while making that representation basically \"undefined\" in many ways. That frustrates \"symbolic\" implementations.\n\nI see what you mean but I don't consider this a hack.\n\n> I would prefer that Rust's specification be implementable symbolically (note that this does not mean that all the code in libcore works symbolically - libcore is allowed to rely on unspecified behaviour).\n\nFeel free to mention your concerns in #30407. While your idea is appealing on a theoretical level, I don't think this is realistic for a systems language, making it harder to write low level code (allocators, kernels, etc.) in rust. Calling stable rust a systems language is already questionable (it fails the simple test that a systems language can, theoretically, compile itself: stable rust requires language items, stable rust will never be able to compile language items; that is, a stable rust compiler cannot even theoretically be a self-hosting compiler), and this idea makes even nightly rust less systems-y.\n\nBut, like I said, I see the value of your idea and I think a theoretical spec could very well keep the representation completely unspecified. But at the same time, the rustc documentation has to extend said spec to specify parts of the representation. Code that relies on such details is then of course not portable between implementations.\n\n> On the other hand, the precise sequence of assembly instructions emitted by a C compiler is not defined in any place, but saying that it is something the compiler is allowed to assume makes no sense. \n\nI'm not sure what you're saying here. Of course the compiler is allowed to assume that the sequence of assembly instructions is not defined. Otherwise it could not perform any optimizations.\n\nThe C standard describes the behavior of the abstract machine. An implementation is allowed to handle the details in any way it wants as long as the observable behavior agrees with the one described in the standard.\n\n> The \"official\" part basically meant that this is basically the Rust-Team-sanctioned way of generating an unreachable.\n\nI think there isn't really a difference between \"official\" and \"sanctioned\". As long as it's not written down somewhere, it's no more than hearsay. If such a thing has actually been discussed and agreed on, then write it down where everyone can look it up so that we can properly language lawyer once you break it.\n\n> For example, you can write f_mut safely as\n\nNow we're getting somewhere! I assume that by \"safely\" you mean that your way is \"sanctioned\"? If so then I'm surprised because one would think that your way is more dangerous than the transmute.\n\n```\nunsafe { &mut *(self.f() as *const Self as *mut Self) }\n                            ^\n```\n\nI'd assume that, at the marked point, the borrow has been \"released\" and that `self` becomes accessible again. So that at the following point\n\n```\nunsafe { &mut *(self.f() as *const Self as *mut Self) }\n         ^\n```\n\nwe've created two live mut pointers to the same address and that the second reference has an unbounded lifetime. The transmute version doesn't seem to have this problem since it goes directly from `&'anon` to `&'anon mut` without releasing the borrow. But if you promise that your version will continue to work then I'll happily replace all transmutes with it.\n\nEdit: See also #30424 which is closely related.\n\n> At least, that is supposed to be non-UB.\n\nThere seem to be lots of things related to the interaction between pointers and references that are completely unspecified. It's one of the things mentioned in @aturon's link.\n\n> which explicitly says that underspecified areas are not stable and can change between releases\n\nThe text linked by @aturon uses lots of qualifiers to restrict this freedom. And references in particular are heavily specified by the following line in the documentation:\n\n> &mut and & follow LLVM\u2019s scoped noalias model\n\nWhich links to LLVM's docs which have lots of text describing noalias.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/166858835/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167010924",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-167010924",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 167010924,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzAxMDkyNA==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-23T23:56:38Z",
    "updated_at": "2015-12-23T23:56:38Z",
    "body": "> It seems that if you keep every transmute of &->&mut working in tuples and structs, then actually breaking the only one you're \"allowed to\" (which is questionable) is more work than keeping that one \n> working to.\n\nWe will find some reasonable semantics. We should try not to break code in practice, and to allow an upgrade path from what we break. Under that constraint, we should try to have the semantics as clear as possible.\n\n> Feel free to mention your concerns in #30407. While your idea is appealing on a theoretical level, I don't think this is realistic for a systems language, making it harder to write low level code (allocators, kernels, etc.) in rust. \n\nClearly we need a \"low-level Rust\" specification in addition to the \"high-level Rust\" specification. Obviously we need them - our high-level specification does not talk about ABIs at all. However, I don't see much value in allowing the C standard `memcpy` to be legal Rust, especially because it is typically written in assembly.\n\n> Calling stable rust a systems language is already questionable (it fails the simple test that a systems language can, theoretically, compile itself: stable rust requires language items, stable rust will never be able to compile language items; that is, a stable rust compiler cannot even theoretically be a self-hosting compiler), and this idea makes even nightly rust less systems-y.\n\nrustc _does not_ require any lang-items. I don't see how this situation is qualitatively different from libc using linked assembly files for various system call stubs.\n\n> I think there isn't really a difference between \"official\" and \"sanctioned\". As long as it's not written down somewhere, it's no more than hearsay. If such a thing has actually been discussed and agreed on, then write it down where everyone can look it up so that we can properly language lawyer once you break it.\n\nIt is basically at the level of official hearsay. We are not willing to document performance characteristics at any level beyond that. Optimizers, both ours and LLVM's, can generate whatever code they feel like as long as it functions correctly. We try to make them generate fast code for things people write, especially the \"officially sanctioned\" ways, but we are not willing to promise anything.\n\nAs an analogy, `sysenter`/`sysexit` is Intel's officially sanctioned way of making system calls on x86-64: Intel tries very hard to make it fast, but I am sure that if you misconfigure your processor correctly you can make it slow, and anyway Intel does not give any performance guarantees for it.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167010924/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167388529",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-167388529",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 167388529,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzM4ODUyOQ==",
    "user": {
      "login": "Aatch",
      "id": 342416,
      "node_id": "MDQ6VXNlcjM0MjQxNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Aatch",
      "html_url": "https://github.com/Aatch",
      "followers_url": "https://api.github.com/users/Aatch/followers",
      "following_url": "https://api.github.com/users/Aatch/following{/other_user}",
      "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions",
      "organizations_url": "https://api.github.com/users/Aatch/orgs",
      "repos_url": "https://api.github.com/users/Aatch/repos",
      "events_url": "https://api.github.com/users/Aatch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Aatch/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-27T06:16:59Z",
    "updated_at": "2015-12-27T06:16:59Z",
    "body": "Is there a point to all of this? It just seems like an excuse to complain about things.\n\nUltimately, in the absence of an actual spec, the only thing we can go on is common sense and current behaviour. The corners are where common sense fails and current behaviour only works via luck. However, until we get a spec, there's no point in arguing about stuff like this.\n\nI'm in favour of just closing this issue unless some actionable issue is presented. We have other channels for this kind of discussion.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167388529/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167415377",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-167415377",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 167415377,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzQxNTM3Nw==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-27T14:03:12Z",
    "updated_at": "2015-12-27T14:03:12Z",
    "body": "@Aatch \n\nI think we should have some organized place for tracking the Rust memory model mess.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167415377/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/169172670",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-169172670",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 169172670,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2OTE3MjY3MA==",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-05T23:55:51Z",
    "updated_at": "2016-01-05T23:55:51Z",
    "body": "As @Aatch says, there's nothing really actionable here: spec-ing this sort of thing is the realm of an RFC, since there's design decisions to make and tradeoffs to be considered (e.g. http://www.playingwithpointers.com/problem-with-undef.html). Therefore, I'm closing.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/169172670/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/169224716",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-169224716",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 169224716,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2OTIyNDcxNg==",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-06T05:07:01Z",
    "updated_at": "2016-01-06T15:19:06Z",
    "body": "@huonw would you mind opening an RFC issue for this and linking it here?  As Ariel said, we should have some  central place to discuss this\n\nI'd do it but I'm on a mobile device for the next few hours\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/169224716/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/169459933",
    "html_url": "https://github.com/rust-lang/rust/issues/30500#issuecomment-169459933",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30500",
    "id": 169459933,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2OTQ1OTkzMw==",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-06T21:02:02Z",
    "updated_at": "2016-01-06T21:02:02Z",
    "body": "okay i opened an RFC issue for Rust needing a memory model; cc https://github.com/rust-lang/rfcs/issues/1447\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/169459933/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
