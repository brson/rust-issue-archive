[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33042087",
    "html_url": "https://github.com/rust-lang/rust/issues/11722#issuecomment-33042087",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11722",
    "id": 33042087,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMDQyMDg3",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-22T16:50:29Z",
    "updated_at": "2014-01-22T16:50:29Z",
    "body": "I am not clear on what is being suggested here.  I would imagine that one can write code parameterized over \"concepts\" with our existing trait system.  (E.g. you make a Tree trait, and the code is parameterized over <T:Tree>, and then callers feed in the particular tree implementation.  Likewise for a character sequence.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33042087/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33105627",
    "html_url": "https://github.com/rust-lang/rust/issues/11722#issuecomment-33105627",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11722",
    "id": 33105627,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTA1NjI3",
    "user": {
      "login": "nicolasboulay",
      "id": 5514486,
      "node_id": "MDQ6VXNlcjU1MTQ0ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5514486?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nicolasboulay",
      "html_url": "https://github.com/nicolasboulay",
      "followers_url": "https://api.github.com/users/nicolasboulay/followers",
      "following_url": "https://api.github.com/users/nicolasboulay/following{/other_user}",
      "gists_url": "https://api.github.com/users/nicolasboulay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nicolasboulay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nicolasboulay/subscriptions",
      "organizations_url": "https://api.github.com/users/nicolasboulay/orgs",
      "repos_url": "https://api.github.com/users/nicolasboulay/repos",
      "events_url": "https://api.github.com/users/nicolasboulay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nicolasboulay/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T08:36:47Z",
    "updated_at": "2014-01-23T08:49:19Z",
    "body": "Your proposal looks like c++ template, but you don't answer the question : \"how the end user will know which tree to use ?\"\nWhen the code change, the optimal contener could change also, this could be costly. \n\nTo take an Ocaml like example, you will use a AbstractString, the compiler will use String, Buffer or Rope. Rope if the string is big, Buffer if there is a lot of concatenation, String otherwise. A beginner will not need to know every concept of the standard library to have fast code. The standard library could offer many different contener without flooding the user.\n\nYou could also see this as a user guided way to make optimisation, that replace high level code, by an other one (imagine a serie of string concatenation replace by a buffer creation). But it looks more easy to do, in large scale.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33105627/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33106424",
    "html_url": "https://github.com/rust-lang/rust/issues/11722#issuecomment-33106424",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11722",
    "id": 33106424,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTA2NDI0",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T08:51:58Z",
    "updated_at": "2014-01-23T08:54:05Z",
    "body": "Branching based on the current representation and then switching the representation based on usage implies a very high bookkeeping overhead. For an unordered map, a hash table is almost always the right answer. For an ordered map, a tuned B-tree implementation will beat a red-black or AVL tree. Red-black trees are only useful because iterators and node pointers are never invalidated by insertions or removals of elements other than the one that's directed pointed.\n\nRust's unique strings/vectors are owned, mutable data structures so copy-on-write is not feasible. It would require many cases of locking to handle sending data between tasks. The obvious representation is as a dynamic array, and it's possible to write a type using small string optimization to trade off overall performance and code size for decreased memory usage and better memory locality with small strings. See #4991 for the existing issue about this.\n\nA rope has a different time complexity and performance characteristics than a dynamic array. Switching dynamically would be very risky for a language focused on reliable performance/latency. Additionally, keeping track of usage via metadata to choose the representation would be too expensive.\n\nAs for integration with the compiler itself to choose statically, I do not think it is realistic. It would require writing profiles for the application and doing high-level Rust-specific profile-guided optimization. Rust inherits the philosophy of C++ in avoiding hard-wired language features possible to implement in a library, with the standard types as unprivileged as possible so third party libraries able to reimplement data structures with the same power available.\n\nIf there are specific instances where this can be shown to make sense, then lets open issues for those. I don't think we need a general metabug about it.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33106424/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33108993",
    "html_url": "https://github.com/rust-lang/rust/issues/11722#issuecomment-33108993",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11722",
    "id": 33108993,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTA4OTkz",
    "user": {
      "login": "nicolasboulay",
      "id": 5514486,
      "node_id": "MDQ6VXNlcjU1MTQ0ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5514486?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nicolasboulay",
      "html_url": "https://github.com/nicolasboulay",
      "followers_url": "https://api.github.com/users/nicolasboulay/followers",
      "following_url": "https://api.github.com/users/nicolasboulay/following{/other_user}",
      "gists_url": "https://api.github.com/users/nicolasboulay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nicolasboulay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nicolasboulay/subscriptions",
      "organizations_url": "https://api.github.com/users/nicolasboulay/orgs",
      "repos_url": "https://api.github.com/users/nicolasboulay/repos",
      "events_url": "https://api.github.com/users/nicolasboulay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nicolasboulay/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T09:36:58Z",
    "updated_at": "2014-01-23T09:36:58Z",
    "body": "This is a compiler choice, nothing is dynamique. The heuristic could be very simple : use of implemented method, presence or not of loops, number of method calls, use of parameter to other function (to avoid recopy if possible).\n\nRed-black trees is use everywhere in linux, so it has some advantges. \"a hash table is almost always the right answer.\", sure but with 2 or 3 more contener, the compiler could choose always the best solution.\n\n\"Rust's unique strings/vectors are owned, mutable data structures so copy-on-write is not feasible. It would require many cases of locking to handle sending data between tasks.\"\n\nIf the compiler detect that a string, can't be send between task, it could choose to use copy-on-write.\n\n\"The obvious representation [of string] is as a dynamic array, \" not for text widget. Insertion is very costly. Contener of string to handle a string, is much more effiscient.\n\n\"Switching dynamically \" I never propose to do it dynamically, only at compile time. A future version could use profile guided compiling, but only in the future.\n\nI don't understand your point on library, contener/String are example, because they have known interface. But you could extend it to any algorithme (search, sort, strategy pattern...)\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33108993/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33111333",
    "html_url": "https://github.com/rust-lang/rust/issues/11722#issuecomment-33111333",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11722",
    "id": 33111333,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTExMzMz",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T10:11:56Z",
    "updated_at": "2014-01-23T10:14:29Z",
    "body": "> This is a compiler choice, nothing is dynamique. The heuristic could be very simple : use of implemented method, presence or not of loops, number of method calls, use of parameter to other function (to avoid recopy if possible).\n\nThe compiler will be unable to determine this information in anything but a toy example. Retrieving the necessary metadata would require dynamic instrumentation via profile-guided optimization. \n\nEven if this was a realistic optimization, Rust is diametrically opposed to an implicit performance model like this. The performance of an application should not be vulnerable to small inconsequential changes to the code destroying performance across the codebase by subverting a fragile whole program optimization.\n\n> Red-black trees is use everywhere in linux, so it has some advantges.\n\nRed-black trees are a well-known data structure so they're widely used. Data structures like this with one element per-node are viable intrusive data structures, which is why the Linux kernel itself uses them. This is not something Rust's ordered map can expose. Rust is also unable to take advantage of the iterator invalidation guarantees which are _required_ by the C++ standard and result in the implementations being forced into using a red-black tree.\n\nAs soon as a high quality implementation of a B-tree is finished, Rust can replace the current `TreeMap` implementation for performance and memory usage wins in nearly every case. See [Google's implementation](https://code.google.com/p/cpp-btree/wiki/UsageInstructions) for an overview of the benefits. A red-black tree is simply quite awful on 64-bit because the node size is _doubled_ and they're unsuited to modern architectures with CPU caches.\n\n> If the compiler detect that a string, can't be send between task, it could choose to use copy-on-write.\n\nIt will be unable to determine this in most cases. Rust doesn't have an effects system, and this probably wouldn't be possible to model in a reasonably simple implementation of one. Copy-on-write is not worth doing for anything but large strings, so that's more unrealistic analysis to perform. The compiler just isn't going to have static knowledge about the string sizes in real world applications.\n\n> I don't understand your point on library, contener/String are example, because they have known interface. But you could extend it to any algorithme (search, sort, strategy pattern...)\n\nI don't really see how you're going to speed up sorting or searches by having the compiler select different algorithms. If allocating is okay, then a well-written merge sort is hard to beat. Otherwise, a heap sort works well when allocation is unacceptable without losing `O(n log n)` performance.\n\nRust could _always_ use a radix sort for integers as the cases when it can be used are static knowledge. A library is fully capable of doing this without hard-wiring special cases into the compiler.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33111333/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
