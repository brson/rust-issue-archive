[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1575734",
    "html_url": "https://github.com/rust-lang/rust/issues/693#issuecomment-1575734",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/693",
    "id": 1575734,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NzU3MzQ=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2011-07-14T22:41:49Z",
    "updated_at": "2011-07-14T22:41:49Z",
    "body": "I'm not completely sold yet. I think we should discuss this more, particularly (as I think Dave said) with an eye to figuring out exactly what the static guarantees we can give are with whatever predicate language we end up choosing.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1575734/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1575738",
    "html_url": "https://github.com/rust-lang/rust/issues/693#issuecomment-1575738",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/693",
    "id": 1575738,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NzU3Mzg=",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2011-07-14T22:42:20Z",
    "updated_at": "2011-07-14T22:42:20Z",
    "body": "Can someone relate this convincing argument? First I've heard of it :)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1575738/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1575946",
    "html_url": "https://github.com/rust-lang/rust/issues/693#issuecomment-1575946",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/693",
    "id": 1575946,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NzU5NDY=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2011-07-14T22:52:52Z",
    "updated_at": "2011-07-14T22:52:52Z",
    "body": "It came up during our meeting with Dan Grossman yesterday. My understanding of it is that type soundness doesn't require the compiler to check, or know anything about, that the relationship between the semantics of the refined type corresponding to a certain typestate predicate, and the semantics of the implementation of that typestate predicate, makes sense. For example:\n\n```\npred le(uint x, uint y) -> { true }\nfn substr(uint start, uint end, str s) : le(start, end)  -> {...}\n```\n\nIn this code, the implementation of le is probably not what the user had in mind. As far as whether it matters for soundness, that depends on whether substr calls some unsafe primitive that requires start to be less than or equal to end. But that's a problem even with the current system; everything here is pure.\n\nSimilar problems come up in Haskell. For example, you can define an instance of the Monad type class that doesn't satisfy the monad laws. The compiler won't help you there.\n\nSo I actually may just have convinced myself that since you run into problems even without considering impurity of the nature of the compiler not being able to check for you that your value semantics actually uphold your type semantics, we might as well just allow any function to be used as a predicate. The story would then be \"the programmer has a proof obligation to make sure the typestate system they define for themselves is sound with respect to the semantics of the predicates they use in typestate constraints.\" This would suggest that those predicates probably have to be referentially transparent, but the compiler won't enforce that.\n\nLet me know if this makes sense...\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1575946/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1576027",
    "html_url": "https://github.com/rust-lang/rust/issues/693#issuecomment-1576027",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/693",
    "id": 1576027,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NzYwMjc=",
    "user": {
      "login": "eholk",
      "id": 105766,
      "node_id": "MDQ6VXNlcjEwNTc2Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eholk",
      "html_url": "https://github.com/eholk",
      "followers_url": "https://api.github.com/users/eholk/followers",
      "following_url": "https://api.github.com/users/eholk/following{/other_user}",
      "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eholk/subscriptions",
      "organizations_url": "https://api.github.com/users/eholk/orgs",
      "repos_url": "https://api.github.com/users/eholk/repos",
      "events_url": "https://api.github.com/users/eholk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eholk/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2011-07-14T23:06:12Z",
    "updated_at": "2011-07-14T23:06:12Z",
    "body": "Where do we see typestate going in the future? Removing all the restrictions purity and whatnot in predicates seems to turn them sort of into C++ Concepts, where the programmer asserts a certain property is true and you write code assuming it's true but the compiler has almost no way to verify it. \n\nAnother direction I can see going is to say that right now we only know how to run the code and see if it's true, but in the future we might be able to do deeper reasoning about predicates. This gives the compiler a lot more freedom to omit checks and things when it can prove the condition already holds (for example, using transitivity of less-than).\n\nIf we see typestate going more in this direction (which is a very hard and still very researchy direction), then I think it makes sense to start with a more restricted language and extend it as we have a better idea what sorts of things the compiler can prove automatically.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1576027/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1576051",
    "html_url": "https://github.com/rust-lang/rust/issues/693#issuecomment-1576051",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/693",
    "id": 1576051,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NzYwNTE=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2011-07-14T23:10:33Z",
    "updated_at": "2011-07-14T23:10:33Z",
    "body": "In the \"deeper reasoning\" department, I think if we do go in that direction, it should be modular; instead of magic being baked into the compiler, there should be a way for the user to declare axioms / theorems about relationships between different typestate predicates. I think that would be pretty cool, but it does take us more into theorem-proving-land, and it would make the behavior of the compiler easy to reason about. It seems like in keeping with the philosophy of Rust overall, typestate is about making it very obvious which checks actually happen at runtime. If the compiler starts doing a bunch of automated theorem proving, that could make performance hard to reason about. Small changes to code could stymie a proof search and turn code with no dynamic checks into code with a bunch of dynamic checks all of a sudden.\n\nFrom the perspective of predictability and control, it might really be better to hang onto the \"the compiler doesn't know anything about the semantics of predicates\" philosophy. And requiring predicates to be pure seems like a weird halfway point between the full-theorem-proving approach, and the know-nothing approach.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1576051/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1576090",
    "html_url": "https://github.com/rust-lang/rust/issues/693#issuecomment-1576090",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/693",
    "id": 1576090,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NzYwOTA=",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2011-07-14T23:19:11Z",
    "updated_at": "2011-07-14T23:19:11Z",
    "body": "I agree in the sense of \"... required for soundness\". The typestate system's predicates are certainly operating outside the type system, and their truth or falsity is entirely up to the user to imbue with meaning.\n\nI disagree that it follows that we should give up tracking purity on preds. The point of the typestate system, after all, is to track the evolution of _state_. In particular when variables change, typestates are invalidated. This happens _because_ we assume the typestate is pure (and applied to immutables). If we give up on the purity as well, there's kinda no point in imagining a typestate holds from one moment to the next. We might as well apply them to mutable values also. The device loses its abstraction-over-flow-control, turns into just a point-in-time judgment. This seems like a serious loss to me. Feels akin to saying \"since you might not alter a mutable value, or make a logic error with an immutable value, there's no point really tracking which values are mutable or immutable\". I don't buy that. The added guarantee is helpful in \"saying what you want to guarantee\".\n\nDoes this makes sense?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1576090/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1576313",
    "html_url": "https://github.com/rust-lang/rust/issues/693#issuecomment-1576313",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/693",
    "id": 1576313,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NzYzMTM=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2011-07-14T23:27:05Z",
    "updated_at": "2011-07-14T23:27:05Z",
    "body": "Indeed, we might as well apply them to mutable values too if we go this route.\n\nThe problem with trying to enforce purity is that whatever we come up with is going to limit expressivity a lot. We might want to write some predicate that's semantically referentially transparent but that mutates local state. For example, we might want to write the substr function above like:\n\n```\nfn substr(uint start, uint end, str s) : le(start, end), le_len_of_str(end, s)  -> {...}\n```\n\nwhere we would want to write le_len_of_str like:\n\n   pred le_len_of_str(uint end, str s) -> bool { end <= str::len(s) }\n\nbut we can't do this, because len is impure, and it can't easily be made pure because it contains a for loop and increments a counter. Observably, len is pure, but since we decided not to do an effect system, we can't invoke effect masking there.\n\nIt's possible to write a tail-recursive pure version of len, but then I don't like the specter of having to write a \"pure\" and \"pred\" version of lots of common functions that are operationally the same.\n\nI don't think there's an easy answer, and I think we should dedicate some time to discussing this. The question doesn't have to be answered right away, because there's still plenty of work I can do exploring what's possible with the current, restricted system.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1576313/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1576630",
    "html_url": "https://github.com/rust-lang/rust/issues/693#issuecomment-1576630",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/693",
    "id": 1576630,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NzY2MzA=",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2011-07-14T23:52:22Z",
    "updated_at": "2011-07-14T23:52:22Z",
    "body": "Yup. This is why we had an effect system in the first place.\n\nQuestion is whether the absence of effect reasoning in general is severe that all serious preds wind up doing something unsafe to get around the purity limit. If that's true, I agree there's not much point in trying to maintain the restriction. But I am not sure how it will play out. I was hoping a few higher-order (possibly unsafe) preds on each data structure would suffice to build many more safe ones, but maybe that's not true.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1576630/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1586233",
    "html_url": "https://github.com/rust-lang/rust/issues/693#issuecomment-1586233",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/693",
    "id": 1586233,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1ODYyMzM=",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2011-07-16T07:41:35Z",
    "updated_at": "2011-07-16T07:41:35Z",
    "body": "Simplifying proposal: preds can call non-pred functions, but can still only apply to immutable values. With further restriction: can only apply to immutable _transparent_ values -- nothing containing objects, functions (or channels/ports/tasks, which will probably all be in libraries as obj and fn types anyways).\n\nThis gives you a form of \"purity\" that, I think, permits as much local state as you want, while still being pure-in-the-arguments. No?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1586233/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1786950",
    "html_url": "https://github.com/rust-lang/rust/issues/693#issuecomment-1786950",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/693",
    "id": 1786950,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3ODY5NTA=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2011-08-11T23:25:12Z",
    "updated_at": "2011-08-11T23:25:12Z",
    "body": "Sorry this took so long, but Dave and I had some discussions and we finally have what I think is a feasible way to proceed now:\n\nhttps://github.com/graydon/rust/wiki/Proposal-for-predicate-language\n\nGraydon (or anyone else who may be following this), let me know your thoughts whenever you get a chance to look at it.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1786950/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1917698",
    "html_url": "https://github.com/rust-lang/rust/issues/693#issuecomment-1917698",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/693",
    "id": 1917698,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE5MTc2OTg=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2011-08-26T22:59:10Z",
    "updated_at": "2011-08-26T22:59:10Z",
    "body": "I'm marking this resolved for now. \"pred\" is now \"pure fn\" and \"pure fn\" can have a non-bool return typed. Unchecked blocks are implemented, so you can escape out to any code within a pure fn. (This is documented in the .texi file.) I think this is a reasonable solution for now.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1917698/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
