[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/165910459",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-165910459",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 165910459,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NTkxMDQ1OQ==",
    "user": {
      "login": "steveklabnik",
      "id": 27786,
      "node_id": "MDQ6VXNlcjI3Nzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/steveklabnik",
      "html_url": "https://github.com/steveklabnik",
      "followers_url": "https://api.github.com/users/steveklabnik/followers",
      "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}",
      "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions",
      "organizations_url": "https://api.github.com/users/steveklabnik/orgs",
      "repos_url": "https://api.github.com/users/steveklabnik/repos",
      "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/steveklabnik/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-18T22:21:48Z",
    "updated_at": "2015-12-18T22:21:48Z",
    "body": "/cc @rust-lang/lang \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/165910459/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167009014",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-167009014",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 167009014,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzAwOTAxNA==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-23T23:34:17Z",
    "updated_at": "2015-12-23T23:34:17Z",
    "body": "Wow. This looks like a big issue in my model of aliasing, but maybe it is not so scary.\n\nThe problem here is that we want locals to be essentially \"always borrowed by the containing function\", and IIRC we already perform optimizations that use that (so your code should probably be UB). On the other hand, we _do_ need to have some way of converting mutable references to raw pointers and back again.\n\nI think _that_ is the reason why @thestinger wanted an access-based, rather than an instant-death-based, aliasing model. An access-based aliasing model basically says that a valid reference _that is dereferenced and used_ must not be incompatibly accessed - by raw pointers, other mutable references, modification of the page table, DMA by random peripherals, etc. - for its entire live lifetime. An instant-death-based model is similar but does not include the \"that is dereferenced and used\" part.\n\nLLVM also has some fancy rules on pointer comparisons, but we can't feasibly support them as we allow taking the addresses of arbitrary things in safe code.\n\nThe problem with the access-based model is that it is problematic with \"spurious\" accesses (e.g. lifting accesses out of a loop), so we probably need some synthesis of the models - maybe using instant-death in functions without `unsafe` blocks and access-based in functions with, or maybe having some \"undefined value\" sort of semantics (related question: if I have a `&mut` reference laying around, am I allowed to `munmap` a hole within it?).\n\nA few examples for the mutable-references-to-raw-pointers-and-back-again issue, for exposition::\n\n``` Rust\nfn f(&self) -> &Self { self }\nfn f_mut_unsure<'s>(&'s mut self) -> &'s mut Self {\n    let ret = unsafe { transmute::<&Self, &'s mut Self>(self.f()) };\n    ret // \u03b2-expansion should have no effect\n}\nfn f_mut_should_work<'s>(&'s mut self) -> &'s mut Self {\n    let ret = unsafe { &mut *(self.f() as *const Self as *mut Self) };\n    ret // \u03b2-expansion should have no effect\n}\n```\n\nThere are basically 2 aliasing issues there:\n- In both cases, `self` is only borrowed within the `unsafe` block, as there is nothing that would make the borrow any longer. Therefore, on the second line both `ret` and `self` are live mutable pointers to the same place.\n- In the first case only, the reborrow of `self` would be another alias, alive just after the return from `transmute`. This is what is linted against.\n\nUnder \"instant death\" rules, both are UB, so we can't have that. Under the access-based rules, both are fine. We had a proposal flying around that `&`-references use instant death and `&mut` use some variant of access-based, which would make the first UB and the second safe.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167009014/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167009159",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-167009159",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 167009159,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzAwOTE1OQ==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-23T23:35:56Z",
    "updated_at": "2015-12-23T23:35:56Z",
    "body": "Of course the reason we want some kind of softer rules for `&mut` is because unsafe code can \"hand-reborrow\" these sorts of references, and then we are have to guess about the lifetime of the intended hand-reborrow.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167009159/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167009462",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-167009462",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 167009462,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzAwOTQ2Mg==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-23T23:39:18Z",
    "updated_at": "2015-12-23T23:40:03Z",
    "body": "Technically, a more explicit version of the above would be\n\n``` Rust\nfn f_mut_pedantic<'s>(&'s mut self) -> &'s mut Self {\n    let captured_self = self as *mut Self;\n    unsafe { &mut *((*captured_self).f() as *const Self as *mut Self) }\n}\n```\n\nwhich inactivates `self`, but I would hate to make it necessary (you can use a `transmute` to replace some of the cast dance).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167009462/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167012558",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-167012558",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 167012558,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzAxMjU1OA==",
    "user": {
      "login": "aturon",
      "id": 709807,
      "node_id": "MDQ6VXNlcjcwOTgwNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aturon",
      "html_url": "https://github.com/aturon",
      "followers_url": "https://api.github.com/users/aturon/followers",
      "following_url": "https://api.github.com/users/aturon/following{/other_user}",
      "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aturon/subscriptions",
      "organizations_url": "https://api.github.com/users/aturon/orgs",
      "repos_url": "https://api.github.com/users/aturon/repos",
      "events_url": "https://api.github.com/users/aturon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aturon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-24T00:16:18Z",
    "updated_at": "2015-12-24T00:16:18Z",
    "body": "cc @ralfjung\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167012558/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167096698",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-167096698",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 167096698,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzA5NjY5OA==",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-24T11:37:19Z",
    "updated_at": "2015-12-24T11:37:19Z",
    "body": "> The problem here is that we want locals to be essentially \"always borrowed by the containing function\", and IIRC we already perform optimizations that use that (so your code should probably be UB). \n\nWhich optimizations would/could that be?\n\nI don't think I'm entirely understanding the significance of choosing an \"aliasing model\", or actually what an \"aliasing model\" is. I suppose it is related to `UnsafeCell` being the only defined way to convert a shared borrow to a mutable one? At least, the part of the language reference this issue is about also mentions `UnsafeCell`.\n\nDisclaimer: So far, the LLVM `noalias` annotation and the special case of `UnsafeCell` are out of scope of my formal development. I did not give much thought to how to formally model \"UB through interior mutability outside of `UnsafeCell`\", and what it would take to prove absence of that UB. The fact that `noalias` is as poorly understood as C's `restrict` (right now, I don't know of anybody who has a real idea what it could formally mean) doesn't help.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167096698/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167140680",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-167140680",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 167140680,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzE0MDY4MA==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-24T17:41:09Z",
    "updated_at": "2015-12-24T17:41:09Z",
    "body": "@RalfJung \n\nThe aliasing rules basically say that the compiler can assume that nobody is modifying its memory behind its back (this also includes calls to external functions and the compiler's own pointer writes). This is important for optimizations like copy elimination and store-to-load forwarding. For example, if we have\n\n``` Rust\n#[derive(Debug,Copy,Clone)]\nstruct Foo {\n    bar: Bar\n}\n#[derive(Debug,Copy,Clone)]\nstruct Bar {\n    // lots of data\n}\nfn doit() -> u32 {\n    let foo = Foo { bar: make_bar() };\n    debug!(\"{}\", &foo);\n    match foo {\n        Foo { bar } => frobnicate(&mut bar)\n    };\n}\n```\n\nIn a case like this, we would like to make `foo.bar` and `bar` point to the same place (rather than physically moving `foo` to `bar`). However, if `debug!(...)` ends up storing the address of `foo` in a global variable, this would be problematic because `frobnicate` could access the original `foo` along with the `bar`.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167140680/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167253200",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-167253200",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 167253200,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzI1MzIwMA==",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-25T17:41:51Z",
    "updated_at": "2015-12-25T17:41:51Z",
    "body": "Thanks for the example! I suppose at some point I will have to mask for more examples of copy elimination and store-to-load forwarding, just to get an idea what it would take to formally justify these transformations.\n\nIn this case however, I am puzzle. Please excuse me being so slow ;-) .\nIf `debug` stored the `&foo` anywhere, how would that in any way help `frobnicate`, considering that the lifetime of this reference ends on the semicolon after `debug!`?\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167253200/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167317590",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-167317590",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 167317590,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzMxNzU5MA==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-26T11:22:20Z",
    "updated_at": "2015-12-26T11:22:20Z",
    "body": "@RalfJung\n\nBecause we want to treat pointers as \"just integers\", they don't have a lifetime associated with them if you do things like convert them to a raw pointer and back. This is required for `f_mut` to work.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167317590/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167320358",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-167320358",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 167320358,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzMyMDM1OA==",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-26T12:26:26Z",
    "updated_at": "2015-12-26T12:28:47Z",
    "body": "What is `f_mut`?\n\nThe pointer passed to `debug!` _had_ a lifetime associated with it.\nThis means `debug` has the permission to use that pointer _for the duration of that lifetime_. Of course it can convert it to a raw pointer, but it cannot convert it back to a shared reference with a larger lifetime. That piece of unsafe code would be severely wrong, because the caller may long since have handed a _mutable_ reference to someone else (after the end of the lifetime of the shared reference).\n\nMy approach to checking validity of unsafe code is not at all about aliasing, so I don't have to think about how pointers are represented here. (Also, I am pretty sure that unsafe Rust _cannot_ pretend pointers are just integers, because that's not what LLVM does. See https://internals.rust-lang.org/t/comparing-dangling-pointers/3019.)\nInstead, I think about the _permissions_ a piece of code has, and whether these permissions justify the actions taken by the code. For example, a shared reference with lifetime `'a` (to something that is `Copy`) carries with it the permission to read from that pointer as long as lifetime `'a` lasts. After the end of `'a`, that permission is entirely useless and does not grant the right to perform any action. Converting a shared reference to a raw pointer does not actually do anything, so there's no permission required to do that, but converting it back to a shared reference requires the code to somehow cough up the permissions that back a shared reference - and `debug!` cannot possibly have that permission.\n\nThere is some relation to aliasing, of course. In particular, permissions are passed around in a linear way, i.e., they cannot be duplicated. The permission associated with a mutable reference is such that it is impossible for anyone else to have the same permission (or the \"shared reference\" permission) for the same location. From having the \"mutable reference\" permission for pointer `p` it follows that no pointer `q` for which someone else has any \"reference\" permission can alias `p`. But this is a consequence of permissions held by separate parties being disjoint, it is not the fundamental building block of how I think about references. I'd like to understand how the \"aliasing-based\" approach works, in particular how the compiler uses it to justify certain transformations, to make sure that these assumptions are actually backed by the permissions I associated with various types.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167320358/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167355556",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-167355556",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 167355556,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzM1NTU1Ng==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-26T19:23:02Z",
    "updated_at": "2015-12-26T19:23:02Z",
    "body": "@ralfjung\n\nI was quite convinced that all raw pointers to the same address are pretty much equivalent. \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167355556/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167355596",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-167355596",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 167355596,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzM1NTU5Ng==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-26T19:24:06Z",
    "updated_at": "2015-12-26T19:24:06Z",
    "body": "Maybe a model with equal raw pointers being equivalent does not allow desirable optimizations so we need a different one.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167355596/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167371421",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-167371421",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 167371421,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzM3MTQyMQ==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-26T23:32:27Z",
    "updated_at": "2016-01-03T21:20:30Z",
    "body": "> What is `f_mut`?\n\nOne of the functions from the previous example, say:\n\n``` Rust\nfn f_mut_pedantic<'s>(&'s mut self) -> &'s mut Self {\n    let captured_self = self as *mut Self;\n    unsafe { &mut *(Self::f(&*captured_self) as *const Self as *mut Self) }\n}\n```\n\nWe basically want them to be defined. This means we can't \"precisely\" track borrows, at least in functions with unsafe blocks (e.g. in the latter function, `self` is not borrowed _at all_).\n\n> My approach to checking validity of unsafe code is not at all about aliasing, so I don't have to think about how pointers are represented here. \n\nWe must be using different definitions of \"aliasing\". The definition I (and I think LLVM) uses is that accessed addresses in an object pointed to by a `noalias` pointers can't be incompatibly accessed during their `noalias` scope except by pointers derived from that pointer, with \"derived from\" being rather conservative.\n\nRust's definition is pretty similar - an accessed field of a reference can't be incompatibly accessed while the reference is active (that's it, live and not-incompatibly-borrowed).\n\nThe problem with only having `noalias` is that it does not allow misoptimizing cases like the OP (in C lingo, a variable read via a `scanf` can now be aliased by everything).  LLVM uses `nocapture` to account for that, which makes the relevant argument become indeterminate after the call. Rust can't afford to emit that because that would require having integers become indeterminate.\n\nInstead, in Rust I think we should say that locals are basically implicitly borrowed by the owning function (they are already treated as such by the borrow checker/safety proof) which would also allow for this kind of reasoning.\n\n> Of course it can convert it to a raw pointer, but it cannot convert it back to a shared reference with a larger lifetime. That piece of unsafe code would be severely wrong, because the caller may long since have handed a mutable reference to someone else (after the end of the lifetime of the shared reference).\n> \n>  Instead, I think about the permissions a piece of code has, and whether these permissions justify the actions taken by the code. \n\nThat is not the way we decided to go about with unsafe Rust. We try not to have a hardcoded notion of \"permissions\" - people come up with pretty exotic ways to split array indices. There is some system of permissions that gives safe Rust its safety proof, but unsafe code is free to use a different system without risking UB. And even if that system is incompatible with the real one (e.g. an unrestricted \"write-what-where\" primitive, or a safe `transmute_lifetime`) that would only be _unsafe_ (be a bad practice), but not _UB_ unless it is actually used to break some rules.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/167371421/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/168539718",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-168539718",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 168539718,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2ODUzOTcxOA==",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-03T20:44:43Z",
    "updated_at": "2016-01-03T20:44:43Z",
    "body": "> I was quite convinced that all raw pointers to the same address are pretty much equivalent. \n\nI am not sure what you mean by \"equivalent\" here. Permissions are entirely independent of the actual values processed on the machine, so one function could work on a raw pointer with some permissions, and another function could work on the same raw pointer and have no or different permissions. Permissions are associated with _types_, and the raw pointer type carries no permission. Of course, unsafe functions can always declare that they want more (or less, or different) permissions than what the types promise.\nI also don't understand how this relates to my post. Sorry I'm so slow on this here, we seem to have very different trains of thought.\n\n> That is not the way we decided to go about with unsafe Rust. We try not to have a hardcoded notion of \"permissions\" - people come up with pretty exotic ways to split array indices. There is some system of permissions that gives safe Rust its safety proof, but unsafe code is free to use a different system without risking UB. And even if that system is incompatible with the real one (e.g. an unrestricted \"write-what-where\" primitive, or a safe transmute_lifetime) that would only be unsafe (be a bad practice), but not UB unless it is actually used to break some rules.\n\nThere has to be _some_ coherent notion of permissions associated with the basic Rust types that is common to all code. This is a necessary condition for soundness. After all, we'd like to take all of these safely encapsulated, but unsafely implemented pieces of Rust and use them _in the same program_. This is only possible if they all agree on what the basic types mean, which permissions they grant.\nUnsafe code, on the other hand, is free to do whatever it wants. It doesn't have to follow any existing permission scheme, if there is no interest in a safe abstraction.\n\nOf course, the permission associated with shared borrows will be a _very_ flexible one, mirroring the fact that programs have lots of flexibility what they do with their shared borrows - just think of `RefCell`.\nWhat exactly are you referring to when you refer to \"splitting array indices\"? The permission associated with an array will consist of all the individual permissions for its elements. And of course, it is possible to partition this array arbitrarily, and split the array permission accordingly - as long as those individual partitions are all pairwise disjoint. This is something that separation logic does automatically for us.\n\n```\nfn f_mut_pedantic<'s>(&'s mut self) -> &'s mut Self {\n    let captured_self = self as *mut Self;\n    unsafe { &mut *((*captured_self).f() as *const Self as *mut Self) }\n}\n```\n\n> We basically want them to be defined. This means we can't \"precisely\" track borrows, at least in functions with unsafe blocks (e.g. in the latter function, self is not borrowed at all).\n\nThis function looks fairly harmless to me. All these pointer casts do not actually _do_ anything, in the end, all that happens here is that `f` is called. `f_mut_pedantic` takes something of type `&mut Self` as argument, so it can do anything you can do with a mutable borrow - including re-borrowing it as a shorter shared borrow, passing that shared borrow to `f`. We know that `f` just returns its argument, so we know it returns the shared-borrow-permission for `s`, and we can end the re-borrow, re-obtain our mutable borrow, and be happy.\nOr did you say that this function should be safe for _any_ `f`? That would be rather surprising... I think we'd need some kind of parametricity argument saying that `f` has to return its argument. And I don't think that would survive specialization...\n\nOf course, the proof sketch above entirely ignores the fact that Rust adds `noalias` annotations to arguments. Until someone formally understands what `noalias` is, there's not much we can do there. We probably would not like to make Rust's semantics depend on the precise nuances of `noalias` anyway, since (I assume) it's something of a beast.\nSo far it was my understanding that what Rust actually wants to enforce is something like \"there is no interior mutability outside of `UnsafeCell`\". From this it should then follow that the `noalias` annotation is correct. In `f_mut_pedantic` above, we actually start with a mutable borrow, so we _do_ have the right to mutate it. We know the function body of `f`, so we can prove manually that whatever permissions we have are good enough for `f`, so we should be fine.\n\nIn particular, I noticed that `f_mut_pedantic` actually _does_ contain a `& <something>`, a shared borrow starts - it's the implicit borrowing happening when `f` is called. Slightly de-sugared, the function looks as follows:\n\n```\nfn f_mut_pedantic<'s>(&'s mut self) -> &'s mut Self {\n    let captured_self = self as *mut Self;\n    unsafe { &mut *((&*captured_self).f() as *const Self as *mut Self) }\n}\n```\n\nSo, there actually is a clear point where \"freezing\" starts. (I think of there being explicit machine instructions to freeze and unfreeze a block of memory. They would be called whenever a shared borrow starts or ends, which should be statically known. Then whenever we write to a location, we can trigger UB if it is frozen. This explains why you can't just transmute a shared borrow to a mutable one, even in unsafe code. This freezing would of course not happen for `UnsafeCell`.)\nThe freezing would end when the lifetime of the shared borrow ends, which is right after the call to \u00b4f`. So, I think this function is fine in my view of the world.\n\nAn interesting question here may be - and maybe that's what some of your other examples are about - is what would happen if there is _no_ explicit `&`, if the shared borrow starts with some casts instead of an actual borrow with a proper lifetime. Then there would be no \"freeze\" instruction emitted, and we may wonder whether `f` is safe to call, since it may assume that its argument is frozen. No sure if anyone cal follow me here... I'll have to think more about this, but right now I am struggling with more fundamental problems in my formal development ;-)\n\n> We must be using different definitions of \"aliasing\". The definition I (and I think LLVM) uses is that accessed addresses in an object pointed to by a noalias pointers can't be incompatibly accessed during their noalias scope except by pointers derived from that pointer, with \"derived from\" being rather conservative.\n> \n> Rust's definition is pretty similar - an accessed field of a reference can't be incompatibly accessed while the reference is active (that's it, live and not-incompatibly-borrowed).\n\nWell, unfortunately I have no idea how to formally capture the notion of aliasing you are using here. As far as I know, nobody has figure out what `noalias` actually means in an operational semantics. So while these intuitions are nice, they don't really help me.\nBy \"aliasing\" above, I meant \"the pointers are equal\". That's why this question is related to how pointers are represented as bits.\n\n> The problem with only having noalias is that it does not allow misoptimizing cases like the OP (in C lingo, a variable read via a scanf can now be aliased by everything). LLVM uses nocapture to account for that, which makes the relevant argument become indeterminate after the call. Rust can't afford to emit that because that would require having integers become indeterminate.\n> \n> Instead, in Rust I think we should say that locals are basically implicitly borrowed by the owning function (they are already treated as such by the borrow checker/safety proof) which would also allow for this kind of reasoning.\n\nHow does the OP's code relate to `scanf`? And which arguments of `scanf` become indeterminate? Also, in unsafe Rust, pretty much anything already _can_ become indeterminate. Or are you saying taht this could come up in safe Rust? Sorry, you entirely lost me here.\n\nAlso, regarding `scanf`, does this mean that if an LLVM program writes a pointer value to a file, then reads it back, and then uses the pointer it read (under the guarantee that it did not change), that this would _not_ be a valid pointer to be used? Is that what `nocapture` makes happen?\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/168539718/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/168541165",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-168541165",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 168541165,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2ODU0MTE2NQ==",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-03T21:15:20Z",
    "updated_at": "2016-01-03T21:15:20Z",
    "body": "Ah yes, now that I realized you may be talking about interior mutability and how to allow it only within `UnafeCell` - how to coherently make mutation through a pointer derived from a shared borrow UB -  I think I can follow your code examples much better ;-) . All the talking about \"aliasing\" somehow didn't do it for me.\nBtw, I heard people saying that \"Transmuting a shared borrow to a mutable borrow is UB\". Is it really the _cast_ that you consider UB, or is it using the resulting pointer to perform mutation? I can't see how UB could arise just from the cast itself, no matter which annotations you emit to LLVM.\n\nSo, coming to your other two examples:\n\n``` rust\nfn f_mut_unsure<'s>(&'s mut self) -> &'s mut Self {\n    let ret = unsafe { transmute::<&Self, &'s mut Self>(self.f()) };\n    ret // \u03b2-expansion should have no effect\n}\nfn f_mut_should_work<'s>(&'s mut self) -> &'s mut Self {\n    let ret = unsafe { &mut *(self.f() as *const Self as *mut Self) };\n    ret // \u03b2-expansion should have no effect\n}\n```\n\nPutting my \"freeze/unfreeze\" glasses on (I have no idea if they make any sense, but it's the only operational take I was able to get on this so far), my question is where these (virtual) freeze and unfreeze instructions are emitted. I think both functions are kind of the same here. In both functions, the `self` argument to `f` is obtained by casting the `self: &mut Self` to `&Self` (and this is a regular cast, the Rust compiler sees this happen - it's not a `transmute`). Now the crucial question is, which lifetime does the borrow passed to `f` have.\n- If we really just have a downcast of the mutability here, then the argument to `f` has the same lifetime as the argument to `f_mut`. That would be rather bad, because we want to up-cast to a mutable borrow again later.\n- So we better make sure that the compiler actually determines a new lifetime for the cast-down `self`. If it does, then that lifetime should turn out to be just the call to `f`, so that `self` is unfrozen immediately. Then both functions would be safe.\n\nThis one, however, would not:\n\n``` rust\nfn f_mut_bad<'s>(&'s mut self) -> &'s mut Self {\n    let ret = unsafe { transmute::<&'s Self, &'s mut Self>(self.f()) };\n    ret // \u03b2-expansion should have no effect\n}\n```\n\nNotice that this forces the lifetime of `f`'s argument to be `'s`, which means that `self` has to be frozen for the rest of `'s` - which is not even something we can make happen, because `'s` may be much longer than the call to `f_mut_bad`.\n\nAnd then there is the functions that use casts to obtain the argument of `f`...\n\n``` rust\nfn unsafe cast_mut_away<T>(x: &mut T) -> &T { transmute(x) } // make sure transmute does not change the lifetime\nfn f_mut_dunno<'s>(&'s mut self) -> &'s mut Self {\n    let local = &mut *self; // just to get a local re-borrow with a lifetime shorter than the function body\n    unsafe { &mut *(cast_mut_away(local).f() as *const Self as *mut Self) }\n}\n```\n\nThe argument to `f` should have a short lifetime, so that's fine, but there's not actually a shared borrow starting anywhere, so the memory never got frozen. Is that bad? `f` assumes the memory is frozen, so it won't do anything that could mutate, so it should not care that memory is _not_ frozen. The only guarantee we ever need is that if we have a `&mut` (or if we own something), then it is _not_ frozen. Maybe. I am not sure.\nOf course, then `fn f_mut_bad` could also be entirely fine, _if_ there are not actually any \"freeze\" instructions emitted. It's not like I have any idea what the concrete rules for emitting these instructions would be...\n\n@arielb1, how do these functions look to you?\n\nComing back to the OP,\n\n``` rust\npub unsafe fn a() -> u8 {\n    let mut x = 11;\n    b(&x as *const u8 as *mut u8);\n    x\n}\n\nunsafe fn b(x: *mut u8) {\n    *x = 22;\n}\n```\n\nMy central question here would be, what is the lifetime of the borrow created at `&x`? It is entirely unconstrained, so it could last for no time at all. Then memory would be unfrozen before `b` is called, and this code should be fine.\nWhich optimizations did you envision that could make above code UB?\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/168541165/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/168541440",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-168541440",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 168541440,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2ODU0MTQ0MA==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-03T21:21:41Z",
    "updated_at": "2016-01-03T21:21:41Z",
    "body": "@RalfJung \n\n> There has to be some coherent notion of permissions associated with the basic Rust types that is common to all code. This is a necessary condition for soundness. \n> Of course, the permission associated with shared borrows will be a very flexible one, mirroring the fact that programs have lots of flexibility what they do with their shared borrows - just think of RefCell.\n\nI think that you are missing the point about the difference between UB and the Safety Proof. These are quite different things.\n\nUB is the set of things that rustc/LLVM is allowed to assume not to happen. Invoking UB, even in unsafe code, gives rustc/LLVM a Carte Blanche to rewrite your code - just the same as C.\n\nUnlike C, Rust (at least in theory) has a safety proof. The safety proof says that as long as all unsafe code in the program behaves according to some rules, then any additional safe code can't cause UB. It is _perfectly fine_ to have a program that plays loose with the safety proof - for example, if you wrap a buggy C library with a safe interface, then calling it with the appropriate arguments will cause it to execute some rather arbitrary code, which is obviously UB. However, if, _at run-time_, the library is not called with these malformed arguments, no UB is involved.\n\nThe rules the Safety Proof demands on unsafe code are purely behavioural, which means that unsafe code may rely on arbitrarily complex predicates in order to satisfy them (including the body of some \"trusted\" safe functions).\n\nThe rules of UB are basically \"syntax-directed\", but are evaluated at run-time. The question of whether a program execution-trace invokes UB should be easily decidable (and require no proof or \"ghost\" permissions not apparent in the code).\n\n> Also, regarding scanf, does this mean that if an LLVM program writes a pointer value to a file, then reads it back, and then uses the pointer it read (under the guarantee that it did not change), that this would not be a valid pointer to be used? Is that what nocapture makes happen?\n\nThat is basically correct, but I am quite sure that LLVM does not emit `nocapture` on the real `scanf` (basically for this reason).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/168541440/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/168542435",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-168542435",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 168542435,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2ODU0MjQzNQ==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-03T21:34:32Z",
    "updated_at": "2016-01-03T21:34:32Z",
    "body": "@RalfJung \n\n> Now the crucial question is, which lifetime does the borrow passed to f have.\n\nRust's lifetime inference always infers the minimum lifetime possible (of course, the semantics only \"run\" on fully elaborated code) so we should be fine. We agree on `f_mut_bad`.\n\nThe problem with `f_mut_should_work` etc. is that an active `&mut self` pointer can also be basically treated as freezing the pointee except for direct modifications (`f_mut_pedantic` ensures that the pointer is disposed of properly) - that should not be a problem in these cases because the pointers are not dereferenced while they are simultaneously active.\n\n`fn a` is unsafe under the \"parent-function-has-borrow\" rules (which we _do_ rely on) because it does not do anything about the parent's active borrow of the local `x` (if it was an `&mut`, it could be argued that the borrow's duration should be extended to not annoy `unsafe` code, but a `&`-borrow does not affect the immutable part of the parent's borrow).\n\nAbout `f_mut_pedantic`: we must have had different versions of the \"pointer permission bits\" model: I (and @mahkoh) was quite sure that taking a short borrow limits the permission bits to the duration of that borrow.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/168542435/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/168665494",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-168665494",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 168665494,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2ODY2NTQ5NA==",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-04T12:23:07Z",
    "updated_at": "2016-01-04T12:23:07Z",
    "body": "> I think that you are missing the point about the difference between UB and the Safety Proof. These are quite different things.\n> [snip]\n> The rules of UB are basically \"syntax-directed\", but are evaluated at run-time.\n\nI see. There is of course a relation between the two, since the safety proof has to show that there is no UB. But I was probably too focused on how to prove absence of UB - indeed for the \"no mutation through a shared reference\" part, even defining UB is an open problem. (The same goes for \"mutable references and pointers derived from them do not alias\", btw.)\n\nBtw, you mentioned the LLVM notion of a \"derived pointer\" above. I tried to find a definition of that for LLVM, but could not find anything like it. Does a pointer loaded from memory through another pointer count as \"derived\"? The LLVM docs http://llvm.org/docs/LangRef.html#noalias-and-alias-scope-metadata only explain `noalias` in relation to an `alias.scope`, as metadata on an expression. Rust uses `noalias` as annotation on the type, which I can't even find mentioned in the LLVM language reference.\n\n> The question of whether a program execution-trace invokes UB should be easily decidable (and require no proof or \"ghost\" permissions not apparent in the code).\n\nI don't think this can be done without adding any ghost state - though that ghost state would be somewhat different from the kind of permissions I mentioned earlier. For example, some the C rules concerning address arithmetic also apply in unsafe Rust; to explain them, our model of the memory cannot be just \"mapping numbers to bytes\". And I think the same goes for \"no mutation through a shared reference, except for `UnsafeCell`\" - there has to be some tracking somewhere whether a particular piece of memory is allowed to be mutated right now, so that we can assign UB if we do not want to allow mutation.\n\nThat's what I had in mind with my \"freezing\" proposal: Imagine every location in memory has an additional bit, \"frozen\", such that writing to a frozen location is UB. We could then imagine having explicit operations that freeze and unfreeze memory, which are called whenever a shared borrow starts or ends. When a function has arguments that are shared references, it would start by asserting that they are frozen - again invoking UB if they are not. This would then justify re-ordering reads from that location.\nUnfortunately, this would not be good enough to justify re-ordering reads around a function call - since the function we call could unfreeze memory, change it, and freeze it again. Some extra tracking could be added to compensate for this, like counting the total number of freezes of a location (sth. like a version number), and checking (within a function) that this does not change.\n\nI think ultimately we will need a model that actually uses some state in the memory to track things like this. The trouble with the aliasing-based models I saw so far is that they involve somehow looking at all the pointers that exist in all functions, and that are not borrowed away. (Notice that this, too, requires some \"operational effect\" associated with borrows starting and ending, visible on the machine that detects UB.) I don't like looking at other functions' state, or somehow having a global register of \"all pointers that exist\", and I think that would be rather hard to formally define. You mention \"access-based\" vs. \"instant-death based\" models above; I definitely think that access-based should be preferred. Having UB just from certain unused pointer values lying around is fairly surprising - and an access-based model lends itself much more natural to some extra tracking happening in the global memory, for every location, with checks being performed on every access. More checks could be easily added if we want certain guarantees even for unused pointers, like the \"assert this memory is frozen\" I suggested above.\n\n> The problem with f_mut_should_work etc. is that an active &mut self pointer can also be basically treated as freezing the pointee except for direct modifications (f_mut_pedantic ensures that the pointer is disposed of properly) - that should not be a problem in these cases because the pointers are not dereferenced while they are simultaneously active.\n\nYou mean, having a `&mut` guarantees that if we don't write through this pointer, then nobody can change that memory? Yes, that's also something that somehow needs to be encoded operationally. I don't have any bright ideas for this yet. But in all the examples you brought up, the `&mut self` is given up before `f` is called (`transmute` consumes its argument), so its not only that the pointer is not used, it _cannot_ be used.\nOr are you talking about the return value? In both cases, the lifetime used for `f` is unconstrained, so it could be said to end before the cast to `&mut` happens.\n\nMore in general though... maybe the \"freezing with a version number\" _can_ help. We could check, when a function starts, that `&mut` arguments are frozen, and record the version numbers. When we perform a mutation, we check the version number and unfreeze, mutate, and freeze again with the next version number. Before the function returns, we check the version number. This way, we could detect if anybody else modifies the memory.\nThinking about it, we wouldn't even need a \"freeze\" flag, just a write counter. We record the write counter at the beginning of every function, and check it at the end, to verify that no unexpected writes have happened. Does this make any sense?\n\nBtw, I noticed that Rust only emits `noalias` for function arguments, but not for borrows created locally. For example, in\n\n``` rust\nstatic zz: i32 = 13;\nfn foo(x: &i32, y: &i32) -> i32 { let z = &zz; *z + *x + *y }\n```\n\nI could not find any annotation for `z`. That's why I only talked about beginning and end of functions above, but of course, the same check should happen immediately after a local (re-borrow) and when that (re-)borrow ends.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/168665494/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/169138810",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-169138810",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 169138810,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2OTEzODgxMA==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-05T21:26:50Z",
    "updated_at": "2016-01-05T21:26:50Z",
    "body": "> I don't think this can be done without adding any ghost state - though that ghost state would be somewhat different from the kind of permissions I mentioned earlier.\n\nPermissions on pointers are not really going to work with FFI, so they are a non-starter. I suppose that the \"freezing\" of `&` can be treated as ghost states on memory, but I am used to think of it as universally-quantified relations on memory accesses (but that should be mostly equivalent).\n\n> But in all the examples you brought up, the `&mut self` is given up before `f` is called (`transmute` consumes its argument)\n\n`self` will reborrow itself rather than be consumed, so this won't work.\n\nAnyway, in my view, an active (I need to decide on terminology: live vs. active) `&mut` is also basically a freeze, except that\na) the memory can be accessed via the relevant active `&mut`, ignoring the freeze.\nb) the memory _can't_ be read from via any other pointer (of course, control flow effects, incl. unwinding, can unexpectedly terminate your borrow and expose that memory, but that is another issue).\nc) the memory is not frozen if the `&mut` is inactive (mutably borrowed or dropped). This is slightly complicated that it is in fact possible for an `&mut` borrow to be active _except for some subobjects_ (1). Note that an `&mut` can also be borrowed immutably and frozen.\n\nOne useful consequence of this, is that if some `&mut` is inactive, but you know an active `&mut` pointer to some subobject of it, you can be sure that the subobject is not poked with except through that pointer, even if the parent is inactive.\n\nMaybe this can be modeled as `&mut` references freezing the relevant memory using a capability, and being able to use that capability to safely access it.\n\n(1)\nFor example, you can have\n\n``` Rust\nfn traverse(l: &mut MyList)\n{\n    let mut cur = l;\n    loop {\n        if let &mut MyList::Cons(42, _) = cur {\n            break;\n        }\n        cur = match {cur} {\n            &mut MyList::Nil => return,\n            &mut MyList::Cons(_, ref mut l) => &mut *l\n        }\n    }\n    // here `l` is active, except for some unknown child of `cur`\n    if let &mut MyList::Cons(ref mut a, _) = cur {\n        *a += 1;\n    }\n}\n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/169138810/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/169460001",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-169460001",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 169460001,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2OTQ2MDAwMQ==",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-06T21:02:21Z",
    "updated_at": "2016-01-06T21:02:21Z",
    "body": "cc https://github.com/rust-lang/rfcs/issues/1447\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/169460001/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/170383654",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-170383654",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 170383654,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3MDM4MzY1NA==",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-10T19:26:26Z",
    "updated_at": "2016-01-10T19:26:34Z",
    "body": "> > But in all the examples you brought up, the &mut self is given up before f is called (transmute consumes its argument)\n> \n> self will reborrow itself rather than be consumed, so this won't work.\n\nFor what lifetime will it be considered reborrowed, when it is transmuted?\nI assume that casting to a `*mut` _does_ consume the reference. Usually reborrows occur because the compiler can reasonably infer a shorter and still non-surprising lifetime for a function argument, i.e. in\n\n``` rust\nfn bar(x: &mut i32) { ... }\nfn foo(x: &mut i32) { bar(x); bar(x); }\n```\n\nit infers the lifetime of the calls to `bar` for the argument type that's actually used when `bar` is called. If the same happens to `transmute`, the compiler could literally pick any shorter lifetime, so using `transmute` to turn a `&mut` into a `*mut` would actually be very different from using a cast.\n\n> // here `l` is active, except for some unknown child of `cur`\n\nWhy should `l` be active there? `l` has been moved out of in the first line, so it should be inactive. Only `cur` remains active.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/170383654/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/170509681",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-170509681",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 170509681,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3MDUwOTY4MQ==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-11T11:04:49Z",
    "updated_at": "2016-01-11T11:04:49Z",
    "body": "> Why should l be active there? l has been moved out of in the first line, so it should be inactive. Only cur remains active.\n\n`l` has been reborrowed, not moved (apparently, rustc even reborrows on raw pointer casts, which would make even my pedantic version not work). rustc reborrows at pretty much every opportunity - apparently even on raw pointer casts, breaking my pedantic example - unless you force it to move using a block `{cur}`.\n\nWe probably need some way to make rustc not reborrow like that.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/170509681/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/170670050",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-170670050",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 170670050,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3MDY3MDA1MA==",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-11T19:53:24Z",
    "updated_at": "2016-01-11T19:53:24Z",
    "body": "I think that whatever rules we settle on when it comes to `&` to `*` casting cannot, probably, be based on the lifetime of the `&` pointer being cast. This is partly because of reborrows but also because in general when we go from `&` to `*`, we lose track of the pointer, and hence can't really have a prayer of inference coming up with a long enough lifetime (in fact, it's often very handy that the lifetime is so short). It might be that they can be based on the \"upper bound\" of the lifetime of that `&` pointer though. \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/170670050/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/170704703",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-170704703",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 170704703,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3MDcwNDcwMw==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-11T22:00:07Z",
    "updated_at": "2016-01-11T22:00:07Z",
    "body": "@nikomatsakis \n\nThe problem is that one of the points of `&mut` is that you can, in fact, suspend your ownership of them only for a short period of time.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/170704703/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/171294294",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-171294294",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 171294294,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3MTI5NDI5NA==",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-13T13:43:59Z",
    "updated_at": "2016-01-13T13:43:59Z",
    "body": "> l has been reborrowed, not moved (apparently, rustc even reborrows on raw pointer casts, which would make even my pedantic version not work).\n\nBut `cur` is alive until after the line where you had your comment, so even if it has been reborrowed, it is dead until the reborrow ends. Which will be when the function ends.\n\n@nikomatsakis I am not entirely following you... but if I understand it correctly that the compiler assigns minimal lifetimes and always reborrows, then this should be sound (and rustc says it is... which leaves me slightly shocked^^):\n\n```\nfn foo(x: &mut T) {\n  let y = x as *mut _; // reborrows x for the shortest possible lifetime, which is this single statement\n  let z = x as *mut _; // does the same again\n}\n```\n\nIn other words, the compiler would actually not see any ownership transfer happening when casting to a raw pointer. This is somewhat consistent (after all, the compiler assigns no ownrship to mutable borrows), but I think it is also dangerous and usually not what people \"mean\". Above, you'd have to be _very_ careful what you do with `x`, even in safe code. If the cast would consume `x`, the compiler would tell you that you cannot use it any more. I think this is desirable. The old behavior can still be encoded, if people want it...\n\n```\nfn foo(x: &mut T) {\n  let y = { let x' = x; x' as *mut _ };\n  let z = { let x' = x; x' as *mut _ }\n}\n```\n\nNow the reborrow happens in the assignment to `x'`, so this is slightly more explicit.\n\nHowever, I think there's not just \"linting\" problems with the current behavior:\nRight now, you can write\n\n```\nfn foo(x: &mut i32) {\n  let y = x as *mut _;\n  unsafe { *y = 42; }\n}\n```\n\nand I assume this code is intended to have defined behavior. But a model that actually ensures that mutable borrows are the only way to write to the data they point to, would assign UB to the program above: At the beginning of the `unsafe` block, `x` is an active mutable borrow, and we do not use `x` for the rest of this function. Hence we can assert that whatever `x` points to does not change. But that's not the case...\n\nThis code is probably okay for LLVM because it will consider `y` to be derived from `x`. But it certainly violates the idea of in-scope active mutable pointers always being unique.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/171294294/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/171344268",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-171344268",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 171344268,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3MTM0NDI2OA==",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-13T16:07:24Z",
    "updated_at": "2016-01-13T16:07:24Z",
    "body": "@arielb1 @RalfJung \n\nMy point is that I believe it should, in some cases, be legal to transmute/cast an `&'a mut T` to a `*mut T` and then use the pointer for a span of time _longer than `'a`_. I don't mean arbitrarily long, either, but I think we need some rules that govern how far a `*mut` can escape and I don't think those rules can be strictly tied to the lifetime of the source pointer (though they are also not _independent_ from that lifetime). I think they should probably be tied to bigger, coarser scopes that are more easily defined.\n\nPut another way, I don't want the results of what is legal to have anything to do with what is inferred by the compiler within a fn definition. I want them to be based on the formal types of the arguments (which are explicitly written) and some kind of \"common sense\" reasoning. This may require the compiler to be more conservative than it would otherwise be in functions whose bodies contain coercions from `&mut` to `*mut` (hopefully, though, we can contain the effects of those coercions to the fn itself, so that callers don't have to care if their callees define coercions -- in fact, I think that this is the primary challenge of the memory model: determining when, exactly, callers should care about the callees do).\n\nFor example, in this snippet from @RalfJung:\n\n``` rust\nfn foo(x: &mut T) {\n  let y = x as *mut _; // reborrows x for the shortest possible lifetime, which is this single statement\n  let z = x as *mut _; // does the same again\n}\n```\n\nAnd another related example that @alexcrichton and I discussed a long time back:\n\n``` rust\nfn caller(x: &mut T) {\n    caller(x, y); // what lifetime is inferred for the (implicit) coercion? does it cover the call?\n}\nfn callee(x: *mut T, y: *mut T) {\n}\n```\n\nIn both these cases, as @RalfJung observed, the compiler will infer an awfully (and unrealistically) short borrow. But clearly the user expects to use the pointers `y` and `z` and I think we ought to make that OK.\n\nOne can imagine then a rule that says something like this: if the fn body contains a coercion or cast to `*mut` or an unsafe block, then the compiler must assume that all references are potentially aliased within the fns. This will impair its ability to optimize and reorder code. It does not mean the user is free to do whatever they want: memory still gets freed and so forth in the usual way. But it does mean that the user can use unsafe pointers to \"go beyond\" borrows, but those uses are on them in terms of avoiding UB.\n\nAnyway, I have to run, so I have no time to cleanup this text just now, and I know that is not a \"memory model\". It's also coming from a mildly different perspective (what the compiler will do), which in principle ought to be \"derived from\" the memory model. But of course in practice most memory models are aimed at formalizing what the compiler just does. Hopefully this comment nonetheless helps to elucidate my thinking a bit.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/171344268/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/171425068",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-171425068",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 171425068,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3MTQyNTA2OA==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-13T20:36:44Z",
    "updated_at": "2016-01-13T20:36:44Z",
    "body": "@nikomatsakis \n\nLuckily, the `&mut`-not-being-properly-disposed-of problem is function-local in its effect - you can always manually dispose of the reference, so we can fudge the rules in functions that contain unsafe code.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/171425068/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/171912054",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-171912054",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 171912054,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3MTkxMjA1NA==",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-15T09:29:40Z",
    "updated_at": "2016-01-15T17:00:45Z",
    "body": "I am slightly worried about the part where it seems like we have to detect whether a function perform a borrow-to-ptr-coercion, and then let the entire function behave differently. I think this should be more local to the pointer, like - the moment you coerce a mutable borrow to a raw pointer, until <not sure what to put here>, all aliasing for that particular pointer is fine.  But I do agree that this is probably the behavior most people would expect.\n\nSemantically speaking, I don't think \"until the end of the function\" would be a good boundary. I would prefer something that is more tied to, e.g., the scope of the variable that has been coerced. Incidentally, if the variable is consumed by the coercion, this would pretty much match the \"infer the maximal lifetime when coercing\".\n\nEDIT: Hm, but you were worried about inferred lifetimes having effect on the validity of code, which I agree Bad (TM). It's just, the function boundary is pretty arbitrary and entirely blurred away by inlining. Plus, there may be mutable borrows that I cast to a raw pointer that genuinely do not live until the end of the function. \"aliasing is now legal\" would have to be communicated to whoever obtains the borrow when its lifetime ends. As in\n\n``` rust\nfn foobar(x: &mut i32) {\n  let zz : *mut _;\n  { let y = x; // reborrow for the scope of y\n    let z = y as *mut _;\n    *z = 15;\n    zz = *z;\n   }\n   // How is the compiler supposed to know that `x` can now alias? Or is thus UB?\n   *x = 14;\n   *zz = 13;\n   *x\n}\n```\n\n(**Update**: fixed typo)\nOf course, the data flow from `x` to `y` could be arbitrarily complicated and involve code in other crates.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/171912054/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/171940931",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-171940931",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 171940931,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3MTk0MDkzMQ==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-15T11:42:46Z",
    "updated_at": "2016-01-15T11:45:05Z",
    "body": "@ralfjung\n\nOf course, only the mutable reference immediately being cast would stay \"semi-active\" - if it was a reborrow of some other thing, its parent would return to being active as soon as the reborrow will go out. This also preserves meaning in the presence of inlining.\n\nThough the SEME rules would make it hard to reborrow anything that is not just a parameter. Maybe just take a function being unsafe to fudge the activity of mutable pointers in it, and preserve that kind of fudging during inlining.\n\nI am not sure what is `zz` in your code above ^ and you seem to have an extra deref (also: unsafe block) but as extract-functioning the block would be obvious UB, this code would also be UB under the first rules and valid if we fudge things.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/171940931/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/172017629",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-172017629",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 172017629,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3MjAxNzYyOQ==",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-15T17:07:07Z",
    "updated_at": "2016-01-15T17:07:07Z",
    "body": "Sorry, I had a typo around the `zz`, I fixed that.\n\n> Of course, only the mutable reference immediately being cast would stay \"semi-active\" - if it was a reborrow of some other thing, its parent would return to being active as soon as the reborrow will go out. This also preserves meaning in the presence of inlining.\n\nIn other words, the cast would completely consume its origin and be a valid pointer - with arbitrary aliasing - for the lifetime of the origin?\n\n> Though the SEME rules would make it hard to reborrow anything that is not just a parameter. Maybe just take a function being unsafe to fudge the activity of mutable pointers in it, and preserve that kind of fudging during inlining.\n\nHu? SEME?\nAgain, I think doing this based on whether the containing function is unsafe or not (what does that even mean?) is a semantic dead-end. Explaining what is and what is not allowed after inlining is about as hard as just doing it in a modular, local way from the start.\n\n> also: unsafe block\n\nSorry for that^^. I think about this stuff in terms of entirely untyped code that doesn't even want to type-check (because we will eventually prove that it behaves semantically well-typed), and then translate it back to Rust, and sometimes I forget that in Rust I have to explicitly mark some pieces of this ;-)\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/172017629/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/172088475",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-172088475",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 172088475,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3MjA4ODQ3NQ==",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-15T20:47:11Z",
    "updated_at": "2016-01-15T20:47:11Z",
    "body": "On Fri, Jan 15, 2016 at 01:30:15AM -0800, Ralf Jung wrote:\n\n> I am slightly worried about the part where it seems like we have to detect whether a function perform a borrow-to-ptr-coercion, and then let the entire function behave differently. I think this should be more local to the pointer, like - the moment you coerce a mutable borrow to a raw pointer, until <not sure what to put here>, all aliasing for that particular pointer is fine.  But I do agree that this is probably the behavior most people would expect.\n\nI am open to more restrictive definitions, but I definitely want to find something that is relatively easy for people to grok. I also want to avoid TBAA and other sensitive definitions. I think people should be able to cast freely around between types. \n\n> Semantically speaking, I don't think \"until the end of the function\" would be a good boundary. I would prefer something that is more tied to, e.g., the scope of the variable that has been coerced. Incidentally, if the variable is consumed by the coercion, this would pretty much match the \"infer the maximal lifetime when coercing\".\n\nSeems plausible. The bottom line for me is that it should be some clear, syntactic boundary -- not the results of lifetime inference!\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/172088475/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/172102224",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-172102224",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 172102224,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3MjEwMjIyNA==",
    "user": {
      "login": "arielb1",
      "id": 1830974,
      "node_id": "MDQ6VXNlcjE4MzA5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arielb1",
      "html_url": "https://github.com/arielb1",
      "followers_url": "https://api.github.com/users/arielb1/followers",
      "following_url": "https://api.github.com/users/arielb1/following{/other_user}",
      "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions",
      "organizations_url": "https://api.github.com/users/arielb1/orgs",
      "repos_url": "https://api.github.com/users/arielb1/repos",
      "events_url": "https://api.github.com/users/arielb1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arielb1/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-01-15T21:40:41Z",
    "updated_at": "2016-01-15T21:40:41Z",
    "body": "> SEME\n\nCurrently, region inference is can only pick out fairly coarse-grained regions. SEME is an RFC for more finely-grained regions which will make the destroying a mutable pointer more annoying.\n\n> In other words, the cast would completely consume its origin and be a valid pointer - with arbitrary aliasing - for the lifetime of the origin?\n\nThat sounds like a good solution. It will be a little problematic when `as_mut_ptr` is used instead of arbitrary casts - maybe just ban these kinds of methods, or have some kind of attribute annotation + lint.\n\n> Explaining what is and what is not allowed after inlining is about as hard as just doing it in a modular, local way from the start.\n\nNot really. The \"dead areas\" of mutable pointers are inferred _once_, _before_ inlining, and then preserved during inlining. This is no more difficult than preserving type inference.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/172102224/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/473540514",
    "html_url": "https://github.com/rust-lang/rust/issues/30424#issuecomment-473540514",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30424",
    "id": 473540514,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MzU0MDUxNA==",
    "user": {
      "login": "steveklabnik",
      "id": 27786,
      "node_id": "MDQ6VXNlcjI3Nzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/steveklabnik",
      "html_url": "https://github.com/steveklabnik",
      "followers_url": "https://api.github.com/users/steveklabnik/followers",
      "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}",
      "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions",
      "organizations_url": "https://api.github.com/users/steveklabnik/orgs",
      "repos_url": "https://api.github.com/users/steveklabnik/repos",
      "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/steveklabnik/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2019-03-16T15:08:48Z",
    "updated_at": "2019-03-16T15:08:48Z",
    "body": "Interestingly enough, if we run this code in MIRI: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=0d8479bc8e9eeb656f08f3b763e80989\r\n\r\n```text\r\nerror[E0080]: constant evaluation error: borrow being accessed (Alias(None)) does not exist on the borrow stack\r\n --> src/main.rs:8:5\r\n  |\r\n8 |     *x = 22;\r\n  |     ^^^^^^^ borrow being accessed (Alias(None)) does not exist on the borrow stack\r\n  |\r\nnote: inside call to `b` at src/main.rs:3:5\r\n --> src/main.rs:3:5\r\n  |\r\n3 |     b(&x as *const u8 as *mut u8);\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nnote: inside call to `a` at src/main.rs:13:21\r\n --> src/main.rs:13:21\r\n  |\r\n13|         let mut a = a();\r\n  |                     ^^^\r\n  = note: inside call to `main` at /root/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/rt.rs:64:34\r\n  = note: inside call to closure at /root/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/rt.rs:52:53\r\n  = note: inside call to closure at /root/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/panicking.rs:293:40\r\n  = note: inside call to `std::panicking::try::do_call::<[closure@DefId(1/1:1780 ~ std[82ff]::rt[0]::lang_start_internal[0]::{{closure}}[0]) 0:&dyn std::ops::Fn() -> i32 + std::marker::Sync + std::panic::RefUnwindSafe], i32>` at /root/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/panicking.rs:289:5\r\n  = note: inside call to `std::panicking::try::<i32, [closure@DefId(1/1:1780 ~ std[82ff]::rt[0]::lang_start_internal[0]::{{closure}}[0]) 0:&dyn std::ops::Fn() -> i32 + std::marker::Sync + std::panic::RefUnwindSafe]>` at /root/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/panic.rs:388:9\r\n  = note: inside call to `std::panic::catch_unwind::<[closure@DefId(1/1:1780 ~ std[82ff]::rt[0]::lang_start_internal[0]::{{closure}}[0]) 0:&dyn std::ops::Fn() -> i32 + std::marker::Sync + std::panic::RefUnwindSafe], i32>` at /root/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/rt.rs:52:25\r\n  = note: inside call to `std::rt::lang_start_internal` at /root/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/rt.rs:64:5\r\n  = note: inside call to `std::rt::lang_start::<()>`\r\n```\r\n\r\nSo, there's *one* answer at least. I'm not going to close this issue just yet, in case someone finds this discussion useful, but I imagine this thread is obsoleted by the unsafe code guidelines, or at least this question should be raised over there.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/473540514/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
