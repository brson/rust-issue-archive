[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31808909",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31808909",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31808909,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxODA4OTA5",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-08T06:30:58Z",
    "updated_at": "2014-01-08T06:30:58Z",
    "body": "cc @pnkfelix, @pcwalton, @nikomatsakis (anyone else)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31808909/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31828208",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31828208",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31828208,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxODI4MjA4",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-08T12:47:52Z",
    "updated_at": "2014-01-08T12:47:52Z",
    "body": "I've filled in more details.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31828208/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31843611",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31843611",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31843611,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxODQzNjEx",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-08T15:24:47Z",
    "updated_at": "2014-01-08T15:29:44Z",
    "body": "How about special-casing RefCell and using the RefCell borrow flags to implement write barriers? (that is, add a new GcWriteBarrier state that causes borrow to append the RefCell address to a task-local modification log)\n\nThis way, they should work automagically with no API change, and allow safe code to borrow with no write barriers (since it's done at the proper place, i.e. the RefCell that can potentially give &muts and not the Gc<T> which doesn't).\n\n[Cell can only contain POD types, so the GC can ignore them]\n\nOf course, the GC needs to be made fully accurate and aware of types beforehand, but that's essential anyway.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31843611/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31844412",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31844412",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31844412,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxODQ0NDEy",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-08T15:32:37Z",
    "updated_at": "2014-01-08T15:32:37Z",
    "body": "That may work, but it requires chaining RefCell and Gc together, while the former is definitely useful outside of Gc... would it make RefCell slower in the non-Gc case?\n\nAlso, RefCell isn't the necessarily only type with interior mutability; people can define their own outside of libstd. In any case, Gc as implemented here _does_ satisfy Pod, we may wish to not have this but satisfying Pod is certainly convenient.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31844412/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31851146",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31851146",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31851146,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxODUxMTQ2",
    "user": {
      "login": "pcwalton",
      "id": 157897,
      "node_id": "MDQ6VXNlcjE1Nzg5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pcwalton",
      "html_url": "https://github.com/pcwalton",
      "followers_url": "https://api.github.com/users/pcwalton/followers",
      "following_url": "https://api.github.com/users/pcwalton/following{/other_user}",
      "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions",
      "organizations_url": "https://api.github.com/users/pcwalton/orgs",
      "repos_url": "https://api.github.com/users/pcwalton/repos",
      "events_url": "https://api.github.com/users/pcwalton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pcwalton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-08T16:36:54Z",
    "updated_at": "2014-01-08T16:36:54Z",
    "body": "Excellent work!\n\nFor the trie, here's the gold standard: http://www.hpl.hp.com/personal/Hans_Boehm/gc/tree.html\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31851146/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31852175",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31852175",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31852175,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxODUyMTc1",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-08T16:45:44Z",
    "updated_at": "2014-01-08T16:45:44Z",
    "body": "Cool!\n\nThis seems like a good place to float an idea I've been thinking about: what about doing tracing with a trait?\n\nI've never written a GC before, only read a few papers. Most GCs seem to do tracing entirely based on dynamic information: a header attached to each heap object, and/or runtime calls to register/deregister traceable areas of memory (as here). Instead of that, what if we had a trait like:\n\n```\ntrait Trace {\n    fn trace(&self, ...);\n}\n```\n\nThe `impl` for most types would call `trace()` on each of its constituents in turn (same method, different impl). If there are none, it would do nothing. For `Gc<T>` itself, it would mark it as alive, before continuing to `trace()` the interior. When types are known statically, all of this would be normal function calls which could be inlined and optimized down to efficient code. Where there's an unknown type (a trait object or closure), it would store a `Trace` vtable (this being the \"header\") and make the call dynamically (after which it would be back to static calls).\n\nIf necessary, `trace()` could be passed some parameters or a closure by the GC, which it could be expected to react to resp. call back.\n\nFor the built-in types except `*T` a `Trace` impl would pre-exist. For most user-defined types, it could be derived either manually (`deriving(Trace)`) or automatically (like `Drop` is), unless the type contains another type which doesn't implement `Trace`. In this case `Trace` could be defined manually. For example, types which contain pointers into foreign data structures could use `Trace` to define how to trace through those data structures for pointers back into Rust, which is kinda cool.\n\nAn invariant that would have to be maintained in the type system is that data which transitively contains `Gc<T>` could not be stored inside any type which doesn't implement `Trace`. (I was thinking the \"does _type_ contain GC data\" part could be done with something like #10879.) Here an interesting question is whether closures and trait objects would default to implying a `Trace` bound (like with `Drop`), or if it would have to specified manually. (This would determine whether or not they can close over managed data.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31852175/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31855384",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31855384",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31855384,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxODU1Mzg0",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-08T17:14:26Z",
    "updated_at": "2014-01-08T17:14:26Z",
    "body": "That would certainly be precise.\n\nHowever, it's not immediately clear to me how it interacts with Rust's stack, since AIUI, being precise on the stack (to work out which `.trace()` to call on what piece of memory) is hard work; does LLVM have support that can assist us?\n\n(Also, would that preclude performance optimisations, so that in applications just using the GC in only one task get slowed globally (which this GC doesn't do) because LLVM can't reorder/SROA things on the stack?)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31855384/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31855907",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31855907",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31855907,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxODU1OTA3",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-08T17:19:14Z",
    "updated_at": "2014-01-08T17:21:32Z",
    "body": "> That may work, but it requires chaining RefCell and Gc together, while the former is definitely useful outside of Gc...\n\nNot exactly, although the behavior would obviously be triggered only for RefCells that the garbage collector sees\n\n> would it make RefCell slower in the non-Gc case?\n\nNo, because it already needs to check the flags to make sure it's not already borrowed, so the check for a write barrier and for the value already being borrowed can be done together at no extra performance cost.\n\n> Also, RefCell isn't the necessarily only type with interior mutability; people can define their own outside of libstd.\n\nThis would have to banned by adding a FreezeExceptNonFreezeTypesWhichSupportWriteBarriersOrCannotHoldGc kind bound to Gc<T> or something like that.\n\nIs there any real use case for this?\n\n> In any case, Gc as implemented here does satisfy Pod, we may wish to not have this but satisfying Pod is\n> certainly convenient.\n\nIt would either need to stop being Pod, or Cell needs to also have a NonManaged bound.\n\nOverall, the issue is that write barrier functionality must be where you can get &muts, since otherwise you cannot safely request to borrow without write barriers (and in fact your code makes such functionality unsafe), which seems unacceptable.\n\nSo the other alternative is to add a Freeze bound to Gc and add a GcMut, but that's less flexible, and it appears the plan is to move away from that model towards using Cell and RefCell inside \"immutable\" types.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31855907/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31869769",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31869769",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31869769,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxODY5NzY5",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-08T19:38:31Z",
    "updated_at": "2014-01-08T21:09:32Z",
    "body": "> However, it's not immediately clear to me how it interacts with Rust's stack, since AIUI, being precise on the stack (to work out which .trace() to call on what piece of memory) is hard work; does LLVM have support that can assist us?\n\nThis occurred to me as well. I plead total ignorance. How was the planned \"conservative on the stack, precise on the heap\" GC going to do this? With headers on all heap objects?\n\n> (Also, would that preclude performance optimisations, so that in applications just using the GC in only one task get slowed globally (which this GC doesn't do) because LLVM can't reorder/SROA things on the stack?)\n\nCan SROA take something off the stack entirely and put it in a register? Would this GC handle that?\n\nEDIT: Would it be unreasonable to have the compiler explicitly generate code to call `register_root(&stack_val as &Trace)` for each stack variable that can contain managed data (and presumably unregister as well at end of scope)? Maybe not the most performant thing in the world, but seems like it could work, be precise, and not have a negative effect on code that's not using GC.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31869769/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31878145",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31878145",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31878145,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxODc4MTQ1",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-08T21:09:47Z",
    "updated_at": "2014-01-08T21:09:47Z",
    "body": "On Wed, Jan 8, 2014 at 2:38 PM, G\u00e1bor Lehel notifications@github.com wrote:\n\n> Can SROA take something off the stack entirely and put it in a register?\n\nSure, the `mem2reg` pass does exactly that. SROA is an amalgamation of\nmany more things than just replacing aggregates with scalars and\nlikely does it too. It's free to destroy any debug information when\noptimizations are enabled. GCC abandoned any hope of preserving this\ninformation at `-O1` and switched to exposing an `-Og` flag instead\nalong with `-fvar-tracking-assignments`. LLVM isn't there yet, and\ndoesn't have a solution for debugging in the presence of optimizations.\n\nLLVM is even free to remove calls to `malloc`, `realloc` and `free`\nand replace them with memory on the stack or in registers. It\ncurrently only does this for dead stores, but the intent of the C\nstandard is to permit escape analysis and it should land soon.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31878145/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31893928",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31893928",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31893928,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxODkzOTI4",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T01:12:30Z",
    "updated_at": "2014-01-09T01:12:30Z",
    "body": "> This occurred to me as well. I plead total ignorance. How was the planned \"conservative on the stack, precise on the heap\" GC going to do this? With headers on all heap objects?\n\nMy current plan was storing the information in the table in the GC. (I.e. expand the `scan` field, which is a crude form of \"precision\".)\n\n> This would have to banned by adding a FreezeExceptNonFreezeTypesWhichSupportWriteBarriersOrCannotHoldGc kind bound to Gc or something like that.\n\nIs this a serious suggestion?\n\nIn any case, I'm not too concerned by the (as yet hypothetical) write barriers for now:\n- Many types are `Freeze`, and so no write barriers at all\n- The intrinsic will allow eliding the write barriers in many instances\n- `Gc` is marked `#[experimental]`, so people will get compiler warnings when they use it, hence making changes like that (if necessary) is possible\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31893928/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31899882",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31899882",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31899882,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxODk5ODgy",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T03:26:33Z",
    "updated_at": "2014-01-09T03:27:54Z",
    "body": "@glaebhoerl I've been thinking about precision/tracing, and I get the feeling that your suggestion does actually work (I'd been thinking kinda-similar thoughts, but it was late and I got distracted by your mention of stack precision):\n\n``` rust\ntrait Trace {\n    fn trace(&self, gc_info: &mut GcInfo);\n}\nimpl<T: Trace> Trace for Gc<T> {\n    fn trace(&self, gc_info: &mut GcInfo) {\n         if gc_info.mark_reachable(self) { // returns true if already traced\n             x.borrow().trace(gc_info);\n         }\n    }\n}\n\nimpl<T: Trace> Trace for RefCell<T> {\n    fn trace(&self, gc_info: &mut GcInfo) {\n        self.value.trace(gc_info);\n    }\n}\n\nimpl Trace for int { fn trace(&self, _: &mut GcInfo) {} }\nimpl<T> Trace for *T { fn trace(&self, _: &mut GcInfo) {} }\n// and similarly for the other basic types (I don't think we can/should\n// impose any particular tracing semantics on `*`?)\n\n// these are registered as roots for (precise) scanning separately, or have\n// been registered to be included in any conservative scans (and have \n// proper impls here). (The latter is probably better; see below.)\nimpl<T> Trace for Uniq<T> { fn trace(&self, _: &mut GcInfo) {} }\nimpl<T> Trace for Vec<T> { fn trace(&self, _: &mut GcInfo) {} }\nimpl<T> Trace for Rc<T> { fn trace(&self, _: &mut GcInfo) {} }\n\n// etc.\n```\n\nThen we could have a deriving mode that takes\n\n``` rust\n#[deriving(Trace)]\nenum Foo {\n    X(Gc<int>, Vec<Gc<int>>)\n    Y(int, int)\n    Z(int, Gc<Vec<int>>)\n}\n```\n\nand generates (after inlining & removing the no-op methods)\n\n``` rust\nimpl<T: Trace> Trace for Gc<T> {\n    fn trace(&self, gc_info: &mut GcInfo) {\n        match *self {\n            X(a, _) => { a.trace(gc_info) }\n            Y(_, _) => {}\n            Z(_, b) => { b.trace(gc_info) }\n        }\n    }\n}\n```\n\nAnd then `<T> Gc<T>` becomes `<T: Trace> Gc<T>`, and we keep a way to call the relevant `trace` of each known pointer. Unfortunately, this means that trait objects don't work very well in `Gc`: every trait used would need to inherit from `Trace`. And it also means that any generic data-structures that wish to be precisely traced need a `Trace` bound, which is rather unfortunate. :( \n\nWe could make `Trace` _super_ special and automatically derived for all types, unless there is a manual implementation; or have an intrinsic like `get_tracing_function<T>() -> Option<fn(...)>`, which will give `None`/`Some` based on whether there is such an method, so we can default to a conservative scan if necessary (this last one seems more feasible than the first). [Possibly with a lint for using non-traceable types in the GC.]\n\nRe `Uniq`, and `Vec` and so on: having them registered to be traced by a conservative scan seems like a very good idea, however, the current scanner only recognises pointers that point exactly at the start of it's registered allocations, not interior pointers; in practice this probably isn't too much of a limitation, since it would be very weird for something to lose its pointer to the start of an allocation.\n\nAlso `Trace` seems rather similar to `Encodable`, but `Encodable` is in `extra` and we are not; and `Encodable` is a bit of weird bound to have. (And would be very weird to add as special to the compiler for the intrinsic mentioned above.)\n\nIn any case, this seems significantly more feasible than I first thought; I'll experiment.\n\n(Also, I'm not sure how this API would work if we were to try to support other tracers, rather than just the one in libstd, I guess `GcInfo` could be a trait...)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31899882/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31920103",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31920103",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31920103,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTIwMTAz",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T10:55:14Z",
    "updated_at": "2014-01-09T11:16:37Z",
    "body": "> `impl<T> Trace for *T { fn trace(&self, _: &mut GcInfo) {} }`\n\nI was thinking `*T` would deliberately not have an impl, to force types which contain it, which are probably up to some funny business, to write their own, and not derive. In any case, having an impl that does nothing seems like the wrong idea, making it easy to automatically derive an impl that doesn't trace things which should be traced.\n\nWhy can't you `impl<T: Trace> Trace for` `Uniq<T>`/`Vec<T>`/`Rc<T>` normally to trace the contained values?\n\n> Unfortunately, this means that trait objects don't work very well in Gc: every trait used would need to inherit from Trace. \n\nAh right. In my head I was using my earlier-proposed idea to have `Trait1+Trait2` be itself a trait, so you could do e.g. `~(ToStr+Trace)`...\n\n> And it also means that any generic data-structures that wish to be precisely traced need a Trace bound, which is rather unfortunate. :( \n\nWhat do you mean here exactly? This seems logical to me (e.g. `impl<T: Trace> Trace for List<T>`), or were you thinking of something different?\n\n> We could make Trace super special and automatically derived for all types, unless there is a manual implementation\n\nIf we do this I think an `impl Trace` should be automatically derived for a type _iff_ all of its members also impl `Trace` (if it has type parameters, then with a `T: Trace` bound on them). I'm not sure if there's a use case for overriding this manually with your own impl? If the type contains non-`Trace`able members (such as `*T`), then you would be forced to write your own. You could also turn the auto-deriving off with an attribute (either per-type or crate-wide).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31920103/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31945182",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31945182",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31945182,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTQ1MTgy",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T15:52:26Z",
    "updated_at": "2014-01-09T15:52:26Z",
    "body": "> Why can't you impl<T: Trace> Trace for Uniq<T>/Vec<T>/Rc<T> normally to trace the contained values?\n\nIt would be possible (see the \"Re Uniq, and Vec and so on\" paragraph my previous comment). In fact, just thinking about it now, it is necessary. My current implementation is actually incorrect for something like\n\n``` rust\nstruct X {\n    x: Gc<Uniq<RefCell<X>>>\n}\n```\n\nThe `Uniq` is always regarded as reachable, even for an otherwise-unreachable `X` value that is pointing at itself, and so that value would then be stuck in a reference cycle and leak.\n\n> What do you mean here exactly? This seems logical to me (e.g. impl<T: Trace> Trace for List<T>), or were you thinking of something different?\n\nSomething different. Smart pointers and generic data stuctures that can contain GC'd values will need to be able to register themselves with the garbage collector, passing in their tracing info (e.g. a function pointer to something wrapping the `.trace` method) so that the GC can run it when it sees a relevant pointer when doing its conservative scan. Something like:\n\n``` rust\nfn run_tracing<T: Trace>(x: *(), gc_info: &mut GcInfo) {\n     unsafe { (*(x as *T)).trace(gc_info) }\n}\n\nimpl<T> Uniq<T> {\n     fn new(x: T) -> Uniq<T> {\n          // pseudo-Rust\n          let ptr = malloc(size);\n          *ptr = x;\n\n           // get the appropriately monomorphised version of `run_tracing`\n          register_with_gc(ptr, run_tracing::<T>);\n\n          Uniq { ptr: ptr }\n     }\n}\n```\n\nThe problem is the `run_tracing::<T>` line: it requires a `Trace` bound, and so we'd need `impl<T: Trace> Uniq<T>`... and then anything using `Uniq` would need one too, etc etc.\n\nMy goal above was to be fancier/work-around the type system: e.g. a pointer to a function equivalent to `run_tracing` in the tydesc, possibly two lang items like\n\n``` rust\n#[lang=\"trace_traceable\"]\nfn trace_traceable<T: Trace>(start: *(), end: *(), gc_info: &mut GcInfo) {\n    unsafe { (*(start as *T)).trace(gc_info) }\n}\n\n#[lang=\"trace_nontraceable\"]\nfn trace_nontraceable<T>(start: *(), end: *(), gc_info: &mut GcInfo) {\n    gc_info.conservative_scan(start, end)\n}\n```\n\nwhere the compiler uses the first where possible (i.e. in the tydescs of types with Trace impls) and the second to make up the slack (i.e. in the tydescs of types without Trace impls). In any case, this tracing stuff seems pretty similar to `Drop` and the drop glue.\n\n---\n\nAnother problem I just thought of (which is completely obvious in hindsight): when we are scanning the stack conservatively and see a pointer to a `Vec<T>` registered with the GC, we don't know how many elements are in the vector and so don't know how to scan precisely. Possible solutions:\n1. scan the memory conservatively (optimisation: wait until we have nothing else to scan before doing any of the vectors found via this, on the off chance that there is another reference somewhere that does have access to true tracing info)\n2. store the length in the allocation; either for all types (loses some of the advantages of the nice `{length, capacity, data*}` vector representation) or just for managed types (one of the problems with the current `@` is it forces a change of representation like this)\n3. store the length in a table in the GC (makes every `.push` and `.pop` really expensive)\n\nI'm leaning toward 1 as the solution that has the least impact: it only affects vectors of managed things stored directly on the stack (or in other such vectors), as soon as you're behind, e.g, a smart pointer, you can trace precisely (so `Rc<~[Foo]>` would be precise).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31945182/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31968763",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31968763",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31968763,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTY4NzYz",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T19:47:53Z",
    "updated_at": "2014-01-09T20:17:11Z",
    "body": "Ultimately, the only solution is to have a fully precise GC, including the stack.\n\nThere seems to be already support for that in LLVM through the shadow stack plugin (albeit with some performance degradation due to explicit bookkepping and need to keep roots on the stack and not in registers), and there is work on something that can work with no performance degradation at https://groups.google.com/forum/#!topic/llvm-dev/5yHl6JMFWqs\n\nAnd in fact the latter appears to be already experimentally available in LLVM 3.4 according to http://www.llvm.org/docs/StackMaps.html#stackmap-section\n\nAnyway, as long as trait objects without Send or NonManaged bounds are not used, the Rust compiler has perfect knowledge of whether any value holds Gc or not, so since trait objects are supposed to be rare (especially those without such bounds), even a precise GC with suboptimal performance should not really impact non-GC code much.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31968763/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31984453",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31984453",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31984453,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTg0NDUz",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T22:34:40Z",
    "updated_at": "2014-01-09T22:37:36Z",
    "body": "> Ultimately, the only solution is to have a fully precise GC, including the stack.\n\nthe llvm-dev thread rooted here may also be relevant/of interest: http://lists.cs.uiuc.edu/pipermail/llvmdev/2013-October/066782.html\n\nNote in particular the discussion of Bartlett mostly-copying gc\n- here: http://lists.cs.uiuc.edu/pipermail/llvmdev/2013-October/066890.html\n- and counterpoints here: http://lists.cs.uiuc.edu/pipermail/llvmdev/2013-October/066906.html\n\n(Update: ah, indeed, the google groups link that bill-myers provided is to a propsal that came after (and in response to) the thread I linked above.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31984453/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31985112",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31985112",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31985112,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTg1MTEy",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T22:43:17Z",
    "updated_at": "2014-01-09T22:43:57Z",
    "body": "> How was the planned \"conservative on the stack, precise on the heap\" GC going to do this? With headers on all heap objects?\n\nEssentially, yes, that was my plan (that, in addition to some way to map from interior pointers to the start of an object).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31985112/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31985247",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31985247",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31985247,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTg1MjQ3",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T22:44:43Z",
    "updated_at": "2014-01-09T22:44:43Z",
    "body": "@pnkfelix: What about heap objects without managed values? Does rooting borrowed pointers require adding overhead to all heap allocations?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31985247/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31986939",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31986939",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31986939,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTg2OTM5",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T23:05:40Z",
    "updated_at": "2014-01-09T23:05:40Z",
    "body": "@thestinger my plan was that ~-allocated objects that could contain references to managed-refs or borrowed-refs would need a header.\n\n(I'll need to double check about ~-allocated objects whose references are solely to other ~-allocated objects.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31986939/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31987415",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31987415",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31987415,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTg3NDE1",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T23:12:00Z",
    "updated_at": "2014-01-09T23:12:34Z",
    "body": "@pnkfelix: So won't this require an extra branch in _every_ unique trait object that's not `'static` and `Send`?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31987415/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31988187",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31988187",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31988187,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTg4MTg3",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T23:22:39Z",
    "updated_at": "2014-01-09T23:22:39Z",
    "body": "> So won't this require an extra branch in every unique trait object that's not 'static'?\n\nI don't understand your question.  There will be extra branches in some places, but I don't see what trait objects would have to do with it ... I was planning on storing all such header information at a negative offset from the referenced address, so that the object layout would look the same from the view point of client code accessing the state of a ~-allocated object.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31988187/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31988501",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31988501",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31988501,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTg4NTAx",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T23:26:56Z",
    "updated_at": "2014-01-09T23:26:56Z",
    "body": "(or maybe @thestinger is talking about the trait objects that store a `Trace` vtable ... in which case that's not what I have been actively thinking about; I haven't even really read the discussion here on that topic carefully yet.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31988501/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31988977",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31988977",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31988977,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTg4OTc3",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T23:34:06Z",
    "updated_at": "2014-01-09T23:34:06Z",
    "body": "> my plan was that ~-allocated objects that could contain references to managed-refs or borrowed-refs would need a header.\n\nDo borrowed refs need a header? Doesn't the borrow freeze the original value in-place and hence the GC will trace it through that value?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31988977/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31989844",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31989844",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31989844,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTg5ODQ0",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T23:47:42Z",
    "updated_at": "2014-01-09T23:47:42Z",
    "body": "> Do borrowed refs need a header?\n\nThe references themselves should not need any header.  I think the sentence I wrote was unclear.\n\nThe point I was trying to make was just that: Under the scheme I was envisaging (a variant of Bartlett), an ~-allocated objects of type ~T would need a header, unless rustc can statically prove that any instance of ~T would not need to be traced for the GC.\n\nWhat sort of header would the ~T need?  At minimum, just the extent of the object (and you would conservatively scan the ~T in the same way that you would the stack).  Of course, we can provide a more precise header (and may want to do so).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31989844/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31990749",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-31990749",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 31990749,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTkwNzQ5",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-10T00:01:54Z",
    "updated_at": "2014-01-10T00:01:54Z",
    "body": "(a clarification: by \"need a header\", I am really thinking \"will need meta-data somewhere tracking extent, and/or type, etc\"; a side-table might be a better choice, or even an outright necessity, for some cases.  Either way, whether its a side-table or a header at a negative-offset, this is all stuff just for the Gc, not for the object to use.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31990749/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32114481",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-32114481",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 32114481,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTE0NDgx",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-12T03:45:46Z",
    "updated_at": "2014-01-12T03:45:46Z",
    "body": "I've pushed two commits that turn this into a tracing garbage collector. (Conservative on the stack, precise on the heap.) Unfortunately, it has some drawbacks, like forcing `Uniq<T>` and `Vec<T>` to have `T: Trace`. Quoting from the adjusted PR text:\n\n> Unfortunately to support tracing, these types (Uniq and Vec) require a Trace bound on their contents, which is unfortunate, as they should be allowed to store non-tracable types if those types don't contain any Gc<T> pointers.\n> \n> # Problems\n> \n> [...]\n> - The tracing API means Uniq and Vec are less flexible that desirable (which flows downstream to any generic users of them) because they require a Trace bound to be able to register a handle to run when discovered by a conservative scan. Possible solutions:\n>   -   having separate non-trace constructors (and non-trace .push and .pop for Vec!) but this would then require similar contortions downstream;\n>   -   some sort of explicit TraceOrNonManaged bound (which would also require downstream generic to have that bound)\n>   -   have the compiler enforce that Gc can only go into Trace types (a little like transmute requires types of the same size)\n>   -   have the compiler generate trace glue like drop glue, etc., and then retrieve this for tracing (would require a call_trace_glue intrinisic, but then we'd have to have some way to get the appropriate types and information into it).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32114481/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32120203",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-32120203",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 32120203,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTIwMjAz",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-12T11:17:36Z",
    "updated_at": "2014-01-12T11:17:36Z",
    "body": "On Wed, Jan 08, 2014 at 07:32:41AM -0800, Huon Wilson wrote:\n\n> That may work, but it requires chaining RefCell and Gc together,\n> while the former is definitely useful outside of Gc... would it make\n> RefCell slower in the non-Gc case?\n\nWhen we last discussed this, we _did_ plan to have `Cell` and\n`RefCell` do a quick check to implement write barriers. This is one of\nthose examples which demonstrate why GC is best thought of as more of\na \"privileged library\" than \"just another library\". (However, I\nhaven't finished reading all the comments on this thread, and I'd be\nhappy if we are able to avoid the need to modify Cell/RefCell --\nperhaps by just not needing write barriers altogether, though that\nimplies a less sophisicated GC algorithm in turn.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32120203/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32121602",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-32121602",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 32121602,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTIxNjAy",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-12T12:41:53Z",
    "updated_at": "2014-01-12T12:44:09Z",
    "body": "@huonw I've been thinking about this paradox:\n1. Any type that is known not to contain managed data can have a trivial `Trace` impl, with `trace()` being a no-op.\n2. Assume the type system prohibits storing managed data in a non-`Trace` type.\n3. Because of 2., we can assume that any non-`Trace` type does not contain managed data. Therefore, following 1., we can give that type a trivial no-op impl of `Trace`.\n4. We conclude that every type may have an impl of `Trace`. But if a type impls `Trace`, then the type system will let you store managed data in it, which invalidates our assumptions in 2.\n\nCan you pinpoint where the contradiction is? I get the feeling that I'm using circular logic in there somewhere. Maybe there should be two separate `Trace`-ish traits, in particular that the one present in 2., written/derived for types by the user, and the one induced by 1., used by the GC, should be separate things. But this is only a cloudy vision, and I can't see the particulars of how it would work. \n\n(Is this the same thing as the `TraceOrNonManaged` possibility you were floating? If we can assume that `TraceOrNonManaged` holds for _every_ type (and following the above we should be able to), then we could make it a special implicitly-present-on-every-type-parameter bound like `Drop` is.)\n\nThe key to unlocking this might also be in the particulars of how 2. happens, which isn't clear to me either.\n\n(I also had an idea w.r.t a primitive method for precisely scanning the stack that doesn't rely on LLVM (but does require compiler support) that I edited into the end of one of my previous comments, did you catch it?)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32121602/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32122521",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-32122521",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 32122521,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTIyNTIx",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-12T13:32:59Z",
    "updated_at": "2014-01-12T13:32:59Z",
    "body": "@glaebhoerl I think I've actually been thinking a similar thing to you (and have finally worked out that I'm on approximately the same page as you).\n\nIf `M` represents containing managed, and `T` is implementing `Trace` (and `Tn` for that being a noop), then your \"proof\" is\n\n```\n1. !M => T & Tn\n2. !T => !M\n3. 1 & 2 => (!T => T & Tn)\n```\n\nEven symbolically like that, it's not exactly obvious to me where that breaks down.\n\n> (Is this the same thing as the TraceOrNonManaged possibility you were floating? If we can assume that TraceOrNonManaged holds for every type (and following the above we should be able to), then we could make it a special implicitly-present-on-every-type-parameter bound like Drop is.)\n\nI think the two traits you mention are basically equivalent to `Drop` + the drop glue generated by the compiler: i.e. types that contain `Drop` types aren't automatically `Drop` but do have destructors that run the destructor of their contents (the drop glue).\n\n> (I also had an idea w.r.t a primitive method for precisely scanning the stack that doesn't rely on LLVM (but does require compiler support) that I edited into the end of one of my previous comments, did you catch it?)\n\nI didn't catch it (but I have now). I'd guess that something like that is the simplest way to do it, assuming that stops LLVM from optimising out the references.\n\n(As @nikomatsakis implies, the Mozilla employees (who've more experience in the GC space that I anyway, and more experience hacking on the compiler) have been thinking about this on and off for a while, so I assume they may have solutions for many of these problems.)\n\n---\n\n@nikomatsakis \n\n> However, I haven't finished reading all the comments on this thread, and I'd be happy if we are able to avoid the need to modify Cell/RefCell -- perhaps by just not needing write barriers altogether, though that implies a less sophisicated GC algorithm in turn\n\nThe API current exposed here is designed to have a write barrier on `Gc<T>` for all `T`, with a non-write-barrier method for `Freeze` types. This is presumably slightly/significantly slower if someone is repeatedly borrowing a `RefCell<Gc<T>>` immutably (which write-barriers-on-RefCells could avoid emitting a write barrier on) or `.get`ing from `Cell<Gc<T>>`, but doesn't require privileging them.\n\n(Although, if they were privileged, `std::gc` could expose the API for this publically so that other non-libstd types that need write barriers could do the same thing.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32122521/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32174872",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-32174872",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 32174872,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTc0ODcy",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-13T14:47:36Z",
    "updated_at": "2014-01-13T14:47:36Z",
    "body": "@pnkfelix and I had some discussion on IRC about the fact that the current collection policy (i.e. deciding when to run a collection; at the time of writing, it is just after some fixed number of allocations) is very subpar, causing quadratic behaviour---the number should be adjusting for heapsize.\n\n(Noting this here for posterity, and so I don't forget to fix it.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32174872/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32474482",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-32474482",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 32474482,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNDc0NDgy",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-16T14:47:18Z",
    "updated_at": "2014-01-16T14:47:18Z",
    "body": "Progress update: I've implemented some lang-items which make `~` and `~[]` work correctly (scanned conservatively, for now). (Not pushed yet.)\n\nAlso, a brief discussion with @nikomatsakis on IRC came to the conclusion that the `#[managed]` annotation (or whatever it becomes in future) should imply that the type is also non-sendable, otherwise a `~Trait:Send` object (the default for `~Trait`) will be considered to possibly contain `Gc` pointers and so require tracing/scanning.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32474482/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32585503",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-32585503",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 32585503,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTg1NTAz",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-17T07:39:15Z",
    "updated_at": "2014-01-17T07:39:15Z",
    "body": "(Both changes pushed.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32585503/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33124755",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33124755",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33124755,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTI0NzU1",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T13:49:05Z",
    "updated_at": "2014-01-23T13:49:05Z",
    "body": "@huonw Here's what I've managed to come up with:\n1. Just like drop glue, every type has trace glue. (If we think of this as a trait itself, then every type parameter of every function, trait, and impl has implicit `DropGlue` and `TraceGlue` bounds.)\n2. By default, trace glue is generated for each declared type to `trace()` each component (field) of the type (similarly to drop glue).\n3. Just as with `Drop`, the programmer may write `impl Trace for MyType` manually. And just as with `Drop`, when tracing the type, this code is invoked _in addition_ to the generated trace glue, and not instead of it.\n4. There would be a built-in `NoManaged` bound fulfilled by any type which provably doesn't refer to managed data. (Similar to `Send`, `Freeze`, etc.)\n5. `*T` would be continued to allow to point to any type, even a potentially-managed (not-`NoManaged`) one. But `*T` itself would _not_ be traced (trace glue = no-op), and it would be the programmer's responsibility to ensure that that the pointee is reachable through other means whenever the pointer is dereferenced.\n6.  For generic types implemented using `*T` (e.g. a smart pointer), it would be the programmer's responsibility to ensure that either `T: NoManaged` or that it is traced via a manual `Trace` impl. So taking [`Rc`](http://static.rust-lang.org/doc/master/src/std/home/rustbuild/src/rust-buildbot/slave/doc/build/src/libstd/rc.rs.html#43-45) as an example, either we should have `fn new<T: NoManaged>(value: T) -> Rc<T>`, or we should have:\n   \n   ```\n   impl<T> Trace for Rc<T> { \n       fn trace(&self, gc: &mut GcThing) {\n           unsafe { trace(&(*self.ptr).value, gc) }\n       }\n   }\n   ```\n7. A type (module, crate?) may have a `#[no_trace]` attribute. In this case, the generated trace glue is a no-op, and when constructing the type (via a struct literal or enum variant literal), the type system enforces a `NoManaged` bound on each component. (This is similar to how we forbid borrowed pointers in `@T`.) If it contains existentials they would also need `:NoManaged`, for generic `no_trace` types functions constructing the type would need a `NoManaged` bound on the type parameters, etc.\n\nWhat do you think? Any obvious (or non-obvious) holes?\n\n(I'm not sure 7. is necessary. It could work in the other direction, i.e. if the type enforces `NoManaged` then the trace glue is dropped as dead code.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33124755/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33126580",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33126580",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33126580,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTI2NTgw",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T14:13:24Z",
    "updated_at": "2014-01-23T14:13:24Z",
    "body": "Caveat: I still haven't read the entirety of this comment thread; sorry about that.  But I figured I should chime in while the most recent comment is fresh in my mind.\n\n@glaebhoerl I mentioned this off-hand to huonw some days ago, maybe last week: I'm generally suspicious about approaches that involve generating type-specific code for every type, because (1.) it is easy to overlook the costs with respect to code size there, and (2.) I worry a little about doing method dispatch in the inner loop of a garbage collector.\n\nTo address (1.), I would be more amenable to an approach that enabled more sharing between trace methods.  One way that we might accomplish this is to have the trace methods take an extra parameter that describes the layout of the type (or perhaps is just a pointer to its TyDesc -- not sure if I want to commit to that though); then all structs that do not have `*T` would have the option of sharing a single method that is an interpreter over the layout argument.  (Of course an interpretive loop could be slow.  There are ways I can imagine dealing with that.)\n\nFor addressing (2.), there's not much I can imagine beyond special casing certain types within the GC, which I guess we can do regardless of how the rest of the API is designed.  So maybe a non-issue here, maybe.  (And also, much like how I suspect the weak generational hypothesis won't hold for rust, it could also be that we just won't need to push as hard to have the tightest possible inner loop in the collector.)\n\nThose are my immediate pieces of feedback to your latest comment.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33126580/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33126740",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33126740",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33126740,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTI2NzQw",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T14:15:17Z",
    "updated_at": "2014-01-23T14:15:17Z",
    "body": "(also, while pondering over potential API's, try to keep in mind whether a proposed API is amenable to a mostly-copying collector.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33126740/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33152744",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33152744",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33152744,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTUyNzQ0",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T18:25:05Z",
    "updated_at": "2014-01-23T18:25:05Z",
    "body": "@pnkfelix Thanks for the feedback!\n\n>  (1.) it is easy to overlook the costs with respect to code size there\n\nWhy is this of great concern _here_, but not for drop glue and generics in general, which all have the same issue?\n\n> (2.) I worry a little about doing method dispatch in the inner loop of a garbage collector.\n\nBy inner loop, do you mean \"tracing the heap\"? That's exactly (among other things) what I like about this scheme. It strikes me that the usual approaches to GC involve taking information that is known at compile time and storing it as runtime data (e.g. headers on heap objects) for the GC to interpret. Here, information that is known at compile can be taken advantage of at compile time: the compiler can inline and optimize tracing code the same as it does other code. For example, given `~~~~~Gc<int>`, instead of the GC reading then analyzing the header on each owned box in turn, discovering that there's a pointer, following the pointer, and after doing this five times discovering the GC-managed object to be marked reachable, this could be optimized down to something like `mark_reachable(*****p)`. The only time a dynamic branch would have to be taken is when it's unavoidable, i.e. for trait objects, where it would call `trace()` through the vtable (the body of which will again be optimized static code).\n\nThis is the same choice Rust makes elsewhere: representations and code are specialized per-type for maximum performance, and I think the same considerations should apply.\n\nTo be clear, this would avoid the need to have any kind of headers, except for a pointer to the trace glue in trait objects (of which closures will be a subset), and even there it could potentially be omitted if we know that it's `NoManaged`. (We could also store drop glue and trace glue in the same vtable, and/or put them in the vtable for the trait itself, to further reduce the size of trait objects.)\n\nI think this would also be a good foundation for accomplishing #11425 with a minimum of bifurcation and contortions. (If the compiler can tell that everything is `NoManaged`, it _might_ even fall out automatically, but more thought is required.)\n\n> (also, while pondering over potential API's, try to keep in mind whether a proposed API is amenable to a mostly-copying collector.)\n\nWhat are the specific requirements here?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33152744/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33170046",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33170046",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33170046,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTcwMDQ2",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T21:23:11Z",
    "updated_at": "2014-01-23T21:23:11Z",
    "body": "@glaebhoerl \n\"Why is [code size] of great concern here, but not for drop glue and generics in general, which all have the same issue?\"\n\nI think that code size is a concern for all of these cases.  For generics, though, I think the end user has the option to use trait objects in order to trade off between code size versus running time overhead.  I don't think the story is so clean for drop glue currently, and I don't want a similar problem for plague the garbage collector.\n\nReally, I was just trying to provide food-for-thought.  Note that I did try to indicate that a virtual method based tracing system isn't necessarily bad; I just wanted you to think about making the interface to the method sufficiently general that one would have a prayer of shared code between a large class of mostly-unrelated types. \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33170046/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33171640",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33171640",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33171640,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTcxNjQw",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T21:38:07Z",
    "updated_at": "2014-01-23T21:38:07Z",
    "body": "Just quickly: how does shared tracing layout info interact with something like `Option<(Gc<int>, Gc<int>)>`? AIUI, setting that to `None` only zeros the discriminant, _not_ the two fields with the `Some`, so just tracing by fixed offsets would mean our tracing can either follow invalid pointers, or be unnecessarily conservative. (In general you have enums like `enum Foo { VeryCommon(int, int), AlsoCommon(u8), VeryRare([Gc<int>, .. 10]) }` and then you're having to trace/scan 10 words, despite the fact that those words are only Gc pointers occasionally.)\n\nAlso, about code-size. In theory the mergefunc LLVM pass (which is unfortunately still broken) should be able to combine the trace glues that are identical.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33171640/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33172138",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33172138",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33172138,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTcyMTM4",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T21:42:30Z",
    "updated_at": "2014-01-23T21:42:30Z",
    "body": "@huonw If one were to attempt to use the same default method implementation for a hypothesized `trace(desc:&TyDesc)`, then there is a third option beyond the two you mentioned: _interpret_ the desc and inspect the discriminant value.  That is, the `desc` tells you that you are looking at an `Option`, so first check whether its `None` before treating it like a tuple.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33172138/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33173973",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33173973",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33173973,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTczOTcz",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T22:01:09Z",
    "updated_at": "2014-01-23T22:01:09Z",
    "body": "Ah, that might work... But I guess it requires storing the discriminant size and then a \"map\" from discriminant value to pointer offsets.\n\n(Also, about code size, we'd only have to emit trace glue for types that have their tydesc got, I.e. trait objects and things put into `Gc`.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33173973/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33174970",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33174970",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33174970,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTc0OTcw",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T22:12:08Z",
    "updated_at": "2014-01-23T22:12:08Z",
    "body": "@glaebhoerl\n\nI'm not sure about trace glue being run in addition to any Trace implementations. E.g. if we have a SmallVector with a `[T, .. 8]` field stored unboxed, then we want to be able to conditionally trace those elements (that said we need a solution for conditionally running destructors in this case too).\n\nI'm also unsure about `*T` with `T` managed having a noop tracer by default... I've been thinking it might be better for it to be completely untraced, so any data structures using it need to explicitly trace it (or explicitly restrict the contents to be non-managed) or the compiler will disallow creating trace glue when `T` is managed. (I.e. `*int` would be fine for trace glue, but `*Gc<int>` would not.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33174970/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33188444",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33188444",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33188444,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTg4NDQ0",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-24T01:09:58Z",
    "updated_at": "2014-01-24T01:11:03Z",
    "body": "> I'm not sure about trace glue being run in addition to any Trace implementations. E.g. if we have a SmallVector with a [T, .. 8] field stored unboxed, then we want to be able to conditionally trace those elements (that said we need a solution for conditionally running destructors in this case too).\n\nInteresting scenario. My best guess is that such a type shouldn't actually store `[T, ..8]`, but something like `[[u8, ..sizeof!(T)], ..8]`, and use transmutes (which also solves the destructor issue). (Edit: Hmm, this wouldn't be enough when considering alignments...)\n\nThe idea that the declared `Trace` should be run in addition to trace glue came from considering types like `struct Blah<A, B, C> { a: Gc<A>, b: *B, c: ~C }`, where if you want to add tracing for `b`, you shouldn't also have to reimplement tracing for the rest of the type as well: a source of potential mistakes, where the compiler-generated code would be surely correct. It would also mean that, because of this potential, writing a manual `Trace` impl would itself be an unsafe act, possibly breaking soundness, whereas with the in-addition rule it only ever reduces unsafety (which is inherent in using a type like `*T`).\n\n(The fact that trace glue ended up resembling drop glue this closely was a surprise to me, but I think it's an encouraging sign.)\n\n> I'm also unsure about *T with T managed having a noop tracer by default... I've been thinking it might be better for it to be completely untraced, so any data structures using it need to explicitly trace it (or explicitly restrict the contents to be non-managed) or the compiler will disallow creating trace glue when T is managed. (I.e. *int would be fine for trace glue, but *Gc<int> would not.)\n\nTrace glue _has_ to exist, otherwise the edifice crumbles, you start having to require explicit `Trace` bounds again everywhere because it can no longer be assumed, etc.\n\nYour position is what I was thinking myself at one point: Does `*T` require `NoManaged`? That can't work, because `*T` should be able to point to anything, and if you do that, there's no way to even make e.g. `Rc<T>` hold a managed type. Is it traced? That can't be either, because it's up to the programmer to assert with an `unsafe` block that the pointee is valid whenever she dereferences it, and the compiler auto-generating `unsafe` blocks for you would be the height of absurdity. So maybe... some in between thing, where `*T` itself may refer to a managed type, but the `NoManaged` bound propagates outward to the type containing it? But how could this even work? It seems to be non-compositional, producing different results if you write `struct Foo<T>(*T)` versus `struct Bar<T>(T); type Foo<T> = Bar<*T>`. If you see a way to formulate a clean rule, I'm interested, but I have the feeling that the idea is fundamentally illogical. And what if `*T` is being used more like a borrowed pointer, where the pointee is known to be kept alive through other means?\n\nIt does make me uneasy that a type with `*T` would have to ensure either `NoManaged` or `Trace` manually, but at least using `*T` is already unsafe.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33188444/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33188860",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33188860",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33188860,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTg4ODYw",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-24T01:18:04Z",
    "updated_at": "2014-01-24T01:18:04Z",
    "body": "I don't have time right now for a full reply, but:\n\n> It would also mean that, because of this potential, writing a manual Trace impl would itself be an unsafe act, possibly breaking soundness, whereas with the in-addition rule it only ever reduces unsafety (which is inherent in using a type like *T).\n\n`Trace` impls are fundamentally unsafe, even with always-run trace glue, e.g. an incorrect `Trace` impl for `Rc<T>` or `Vec<T>` (both of which only use `*` internally) may let the GC deallocate Gc pointers that are still reachable. I would agree that running the trace glue in addition would be slightly safer, but I don't think manually implementing `Trace` will be very common (certainly nowhere near as common as `Drop`).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33188860/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33189649",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33189649",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33189649,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTg5NjQ5",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-24T01:33:38Z",
    "updated_at": "2014-01-24T01:33:38Z",
    "body": "It's using `*T` that's unsafe (see point 5), not writing the `Trace` impl. With always-run-trace-glue `impl Trace` can at best resolve, at worst ignore unsafety that was already present, but not introduce it. Without it, you can use it to introduce unsafety where none existed before (e.g. a type that doesn't even contain raw pointers).\n\nAlso @pnkfelix \n\n> Note that I did try to indicate that a virtual method based tracing system isn't necessarily bad\n\nThis might just be a matter of terminology, but if we're using C++ words, in the large majority of cases it wouldn't be using virtual methods, rather templates.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33189649/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33218378",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33218378",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33218378,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjE4Mzc4",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-24T12:18:34Z",
    "updated_at": "2014-01-24T12:21:24Z",
    "body": "Sorry, I wasn't specific enough about the unsafety: AIUI, one design for a (mostly) copying GC is for the tracing function to do (some of) the work in rewriting pointers as data is moved around in memory, so, for example, a tracing function that `fail`s can possible leave the GC heap (and possibly even the GC itself, since it's running the tracers \"inside\" itself) in an inconsistent state, and may then cause the task clean-up code (which includes the GC handling any remaining reachable allocations) to crash/be memory unsafe.\n\n(Of course, whether this is true or not likely depends heavily on the details of the design of the GC.)\n\n> And what if *T is being used more like a borrowed pointer, where the pointee is known to be kept alive through other means?\n\nA copying collector still needs to trace and handle `&T` (and equivalents). (At the very least, it needs to know that a certain block of memory can't be moved due to someone having borrowed an interior `&` pointer.)\n\n---\n\nI'm still uneasy about `*`: it seems relatively easy to have a library that exposes a safe interface using `*` and `unsafe` internally... without considering the GC properly (and getting it precisely correct will likely be difficult, especially with a more complicated GC like a moving one, where pointers change) leading to peculiar crashes. (On first though this seems easier to get wrong than most of the other forms of unsafety, but, with a solid API, it may turn out to be not so bad.) I'd _almost_ say that an \"internal\" error like `transmute` give (that is, you can have a generic function that uses transmute internally, and then an instantiation with mismatched sizes will emit an error from \"inside\" that function, visible as the span pointing to the start of the crate) would be better than risking crashing... but it may just get too annoying.\n\nThat said... we could \"solve\" this by just having a lint for types containing `*T` that don't trace it and don't restrict to to `NoManaged`. (Although I guess this would be _very_ hard to detect in general: the compiler would somehow have to look at all the avenues for producing such a type (including trait objects) and see if any of them have generics missing a `NoManaged`, including handling variance/phantom types correctly.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33218378/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33218427",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33218427",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33218427,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjE4NDI3",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-24T12:19:25Z",
    "updated_at": "2014-01-24T12:19:25Z",
    "body": "@glaebhoerl my assumption was that the core of the collector code, where it knows about object representation, where the mark bits are represented, whether to copy or not, how to scan the roots, etc would all be part of the rust runtime.  To link that up with arbitrary user-defined trace methods, I assume you need to do some kind of indirect function invocation, either via function ptrs or via a vtable.  That kind of indirection is what I meant by a \"virtual method tracing system.\"\n\n(I now see that this scheme might not necessarily imply that the inner loop of the collector is going through indirect function calls; so if the indirect function invocations are only occurring during an infrequent outer loop, e.g. during an initial root-scanning that queues up objects to be processed and an outer loop over the queue, then maybe my concerns about its efficiency will be found unwarranted.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33218427/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33218863",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33218863",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33218863,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjE4ODYz",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-24T12:27:29Z",
    "updated_at": "2014-01-24T12:27:46Z",
    "body": "Is an indirect function call (i.e. `(tydesc.trace_glue)(ptr)`, or something similar) going to be much slower than reading and interpreting the pointer metadata about discriminants and pointer words etc.?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33218863/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33219877",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33219877",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33219877,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjE5ODc3",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-24T12:46:44Z",
    "updated_at": "2014-01-24T12:47:19Z",
    "body": "@huonw The indirect call could well be a win.  (Especially if it jumps into common code that's already in the instruction cache.)\n\nIn case it wasn't clear from my phrasing before, I am more concerned about code size (and the indirect costs of failing to share code when possible) than about the overhead of an indirect jump.\n\nI have a copy of the 2012 GC handbook here.  I'll look up the references on generating per-class methods for tracing+copying+etc, so that we can at least see what other researchers have found.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33219877/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33220368",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33220368",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33220368,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjIwMzY4",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-24T12:55:46Z",
    "updated_at": "2014-01-24T12:55:46Z",
    "body": "Sounds good.\n\nAlthough, as I said above, Rust is possibly slightly unique in that we may not actually have a lot of distinct types with non-trivial tracers (i.e. any type that doesn't reach any managed pointers doesn't need tracing, and so their tracers could literally just be `ret void`, which will (a) be amenable to de-duplication via mergefunc, and (b) will always inline and be elided, for static calls)... assuming the use of the GC will be fairly restricted.\n\nIn any case, I'm sure there's been some thought about systems similar to this at some point, so I'll stop hypothesising.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33220368/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33222032",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33222032",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33222032,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjIyMDMy",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-24T13:23:52Z",
    "updated_at": "2014-01-24T13:57:21Z",
    "body": "Pages 169--171 of [The GC Handbook](http://gchandbook.org/) by Jones Hosking and Moss  discuss representing the info to support precise tracing of objects (as opposed to the roots/stack, which has many more pages of follow-on discussion).\n\nThe usual approach, for an OO language, is with a table mapping types (as represented by the ptr to the vtable) to a description of their layout.  (This doesn't immediately handle the `Option` problem that @huonw outlined, but perhaps the key for the table-lookup could also incorporate the discriminant.  Not sure yet.)  The handbook references [Huang et al, OOPSLA 2004](http://cs.anu.edu.au/~./Steve.Blackburn/pubs/abstracts.html#oor-oopsla-2004) for discussion of this.  (The main point it makes is that the tabular approach is fine, at least compared to choosing very specialized object-partitioning representations such as \"bidirectional object layout\", which is not an option for Rust.)\n\nFor generating object-oriented style methods for tracing/copying/etc, the handbook references the following papers, which I have not yet read:\n- (A series of papers by Stephen Thomas that I cannot find available for free online.) (**)\n- [Cheadle et al 2004](http://pubs.doc.ic.ac.uk/incremental-garbage-barrier/incremental-garbage-barrier.pdf): see table 2 for code bloat reported as percentages.\n- [Bartlett 1989a](http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-TN-12.pdf)  outlines the technique but does not report performance numbers (for neither running time nor code size).\n\nOn avoiding object-headers in statically-typed languages like ML, the handbook points to\n- [Appel 1989b](https://www.cs.princeton.edu/research/techreps/TR-142-88)\n- [Goldberg 1991](http://www.cs.nyu.edu/goldberg/pubs/gold91.pdf)\n- [Goldberg and Gloger 1992](http://www.cs.nyu.edu/goldberg/pubs/gg92.pdf)\n- [Goldberg 1992](http://cs.nyu.edu/goldberg/pubs/gold92.pdf)\n\nbut be forewarned: based on my memory, much of this work is largely not applicable to our domain.  (E.g. the Goldberg papers from 1992 say that the earlier work is in fact inapplicable to languages with polymorphic type parameters, and solves this by doing full type inference during collection; aka during runtime.  Totally unsuitable to us.)\n\n---\n\nSo my plan is to read the Cheadle 2004 paper carefully, and re-read the Huang 2004 paper, and maybe skim over the others a little.\n\n(**) here are the bibliography entries for the Stephen Thomas papers (see also the [gc bibliography](http://www.cs.kent.ac.uk/people/staff/rej/gcbib/gcbibT.html#thom94)).\n- Stephen Thomas 1993, Ph.D thesis [Pragmatics of Closure Reduction](http://kar.kent.ac.uk/21100/)\n- Stephen Thomas and Richard Jones 1994 [Garbage Collecting Shared Environment Closure Reducers](http://www.cs.kent.ac.uk/pubs/1994/147/)\n- Stephen Thomas 1995 [Garbage Collection in shared-environment closure reducers: Space-efficient depth-first copying using a tailored approach](http://www.bibsonomy.org/bibtex/23fb2f8f8716f02c56a84c5c3cb63cd15/dblp)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33222032/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33237785",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33237785",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33237785,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjM3Nzg1",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-24T16:31:25Z",
    "updated_at": "2014-01-24T16:35:24Z",
    "body": "@huonw \n\n> I'm still uneasy about `*`\n\nMe too, but can you think of a better plan? The one I described is the only one I managed to arrive at which actually holds together. I don't see any promising leads for a potentially better one, but that doesn't mean there isn't one.\n\nW.r.t. a copying/moving collector (it's good to see we've been thinking about the same things again!), the thought I keep returning to is that the garbage collector would have to be made to \"obey the borrow checker\", i.e. to not move things around if it would violate the contracts of any outstanding loans. I have very little idea about how (or whether) this could happen, though. (There's potentially two parts of it: one is moving an object in the heap and leaving an indirection to it in its former location. This might be handled by changing the representation of a Gc box (to enum of indirection or value etc), and potentially storing bit flags like Cell to know if there's any loans. The harder-seeming part is cleaning up the indirection and rewriting references to point to the new object... for this you would have to know that there aren't any loans of the Gc references themselves (as opposed to their contents).)\n\n@pnkfelix \n\n> my assumption was that the core of the collector code, where it knows about object representation, where the mark bits are represented, whether to copy or not, how to scan the roots, etc would all be part of the rust runtime\n\nRight... my thought was that the parts which relate to the properties and representation of types would be all be handled by the given type's trace glue (i.e. instead of storing data that \"this type is enum, it has a discriminant of size S, and members of type either A, B, and C or X, Y, and Z\" for the GC to interpret, the `trace()` glue would just do the `match` and invoke `trace()` in turn on the appropriate members statically, exactly the same as any derived instance of e.g. `Eq` or drop glue might do). How or whether this could be made to work together with more sophisticated GC ideas like generational and/or incremental collection, card marking, copying/moving, and so forth is an open question in my mind. So if you see any major conflicts, do share. :)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33237785/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33280698",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33280698",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33280698,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjgwNjk4",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-25T04:13:38Z",
    "updated_at": "2014-01-25T04:13:38Z",
    "body": "> the thought I keep returning to is that the garbage collector would have to be made to \"obey the borrow checker\", i.e. to not move things around if it would violate the contracts of any outstanding loans I have very little idea about how (or whether) this could happen, though.\n\nAt the very least, by tracing through `&` and `&mut` and marking their contents as \"borrowed\" (this would, unfortunately, require tracing _every_ reference, since any reference could point inside a `Gc` pointer; although the cost will only happen in tasks where the GC is actually active... but, depending on how we handle things like vectors, it may make `Vec<&T>` slightly slower). Also possible by having an RAII wrapper around the .borrow methods of `Gc` that registers & then deregisters a pointer , although this would mean every borrow is quite expensive... maybe ok, especially if we need to root borrows anyway.)\n\nAnother option is to actually rewrite `&` and `&mut` as we move things, but I imagine this may mean we have problems with optimisations.\n\n> for this you would have to know that there aren't any loans of the Gc references themselves\n\nI assume you're talking about `&Gc<T>` here? We can still rewrite the pointer there, but we may have to make `Gc` non-`Freeze` for it to be valid. (Although we may have to do this anyway, since even something like `let x: Gc<int>;` will be considered deeply immutable (with possible optimisation consequences) without marking it as not `Freeze`... unfortunately that is slightly lossy, in that only the pointer is changing, the contents is always identical.)\n\n> Me too, but can you think of a better plan? The one I described is the only one I managed to arrive at which actually holds together. I don't see any promising leads for a potentially better one, but that doesn't mean there isn't one.\n\nThe only other one I can think of that I think has any hope of working is the one that is similar to `transmute`. In code:\n\n``` rust\nextern \"rust-intrinsic\" {\n     /// Trace the value for the GC, calling a `Trace` impl and[/or]\n     /// the auto-generated tracing glue.\n     fn trace<T>(value: T, tracer: &mut Tracer);\n}\n\nfn foo(t: &mut Tracer) {\n    // ok\n    trace(0i, t);\n    trace(Gc::new(Gc::new(1)), t);\n\n     // error: trace called on a raw pointer that contains a managed type\n    trace(0 as *Gc<int>, t);\n}\n```\n\nBut, as I said above, this will have similar errors to transmute, where generic instantiations of functions from other crates can cause errors (similar to C++, too).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33280698/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33287378",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33287378",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33287378,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjg3Mzc4",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-25T12:01:03Z",
    "updated_at": "2014-01-25T12:07:21Z",
    "body": "> Also possible by having an RAII wrapper around the .borrow methods of Gc that registers & then deregisters a pointer , although this would mean every borrow is quite expensive... maybe ok, especially if we need to root borrows anyway.)\n\nThis is kind of what I was thinking.\n\nI don't suppose there's any way that the compiler could relay the static information that it has about borrows/loans to the garbage collector, and that this information could be sufficient? (I have a hard time wrapping my head around this, but my suspicion is no.)\n\n> Another option is to actually rewrite & and &mut as we move things, but I imagine this may mean we have problems with optimisations.\n\nRight. Any time the garbage collector disregards the borrow checker, I think you need to have a very strong reason why it's safe for it to do that, when it's not safe for other code to do so.\n\n> I assume you're talking about &Gc<T> here?\n\nYes, or more likely a borrow of some larger structure with `Gc<T>` inside it.\n\nAll this talk of rewriting pointers and references where it's not expected has me wondering whether we couldn't, or even shouldn't, adopt [SpiderMonkey's solution](https://blog.mozilla.org/javascript/2013/07/18/clawing-our-way-back-to-precision/) involving double indirection. After all, they're facing very similar constraints: a managed heap hosted in a non-managed environment. Their rooting API also seems to be very similar to the suggestion I had for how to do precise tracing of the stack. So essentially in this scheme our `Gc<T>` would be like their `Handle<T>`, and variables on the stack referencing potentially-managed data would be like their `Rooted<T>`, except done automatically by the compiler. (Though, AFAICT, they have a clear boundary between what's inside the GC heap (JavaScript) and what's on the outside pointing in, which means that it's only the latter which need a double indirection, whereas I'm not sure if we could make a similar distinction...)\n\n> The only other one I can think of that I think has any hope of working is the one that is similar to transmute\n\nJust to see if I'm understanding you correctly: is the idea that the transmute-like error would be generated if a type contains a raw pointer, which the automatically generated trace glue would attempt to trace? And that to resolve it you'd have to write your own `Trace` impl, which first casts it to a borrowed pointer or something before tracing it? (And IINM this would also depend on the manual `Trace` impl being used instead of, not in addition to, the generated trace glue?)\n\nIn the context of my earlier plan, i.e. not the afore-discussed transmute-like one, what about this solution: a lint which warns (or errors) if a type contains a raw pointer potentially referencing managed data, UNLESS any of the following are true:\n- the type has a `#[no_trace]` attribute (in which case `NoManaged` will be enforced by the compiler and there's nothing to worry about), or\n- the type has a manual `Trace` impl (whether it can or should also check that this impl looks like it actually attempts to trace the raw pointer is another question), or\n- the type has an `#[unsafe_managed]` attribute or something, which indicates to the compiler that \"I have my own solution to this and I know what I'm doing\".\n\nFor a type like `Rc<T>` which stores a \"single thing\" and doesn't rely on an external invariant to keep its data alive, if you don't want to allow managed data in it, adding `#[no_trace]` has no real drawback, it just enforces that you put `NoManaged` in the places where it's required for correctness in either case. It's only if you want one part of the type to be traced and another part `NoManaged`, or if you're doing a borrowed-pointer-like thing, that you need something more sophisticated.\n\nThis would still be best-effort (of course, I don't think you can make any guarantees around raw pointers), but it seems less error-prone than the prior plan.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33287378/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33287938",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33287938",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33287938,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjg3OTM4",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-25T12:33:59Z",
    "updated_at": "2014-01-25T12:49:06Z",
    "body": "@glaebhoerl @huonw regarding this issue: \"W.r.t. a copying/moving collector (it's good to see we've been thinking about the same things again!), the thought I keep returning to is that the garbage collector would have to be made to \"obey the borrow checker\", i.e. to not move things around if it would violate the contracts of any outstanding loans.\"\n\nIn the design I have been envisaging, this would fall semi-naturally out of a Bartlett style mostly-copying GC, with a few caveats.  Note that currently in `@T`, the `T` is not allowed to have &-ptr fields, which helps a little here.\n- The reason it falls out almost totally naturally is that one expects most of the `&T` ptrs (be they pointers to gc-allocated objects or to other memory), one expects most of them to be on the stack, so in a Bartlett-style Gc, the objects referenced via `&T's` on the stack will be pinned in place already.\n- I'm currently planning to conservatively scan ~-allocated objects that are recursively reachable from the stack; so that's another source of potential `&T` ptrs.  But that appears to just be a generalization of how the `&T` ptrs on the stack will be handled.  (Note the \"recursively\" here, i.e. I think it needs to be able to deal with a `~(Q, ~(R, ~(S, &T)))` that is on the stack.)\n- The only place where I imagine we would deal with re-writing `&T` references would be if they are in ~-allocated objects that are only directly referenced by objects that we are tracing precisely (i.e., gc-allocated objects).  Any borrowed references (to a T within gc-allocated object) that we scan conservatively would cause the referenced gc-allocated object to get pinned.\n  - Actually, I need to double check my thinking here.  I was thinking that the borrow-checker disallows `@&T` but that it allows `@~&T` (and likewise `@(Q, @(R, ~(S, &T)))`) but that might be simply incorrect on my part.  In which case this complication may not arise at all.  I need to check about this first.\n\nI do not know if this answers your question about how to integrate with the borrow checker, but it was enough to convince me that we could consider doing a moving collector that even allowed for (some) `&T` references to moving objects.\n\n(The reason that I want to ensure that we handle updating the `&T` references on ~-allocated objects that are reachable solely via gc-allocated objects, is because if you do not do this, then either (1.) the borrow-checker needs to emit code to pin and unpin gc-allocated objects, which I do not think is feasible, or (2.) you need to do a full non-moving tracing GC to find all of the reachable `&T` references before you can do any moves of any objects at all.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33287938/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33288300",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33288300",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33288300,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjg4MzAw",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-25T12:55:56Z",
    "updated_at": "2014-01-25T12:55:56Z",
    "body": "I didn't address native `*T` ptrs at all in my previous post.  I've been working under the assumption that the client code, i.e. library utilizing `*T`, would be responsible for pinning any gc-objects that have an outstanding `*T` pointer, and hopefully unpinning it eventually.  (Some collectors make pinned objects uncollectable, but in my mind pinning (disallowing moves) and rooting (disallowing reclamation) can be orthogonal notions; i.e. we could avoid imposing the burden of knowing when to unpin the object, and instead just never move it until it dies.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33288300/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33306232",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33306232",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33306232,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzA2MjMy",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-26T01:28:16Z",
    "updated_at": "2014-01-26T01:28:51Z",
    "body": "> I don't suppose there's any way that the compiler could relay the static information that it has about borrows/loans to the garbage collector, and that this information could be sufficient?\n\nAt the very least, we have to convey the actual value of the pointers that are borrowed so the GC knows which they are. (I imagine some sort of static information may be possible with precision everywhere... not really sure.)\n\n> is the idea that the transmute-like error would be generated if a type contains a raw pointer, which the automatically generated trace glue would attempt to trace? And that to resolve it you'd have to write your own Trace impl, which first casts it to a borrowed pointer or something before tracing it? (And IINM this would also depend on the manual Trace impl being used instead of, not in addition to, the generated trace glue?)\n\nYes, that's the idea, but I think we could still run the generated trace glue with a manual Trace impl: basically `*T` would have a noop trace glue, but it would be an error to actually attempt to call it directly. That is, you need to have a type with a `Trace` impl \"between\" a call to the `trace` intrinsic and any raw pointers, i.e.:\n\n``` rust\nstruct NoTraceImpl<T>(*T);\nstruct HasATraceImpl<T>(T);\nimpl<T> Trace for HasATraceImpl<T> { ... }\n\n// errors:\ntrace(raw_ptr, ...)\ntrace(NoTraceImpl(raw_ptr), ...);\ntrace(~NoTraceImpl(raw_ptr), ...); // `~` calls `trace` on its interior\n\n// ok\ntrace(HasATraceImpl(NoTraceImpl(raw_ptr)), ...);\ntrace(~HasATraceImpl(NoTraceImpl(raw_ptr)), ...);\ntrace(HasATraceImpl(~NoTraceImpl(raw_ptr)), ...);\n```\n\nTo be clear, in my mind, all this work with raw pointers is just designed to make it harder to do the wrong thing, it's not particularly fundamental to the semantics of the GC, it's just something that users should avoid making mistakes on, and it'd be nice if `rustc` caught the common ones.\n\nTo this end, a lint makes sense, but I think it could be rather difficult to do properly, since you may have the tracer for a raw pointer on a different type, i.e.:\n\n``` rust\nstruct Inner {\n    ptr: *X\n}\n\npub struct Outer {\n    priv inner: Complicated<Wrappers<Inner>>\n}\n\nimpl Trace for Outer { ... }\n```\n\nOf course, peculiar wrappers like this may just be where we say \"you're doing weird things, and the compiler can only be so smart; you're on your own, be careful\".\n\n> Actually, I need to double check my thinking here. I was thinking that the borrow-checker disallows @&T but that it allows @~&T (and likewise @(Q, @(R, ~(S, &T)))) but that might be simply incorrect on my part. In which case this complication may not arise at all. I need to check about this first.\n\n`~&T` is not `'static`, so yes, `@~&T` (all the sigils!) is disallowed.\n\n> I'm currently planning to conservatively scan ~-allocated objects that are recursively reachable from the stack; so that's another source of potential &T ptrs\n\n(FWIW, the code in this PR currently does this.)\n\nDoes this include conservatively scanning `~[]` vectors? (I guess with the library vector in `std::vec_ng`, it will be (somewhat) easier to precisely scan, since we don't have to build that extra infrastructure into the compiler. If we do precisely scan them, then we do have the option(requirement?) of rewriting any references inside `Vec<&T>`.)\n\nAlso, on `&T`, what about `&[T]`? (either as an interior slice into a `Gc<~[T]>` or just as a `&[Gc<T>]`)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33306232/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33310724",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33310724",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33310724,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzEwNzI0",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-26T06:50:52Z",
    "updated_at": "2014-01-26T06:57:06Z",
    "body": "> basically *T would have a noop trace glue, but it would be an error to actually attempt to call it directly. That is, you need to have a type with a Trace impl \"between\" a call to the trace intrinsic and any raw pointers\n\nI might be misunderstanding something: wouldn't the compiler generate trace glue for `NoTraceImpl` and immediately raise the error?\n\n> To be clear, in my mind, all this work with raw pointers is just designed to make it harder to do the wrong thing\n\nWe're on the same page.\n\n> a lint makes sense, but I think it could be rather difficult to do properly, since you may have the tracer for a raw pointer on a different type\n\nIn this example, the compiler would complain about `Inner`.\n\n(That is, my thinking was that it wouldn't try to \"look inside\" anything, and would raise the error at the type which actually contains the `*T`. Maybe there could be yet another attribute which says \"defer all yer complaining to users of this type\" (i.e. that this type is itself \"like `*T`\"), if there's demand for it.)\n\nWhat I'm not so clear about is how something like `struct Id<T>(T); struct Hmm<T> { m: Id<*T> }` might be handled. It's obviously preposterous to complain about `Id`. But to complain about `Hmm`, it seems like you would have to look at the definition of `Id`. (Given that it's a generic type, I suppose the compiler _would_ see its definition at some point, but I'm not sure if it's an appropriate point?)\n\n> At the very least, we have to convey the actual value of the pointers that are borrowed so the GC knows which they are. (I imagine some sort of static information may be possible with precision everywhere... not really sure.)\n\nThe compiler's information about borrows is per function, since of course function bodies are typechecked separately. So to again start from the least sophisticated solution that could possibly work, what the compiler could do is insert calls to `register_borrow(&var, Imm | Mut | ...)` and `unregister_borrow(&var)` or similar at the beginning and end of the statically known lifetime of each borrow of a variable holding potentially-managed data. If you also require `RefCell` to call these explicitly, then... you might even have full knowledge of active borrows. So maybe my suspicion was misplaced and this could actually work?\n\nWhat's not clear to me yet is the case where the function takes out a loan on some larger structure, but the _interior_ of that structure (which is thereby also borrowed) is also reachable through other means. First of all, is this possible? (Does the borrow checker allow it? Does the compiler have some notion of active vs. inactive pointers which the GC doesn't (yet)?) Second of all, if it's possible, could the GC detect it in a reasonable way?\n\nAnd of course the other big question is what the GC would actually do with all this information about active borrows that we'd be giving it.\n\n@pnkfelix:\n- If completely precise GC is possible, are there reasons why partly-precise, partly-conservative GC might still be preferable? What are they? What I'm driving toward with all this `Trace`ing and borrow checker stuff is essentially to see whether completely precise GC would be possible (and without headers everywhere!). (Again, my impression being that GCs are for some reason usually designed with the assumption that they need to work in a completely \"dynamic\" fashion;  while we have a _lot_ of static information, and we might try using it.)\n- Knowing that, as @huonw notes, borrowed pointers inside managed data are completely impossible, would this also completely avoid the need to rewrite any borrowed pointers anywhere in your scheme?\n- It makes me a little bit uneasy that your plan gives special consideration to `~` pointers, when it's just one smart pointer type among many. Is it meant to stand as a proxy for \"whatever kind of smart pointer\"? Or would there actually be a gap in support between `~` and other smart pointers? What if `~` is itself removed from the language and implemented as a library instead?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33310724/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33311425",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33311425",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33311425,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzExNDI1",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-26T07:43:31Z",
    "updated_at": "2014-01-26T07:43:31Z",
    "body": "> I might be misunderstanding something: wouldn't the compiler generate trace glue for NoTraceImpl and immediately raise the error?\n\nNo, that's the \"magic\". There's two concepts under that plan: the actual trace glue and the calling of the trace glue, (normally) done via some intrinsic (I called it `trace` above, but I'll call it `trace_checked` here). For raw pointers, the actual trace glue is a noop (and is perfectly fine to create[1]), but calling `trace` directly on one is illegal.\n\nSemantically, creating the trace glue for types without a `Trace` implementation would be the same as just calling `trace` on every field (so that \"unprotected\" raw pointers inside structs would be an error). However, calling `trace` on a type _with_ a trace implementation would still generate the trace glue for the fields, but the generation would not be considered to be a call to `trace`.\n\nAs an example, say we have `Uniq<T> { priv ptr: *mut T }` as a library implementation of `Uniq`, we'd have\n\n``` rust\nimpl<T> Trace for Uniq<T> {\n    fn trace(&self, t: &mut Tracer) {\n        unsafe { trace_checked(&*self.ptr, t) }\n    }\n}\n```\n\ni.e. just tracing its contents.\n\nThen the trace glue for `Uniq<T>` would look something like:\n\n``` rust\n// explicit Trace impl:\ncall trace_checked::<T> // contents\n// autogenerated:\ncall trace_glue::<*mut T> // noop\n```\n\nFor `Uniq<*T>` the trace glue would be\n\n``` rust\n// explicit Trace impl:\ncall trace_checked::<*T> // error: calling trace_checked on *T\n// autogenerated:\ncall trace_glue::<*mut *T> // noop\n```\n\nAs a different example, say we have `Foo<T, U> { x: Uniq<T>, y: U }` (without an explicit `Trace` impl), then the trace glue for `Foo<int, *int>` would be\n\n``` rust\n// explicit Trace impl: <no impl>\n// autogenerated:\ncall trace_checked::<Uniq<int>> // code above\ncall trace_checked::<*int> // error: calling trace_checked on *T\n```\n\nThe difference is the call of `trace_checked` or the direct call of `trace_glue` in the autogenerated section based on whether there is an `Trace` impl of the current type or not. Writing it out like this, I'm relatively sure it could work, but (a) the error messages would be as bad as the ones we get from `transmute`, and (b) I'm not sure how well it fits into the compiler/language. Especially since the only types that have a different behaviour for `trace_glue` vs. `trace_checked` are `*T` and `*mut T`.\n\n[1]: I don't know how this would interact with trait objects. I guess the trace glue in a trait object would created as if it were a call to `trace_checked`, rather than `trace_glue`.\n\n> In this example, the compiler would complain about Inner.\n\nMy point is that is a case when it shouldn't complain about Inner, because `Outer` is managing the tracing. I guess `#[allow(untraced_raw_pointer)] struct Inner { ... }` would be ok.\n\n> What's not clear to me yet is the case where the function takes out a loan on some larger structure, but the interior of that structure (which is thereby also borrowed) is also reachable through other means. First of all, is this possible? (Does the borrow checker allow it? Does the compiler have some notion of active vs. inactive pointers which the GC doesn't (yet)?) Second of all, if it's possible, could the GC detect it in a reasonable way?\n\nMaybe something like `Gc<Rc<int>>`: you can have an `Rc<int>` outside the `Gc` that points to the same `int`. However, I'm not quite sure what you mean by this.\n\nAlso, re spidermonkey-style double-indirection, I'd thought about it briefly, but didn't really pursue it at all, since we actually have control of the compiler & language and the ability to put in the appropriate hooks to make that unnecessary, in theory. (I'd assumed that avoiding two layers of pointers is a Good Thing, without considering the benefits of such an approach in depth.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33311425/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33316425",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33316425",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33316425,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzE2NDI1",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-26T13:10:22Z",
    "updated_at": "2014-01-26T13:10:43Z",
    "body": "@glaebhoerl \n1. Regarding \"GCs are for some reason usually designed with the assumption that they need to work in a completely \"dynamic\" fashion; while we have a lot of static information, and we might try using it\"\n   - I will just mention again the papers by Appel and also Goldberg that I referenced in [an earlier comment](#issuecomment-33222032).  Those explore GC in the context of ML, where you have much the same collection of static information that we do, at least from the view point of a GC.  (I suspect Goldberg's tack diverges from your own in his handling of polymorphic types, but still, if you want to spend time on the thought experiment, it may be good to see what others have done here.)\n2. Regarding: \"If completely precise GC is possible, are there reasons why partly-precise, partly-conservative GC might still be preferable?\"\n\nThis is a game of trade-offs.  The word \"possible\" is very broad.  I do not doubt that it is \"possible\" to implement a completely precise GC for Rust.  But that does not imply that it would be the right engineering decision for the short term (and perhaps not even for the long term).\n\nLargely I keep pushing for a Mostly-Copying Collector due to ease of implementation: to get a tracing GC into Rust ASAP, I do not want to spend more time than necessary wrestling with LLVM.  I am under the impression that LLVM's API for precise stack scanning may be in a flux in the near term, so that's a distraction, and I do not want to spend time finding out what the performance overheads are of its current API.\n\nI'm not saying that I would immediately veto a fully-precise collector.  I just think it would be a mistake to build full-precision in as an up-front requirement for the GC.\n\nAnyway, there are other reasons that a Mostly-Copying GC could be preferable. I continue to stress: this is all about _trade-offs_:\n- It may simplify interfacing with native code.  (But then again, I already said that I want to see whether we can require explicit pinning and unpinning from the client code in such cases.)\n- The metadata to support precise stack scanning are another source of potential bloat.  I do not have my copy of the GC handbook with me at the moment so I do not have access to the relevant statistics here.\n- The code to scan the stack conservatively is not just simpler to implement, but it can also be faster than trying to do a precise scan, depending on the technique that is used.  \n\nI think my mindset coincides with Filip Pizlo's on this matter; see the LLVMdev emails I linked in [another comment above](#issuecomment-31984453).  In particular this one: \"I do not mean to imply that accurate GC shouldn't be considered at all.  It's an interesting compiler feature.\"\n\nI'll repeat a few links that I found again while double-checking my work writing this comment:\n- http://lists.cs.uiuc.edu/pipermail/llvmdev/2013-October/066906.html\n- http://lists.cs.uiuc.edu/pipermail/llvmdev/2013-October/066984.html\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33316425/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33524900",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33524900",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33524900,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTI0OTAw",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-28T21:01:55Z",
    "updated_at": "2014-01-28T21:03:40Z",
    "body": "@pnkfelix Thanks for the pointers, I've finally borrowed some time to start following them. Below are my notes. I did not give them very thorough readings, but only attempted to understand the most important aspects of each.\n\nBartlett's 1989 paper explains mostly-copying GC and how to extend it to a generational collector. The key idea is that besides the area of memory they reside in, whether a page is in old-space or new-space can also be tracked by a field stored in the page. The stack is scanned conservatively, and pages pointed into are \"moved\" to new-space by updating their space fields. In this way the address of objects which may-or-may-not be referenced from the stack is unchanged. After this, objects referenced from these pages are physically copied into new-space. (This requires those objects to be self-identifying, e.g. to have headers.)\n\nAppel's paper is about GC in Pascal and ML without headers or tags on objects. This is accomplished by the compiler generating tables containing type information (layout etc) for the garbage collector, which traverses these tables in parallel with the traced objects to keep track of types. The type of roots is determined by associating this information with the functions containing them, which is looked up by the GC based on the return-address pointer, and in the case of polymorphic functions, walking up the stack until the function where the type variables are instantiated is found. It also has a section on how to do breadth-first copying collection with this scheme.\n\nGoldberg 91 seems closer to what I was thinking about: here garbage collection routines are generated by the compiler for each type. He takes it a step further, and borrowing Appel's idea of associating GC information with functions, also generates GC routines per function to trace its stack variables (and in fact a different routine for each point in the function where different variables are live). There is also analysis to avoid doing this when a function doesn't allocate and therefore cannot trigger collection. Tracing polymorphic values (here all polymorphism is with boxing) is accomplished by parameterizing the tracing routine for each polymorphic function and type over the tracing routines of their type variables, which during GC are passed in by the tracing routine for the containing type/stack frame. There is also a section on extending this to parallel programs which I skipped.\n\nGoldberg 92 is about how to extend tagless GC to copying _incremental_ GC. Read about halfway, seems quite interesting, might be worth returning to later. (Also the pages are in reverse order, which is kinda weird.)\n\nGoldberg/Gloger 92 realize that tracing vptrs must also be stored for closures. For polymorphic closures there seems to be a problem, because there is no way to go back to the point where the closure was created to find out what types it is closing over. They then realize that by parametricity, if a closure is polymorphic over some types, then its code cannot follow pointers to those types, therefore doing this is actually unnecessary: any values whose type the GC cannot establish can only be garbage.\n\nHuang et al 04 appears to be about using JIT technology to help the Java GC optimize locality based on the dynamic execution of the program. I'm not sure which part of this is relevant here?\n\nCheadle et al 04 is about using code specialization to reduce the heap usage of their incremental GHC/Haskell garbage collector. As Haskell is lazily evaluated, heap objects in GHC contain a pointer to \"entry code\" which, if the object is an unevaluated thunk, points to code which evaluates it, stores the result, and then overwrites the entry code pointer with a different one which merely returns the stored result. Objects are accessed by the mutator \"entering\" them in this way. As this is already a read barrier, they take advantage of the same mechanism for incremental GC to scavenge the object (copy its referents from old-space to new-space) when the mutator \"enters\" it. In their earlier version, this necessitated storing an additional pointer to the original non-scavenging entry code in each heap object, so that after scavenging the normal entry code can be used. In this paper they remove the need for this additional pointer by instead generating specialized scavenging and non-scavenging versions of each function, and making the entry code pointer point to the appropriate one. Except for perhaps their measurements I'm not sure how relevant all of this is to us. They do observe that closures are just trait objects:\n\n> The most important feature of the STG-machine for our purposes is that a closure has some control over its own operational behaviour, via its entry code pointer. We remark that this type of representation of heap objects is quite typical in object-oriented systems, except that the header word of an object typically points to a method table rather than to a single, distinguished method (our \u201centry code\u201d).\n\nI haven't looked at the LLVM links yet, I'll have to get back to those later.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33524900/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33527188",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33527188",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33527188,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTI3MTg4",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-28T21:23:07Z",
    "updated_at": "2014-01-28T21:23:07Z",
    "body": "@pnkfelix most of your concerns w.r.t. precise tracing appear to be about tracing the stack. I'll re-suggest my earlier [suggestion](https://github.com/mozilla/rust/pull/11399#issuecomment-31869769) here: the compiler could generate code in each function to register and deregister those stack variables as roots (in the form of their address plus the trace glue vptr corresponding to their type) which may possibly contain references to managed data. While this may not be optimal for mutator performance when using GC, it also avoids relying on LLVM and imposes no cost on code which is known not to require GC. I also had a similar [idea](https://github.com/mozilla/rust/pull/11399#issuecomment-33310724) for identifying (and presumably pinning?) objects which have been borrowed. In both cases, there is also the advantage that besides the compiler generating these calls automatically for safe code, they would also be available for unsafe code to invoke manually where appropriate.\n\nThe reason I was wondering what advantages semi-precise GC has (in other words, what the other side of the tradeoffs is) is that one of our main objectives, which is not putting a burden on code which doesn't use GC, seems (to me) to be easier to achieve with precise collection. (Which is not so surprising if you consider that precise collection involves knowing what _not_ to trace.)\n\n@huonw Gah, I still need to process your last comment as well. :) I'll get around to it.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33527188/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33528343",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33528343",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33528343,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTI4MzQz",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-28T21:31:45Z",
    "updated_at": "2014-01-28T21:35:20Z",
    "body": "@glaebhoerl you said \"most of your concerns w.r.t. precise tracing appear to be about tracing the stack\":\nwell, yes, when comparing fully-precise tracing versus mostly-copying style tracing, the only difference _is_ how the stack is handled ... \n\n(update: I was being a bit flip in the previous comment.  I do realize you've been talking about trying to do a heavily type-driven tracing gc, which would imply that you really do need precise knowledge of the types of one's registers and stack slots in order to properly drive the tracing itself, at least if one wants to do it without any headers, and that would be impossible in a conservative stack scanning setting.  I just am not yet convinced that this is a realistic option for us.  Maybe I am too pessimistic.)\n\nThere is plenty of precedent for having the compiler emit code to automatically maintain a root set (or a shadow stack of roots, register/deregister, etc.)  I think the LLVM-dev email thread I linked to earlier has some pointers to related work here.  As you said, its not a technique thats known to be terribly performant.\n\nI'll have to go back through your comments on this thread, as I feel like I must have misunderstood something in the line of discussion here.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33528343/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33659521",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33659521",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33659521,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjU5NTIx",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-30T04:30:51Z",
    "updated_at": "2014-01-30T04:30:51Z",
    "body": "You can have optimal performance by generating tables that tell you, for every instruction that can potentially trigger GC (i.e. all function calls), which registers or locations on the stack cointain GC roots, and what their type is.\n\nWhen GC is triggered you use unwind tables to find the IPs in all functions on the call stack, lookup the GC tables for all of them, and trace them.\n\nYou can probably do that now on LLVM with http://www.llvm.org/docs/StackMaps.html\n\nI think that ultimately this is the only option for Rust that would be acceptable for \"production\": conservative scanning is conceptually really ugly, cannot scan datatypes that hide pointers but have a custom Trace implementation, can incorrectly keep dead objects alive forever, adds the overhead of having to annotate all allocations with type information and adds the overhead of a data structure that allows to lookup whether a value is a pointer to an object.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33659521/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33672731",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33672731",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33672731,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjcyNzMx",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-30T09:40:03Z",
    "updated_at": "2014-01-30T09:40:03Z",
    "body": "@bill-myers you've said basically the same thing in [your earlier comment](#issuecomment-31968763).\n\nOut of curiosity:\n- Do you know offhand if Filip Pizlo has revised his opinion of the necessity/utility of precise stack scanning?\n- Do you think that Rust is just fundamentally different from the languages where Bartlett-style mostly-copying gc has been deployed succesfully?  I suppose reasonable people can different about what \"acceptable for production\" means.\n\n---\n\nIn my opinion we need precise heap scanning but can live with conservative stack scanning for 1.0.  I agree that the other drawbacks with conservative scanning you pointed out are present, at least partially (I may quibble about details), but I disagree about their impact.  I do not think mostly-copying is conceptually ugly, and I stand my points about the trade-offs here that I made [earlier](#issuecomment-33659521).\n\nLooking over the [LLVM stack map API](http://www.llvm.org/docs/StackMaps.html), it says outright in the motivation section that the functionality is currently experimental.  The only linked client of the API is [FLT JIT](https://trac.webkit.org/wiki/FTLJIT), which is also experimental and disabled by default.  So I stand especially by this comment I made earlier: \n\n> I do not want to spend more time than necessary wrestling with LLVM. I am under the impression that LLVM's API for precise stack scanning may be in a flux in the near term, so that's a distraction, and I do not want to spend time finding out what the performance overheads are of its current API.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33672731/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33673728",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33673728",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33673728,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjczNzI4",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-30T09:54:29Z",
    "updated_at": "2014-01-30T09:56:11Z",
    "body": "I realized something while reflecting on this dialogue.\n\nI think many of the participants here are focused on using precise stack scanning to enable type-driven heap tracing from the outset in the roots+stack.  Notably, people haven't been discussing whether these tracing procedures are using a mark-sweep style GC or a copying GC, which makes sense, because that is an orthogonal decision once you assume that you are going to have 100% precise tracing on the roots and stack.\n\nMeanwhile, my focus has been on how to get a GC into Rust that makes use of techniques such as copying collection.  I do not want to build in a mark-sweep GC as the only GC we deploy in 1.0, because I worry that end-users will then build the assumption that objects do not move into their own code, and we'll never get a relocating collector into the runtime once libraries deployed with that assumption become popular.  (And Rust may not need a relocating collector; but since it might, I would prefer to start with one and then see whether it fails to pay for itself.)\n\nMy recent realization is that these two ends: type-driven GC and a mostly-copying style GC, may not be at odds with one another.  Assuming that we have precise type information for at least one GC reference stored on the stack (or in a ~[T] solely reachable from the stack), via a stack map or what-have-you: then that may be enough info to drive the GC in the manner that @glaebhoerl wants, while still allowing us to use a Bartlett style system that still pins all the objects immediately reachable from the stack (which I conservatively assume to be borrowed and have outstanding borrowed references) but allows relocation of the other heap-allocated objects.  There would be no need, I think, to worry about borrowed-references to moving objects, which has been my primary motivation for focusing on mostly-copying GC.\n\nI admit: the above is just conjecture, I haven't thought it through completely.  It may not address all of the drawbacks that @bill-myers pointed out.\n\nI guess my point is, I may have been mistakenly conflating \"precise stack scanning\" with \"fully-moving GC\", and the latter I have been treating as \"too risky for 1.0.\"  But I would be happy to adopt type-driven tracing in combination with mostly-copying GC.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33673728/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33756578",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33756578",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33756578,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNzU2NTc4",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-31T02:18:58Z",
    "updated_at": "2014-01-31T02:50:10Z",
    "body": "@huonw I think I _finally_ understand the `trace_checked` idea. It does seem a bit involved and magical, but also relatively thorough and complete (apart from checking the validity of actual `Trace` impls, it seems like it catches every case?). Do you see a solution in the lint-based (or lint-like) approach to the `struct Foo<T> { x: Uniq<*T> }` case that's better than just conservatively triggering the warning any time `*T` is present as a type argument? But maybe that's good enough... perhaps it could piggyback off variance and, a bit less conservatively, warn only if it's used in covariant or invariant positions.\n\n> My point is that is a case when it shouldn't complain about Inner, because Outer is managing the tracing. I guess #[allow(untraced_raw_pointer)] struct Inner { ... } would be ok.\n\nIn total you'd need three attributes, with the hard part being figuring out ergonomic bikeshed colors:\n- one which makes the type have no-op trace glue and enforces `NoManaged` (`no_trace`?)\n- one for types containing `*T` which are \"like `&T`\", in that they look unsafe without a `Trace` impl but aren't (`unsafe_raw_managed`?)\n- and one for types containing `*T` which are \"like `*T`\", in other words _are_ unsafe without a `Trace` impl, and should be treated the same as `*T` itself in any containing contexts (`checked_unsafe_raw_managed`??)\n\nThe latter two are rather different, but capturing that distinction in their names is another matter.\n\n> Maybe something like `Gc<Rc<int>>`: you can have an `Rc<int>` outside the Gc that points to the same int. However, I'm not quite sure what you mean by this.\n\nA good example might actually be the reverse: consider `Rc<Gc<int>>`. Under what circumstances is the GC allowed to (a) rewrite the contents (pointee) of the `Gc` box with an indirection, (b) rewrite the `Gc` pointer itself? The former case seems easier: it should be allowed iff the `int` isn't borrowed (so \"borrowing is pinning\"). For (b), I was thinking at first that the same rule would apply (rewritable unless borrowed), but upon reflection I think this doesn't make sense. Why should it be forbidden to rewrite the `Gc<int>` pointer in `&Gc<int>`, but allowed in e.g. `Gc<Gc<int>>`, and our example which is `Rc<Gc<int>>`? (`RefCell` doesn't mind.) If this is the right way of thinking about it, then `Gc` would indeed be kinda non-`Freeze` as you say. (I'm starting to have questions about the meaning and legitimacy of `Freeze`...)\n\nThe restrictions on (a) seem like they could be satisfied with a `RefCell`-like dynamically tracked borrows with RAII scheme. Are there other, perhaps more efficient ways? For instance, using either [my earlier idea](https://github.com/mozilla/rust/pull/11399#issuecomment-33310724) or conservative stack scanning, how could it handle cases like `Gc<~int>` where someone takes out a borrow on the `int`? Just as when it's on the stack, `~int` should not be relocated while its interior is borrowed. But how will the GC know this, when they're at unrelated addresses? (With the `RefCell`-like mechanism, the programmer must first borrow the full contents of the `Gc` box i.e. `~int` to borrow a part of it, i.e. the `int`, so this doesn't pose a problem.)\n\n@pnkfelix:\n\nI think my attitude is basically that it would be awfully nice to have the infrastructure for fully precise, type-based, Rustic tracing right from the start, in a way that minimizes (ideally all the way to 0) the impact on non-GC code, while the performance of the GC itself and GC-using code can be improved later as long as the semantics and programmer-facing parts of it are there. Hence why the compiler-inserted `register_root` calls idea seems appealing to me: not necessarily fast, but appears relatively easy to implement (relative to having to rely on LLVM support which doesn't exist, anyways), and it could be replaced with precise stack maps or Goldberg-style generated stack tracing code or whatever else at any later point without changing the observable behavior.\n\n>  I worry that end-users will then build the assumption that objects do not move into their own code\n\nGiven that Rust's semantics guarantee memory safety, this should only be an issue for `unsafe` code. Is that what you meant?\n\nAlso questions:\n- How would conservative stack scanning handle the `Gc<~int>` + `&int` case from above? \n- In an earlier comment you wrote \"I'm currently planning to conservatively scan `~`-allocated objects that are recursively reachable from the stack\": how would this work exactly? (And [how] would it generalize to library smart pointer types?)\n\n(I don't really mind what method is used, as long as it's compatible with the mentioned goals, so if \"borrowing is pinning\" is implemented by conservatively scanning the stack that's fine by me. I'm just trying to understand how it would work.)\n\n> There would be no need, I think, to worry about borrowed-references to moving objects, which has been my primary motivation for focusing on mostly-copying GC.\n\nCould you expand on this point? I'm not sure I grok it.\n\n> I may have been mistakenly conflating \"precise stack scanning\" with \"fully-moving GC\", and the latter I have been treating as \"too risky for 1.0.\"\n\nIs this because of having to rely on uncertain-at-best LLVM support, or some other reason?\n\n@bill-myers do you have any thoughts about the generated stack tracing code approach from [Goldberg's 1991 paper](https://github.com/mozilla/rust/pull/11399#issuecomment-33222032)? (This is kind of like treating a stack frame as a big struct and generating code to trace that type (not unlike how stack-closures-as-trait-objects can be interpreted), with the additional complication that different variables are live at different points. Of course that complication exists with stack maps as well.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33756578/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33757334",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33757334",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33757334,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNzU3MzM0",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-31T02:40:16Z",
    "updated_at": "2014-01-31T02:40:16Z",
    "body": "I'll come back to it, but:\n\n> (I'm starting to have questions about the meaning and legitimacy of Freeze...)\n\nIt's possible that `Freeze` will disappear (https://github.com/mozilla/rust/issues/11781), but it may be still useful for TBAA-style optimisations. In any case, I certainly don't think that it's a requirement for `Gc<T>` to be `Freeze`.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33757334/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33896396",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33896396",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33896396,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzODk2Mzk2",
    "user": {
      "login": "emberian",
      "id": 704250,
      "node_id": "MDQ6VXNlcjcwNDI1MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emberian",
      "html_url": "https://github.com/emberian",
      "followers_url": "https://api.github.com/users/emberian/followers",
      "following_url": "https://api.github.com/users/emberian/following{/other_user}",
      "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emberian/subscriptions",
      "organizations_url": "https://api.github.com/users/emberian/orgs",
      "repos_url": "https://api.github.com/users/emberian/repos",
      "events_url": "https://api.github.com/users/emberian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emberian/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-02T09:48:28Z",
    "updated_at": "2014-02-02T09:48:28Z",
    "body": "Closing to clear up the queue.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33896396/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33930506",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33930506",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33930506,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzOTMwNTA2",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-03T07:58:28Z",
    "updated_at": "2014-02-03T07:58:28Z",
    "body": "(I don't think this should impede us in continuing the discussion?)\n\n@huonw I noticed that of the \"three attributes\" from above, the second can be adequately expressed by writing an explicit no-op `Trace` impl. So then there's only two, which makes naming a bit easier.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33930506/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33930917",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-33930917",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 33930917,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzOTMwOTE3",
    "user": {
      "login": "emberian",
      "id": 704250,
      "node_id": "MDQ6VXNlcjcwNDI1MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emberian",
      "html_url": "https://github.com/emberian",
      "followers_url": "https://api.github.com/users/emberian/followers",
      "following_url": "https://api.github.com/users/emberian/following{/other_user}",
      "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emberian/subscriptions",
      "organizations_url": "https://api.github.com/users/emberian/orgs",
      "repos_url": "https://api.github.com/users/emberian/repos",
      "events_url": "https://api.github.com/users/emberian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emberian/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-03T08:08:27Z",
    "updated_at": "2014-02-03T08:08:27Z",
    "body": "(No, it certainly doesn't)\n\nOn Mon, Feb 3, 2014 at 2:58 AM, G\u00e1bor Lehel notifications@github.comwrote:\n\n> (I don't think this should impede us in continuing the discussion?)\n> \n> @huonw https://github.com/huonw I noticed that of the \"three\n> attributes\" from above, the second can be adequately expressed by writing\n> an explicit no-op Trace impl. So then there's only two, which makes\n> naming a bit easier.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/mozilla/rust/pull/11399#issuecomment-33930506\n> .\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33930917/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34314938",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-34314938",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 34314938,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzE0OTM4",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-06T11:37:00Z",
    "updated_at": "2014-02-06T11:37:00Z",
    "body": "> Do you see a solution in the lint-based (or lint-like) approach to the struct Foo<T> { x: Uniq<*T> } case that's better than just conservatively triggering the warning any time *T is present as a type argument? But maybe that's good enough... perhaps it could piggyback off variance and, a bit less conservatively, warn only if it's used in covariant or invariant positions.\n\nLints can examine attributes etc. on things, so it would be possible to have a `#[allows_unsafe_gc]` annotation on types that can always handle `*T`... but other than that: I guess it would just be conservatively triggered. I'm not really sure of the consequences.\n\n> Under what circumstances is the GC allowed to (a) rewrite the contents (pointee) of the Gc box with an indirection\n\nI'm probably misunderstanding(I'm interpreting that as \"change the value that the `Gc<T>` points to\")... but, never? The GC should only be modifying the `Gc` pointers not the contents (unless the contents is other `Gc` pointers...).\n\n> (b) rewrite the Gc pointer itself?\n\nAs long as we can guarantee we rewrite all references (and only rewrite actual references) as we move things, it seems reasonable for this to always be possible... although this means everything can change under the feet of a function (since the values can change due to some far removed `Gc::new()` call), so if we allow rewriting `&` would this require reloading them off the stack for every interaction?\n\n(If so, it would have to apply to all `&`s, and would require compile-time disabling of the GC (in the whole program) to avoid... maybe it seems less reasonable.)\n\n> For instance, using either my earlier idea or conservative stack scanning, how could it handle cases like Gc<~int> where someone takes out a borrow on the int? Just as when it's on the stack, ~int should not be relocated while its interior is borrowed\n\nI think the `~int` _can_ actually be relocated when there is only a `&int`, since the `int` it (and the reference) points to never moves. I think the subtlety here (which is what you are saying, AIUI) is making sure that a `&int` into a `Gc<~int>` keeps it reachable, so that the `Gc` pointer isn't collected (possibly finalising the `~int` and leaving the `&int` dangling). I.e. we need some sort of rooting/borrowing device like RefCell, as you say.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34314938/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34331327",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-34331327",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 34331327,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzMxMzI3",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-06T15:08:55Z",
    "updated_at": "2014-02-06T15:08:55Z",
    "body": "> > Under what circumstances is the GC allowed to (a) rewrite the contents (pointee) of the Gc box with an indirection\n> \n> I'm probably misunderstanding(I'm interpreting that as \"change the value that the Gc<T> points to\")... but, never? \n\nSome GCs, I think generational collectors, do a thing where moves happen in two stages: in minor collections moved objects are rewritten with forwarding pointers (indirections) to their new location, and in major collections these are cleaned up by actually making all references point to the new location (after which the indirection becomes garbage). A simplistic formulation in Rust might be something like:\n\n```\npub struct Gc<T> { priv contents: *mut GcContents<T> }\nenum GcContents<T> { Object(T), Indirection(Gc<T>) }\n```\n\nClearly the contents can't be overwritten with an indirection as long as the object itself is borrowed.\n\n> if we allow rewriting `&` would this require reloading them off the stack for every interaction?\n\nI don't have specific arguments for this position yet (though perhaps you have just stated one), but my very strong feeling is that borrowed references should _not_ be rewritten. It should work in the opposite direction: an `&` reference should root and pin the thing it is referring to. The GC should not have special license to meddle with things outside its domain, rather it should be subject to the same invariants as other code.\n\n> I think the `~int` can actually be relocated when there is only a `&int`, since the `int` it (and the reference) points to never moves.\n\nIn this particular case yes, this is true. But in the case of `(double, int)` borrowing `&int`, it just as obviously isn't. Maybe in that case, the GC can figure out that it's the same object because they're adjacent in memory. But in theory both types have the same kind of ownership semantics. How does the GC know? I'm very nervous about this extending to any kind of general case, because it feels like the GC would need to have knowledge of the semantics and internal invariants of every particular type for it to be safe. Much more reassuring to say that borrowing the interior of an object in a `Gc` box should behave _as if_ the whole object were borrowed first (maybe the only way to do this is to make it be literally what happens, or maybe not; I don't know).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34331327/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34342844",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-34342844",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 34342844,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzQyODQ0",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-06T16:42:44Z",
    "updated_at": "2014-02-06T16:44:58Z",
    "body": "@glaebhoerl First off, I'm inclined to agree that a `&` reference should pin its referent.  I have gone back-and-forth internally on this matter, but at this point I think this suggestion is likely to be the most workable solution.\n\nI think this property (that `&` reference should pin their referent) is the essence of my argument for why we should adopt a mostly-copying strategy that pins the references reachable from the stack (or reachable from `&` references that are in `~` objects recursively reachable from the stack).  I admit that there remain two strategies for pinning here: 1. Pin based on immediate-reachability from the stack (or the `~`heap), as described in the previous sentence, or 2. do the pinning when the borrow occurs and then unpin when the borrow expires, which I believe is what you are thinking of.\n\nI do not yet know how to handle doing the unpin exactly when the borrow expires, which is one reason strategy 2 worries me, although maybe we can do something that just keeps things pinned for longer than strictly necessary, I am not yet sure.\n\n---\n\nSecond, just an aside / FYI / head's up: I think you are conflating generational collectors with replicating incremental collectors.  A relocating generational collector will move a subset of the objects (namely the live ones in the nursery) during a minor collection, but in my experience it is also responsible for updating all references to the moved objects before yielding control back to the mutator.  (This is one purpose of a remembered set: to provide the collector with a narrowed subset of the fields that need to be updated when the objects in the nursery are moved, so that hopefully one will do less work than an scan of the entire heap in order to maintain this invariant.)\n\nIn an incremental copying (i.e. relocating) collector, objects can be copied and then there may be two copies in existence while the mutator is allowed to run.  Supporting a system where an object can be forwarded by the GC and then control returns to the mutator _before_ all of the outstanding references have been updated in this strategy is often accomplished via a read-barrier (which is a non-starter for us IMO), although I think alternative schemes that still rely solely on write-barriers have been devised such as the one from [Cheng and Blelloch](http://dl.acm.org/citation.cfm?id=378823&CFID=289782149&CFTOKEN=48318899) (which I think is a variant of [Nettles and O'Toole](http://dl.acm.org/citation.cfm?id=155111&CFID=289782149&CFTOKEN=48318899); and here's another contemporary paper by [Blelloch and Cheng](http://dl.acm.org/citation.cfm?id=989456&CFID=289782149&CFTOKEN=48318899), I cannot recall offhand which one is most relevant here; in any case the write-barriers in these cases are far more expensive than the ones one typically sees in a normal generational collector.)\n\n(my apologies for not providing links that are not behind a paywall.  If other people take the time to track down variant links to free pre-prints of those papers, please feel free to add those links to the end of the this comment, but please leave the acm links above alone to aid with finding cross-references.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34342844/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34439765",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-34439765",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 34439765,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NDM5NzY1",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-07T14:19:30Z",
    "updated_at": "2014-02-07T18:23:12Z",
    "body": "@pnkfelix I was thinking in particular of GHC's collector, which does do the thing where indirections are cleaned up by the GC, but indeed, my hazarded guess that it has to do with generational collection was wrong: in fact the indirections are created when thunks are evaluated. (I had a surprising amount of trouble finding a good reference for this which does more than just mention it in passing, but see e.g. the \"Graph Reduction: Thunks & Updates\" section [here](http://www.scs.stanford.edu/11au-cs240h/notes/ghc.html).)\n\nSo mea culpa, but it doesn't end up making much difference: if the object is moved by rewriting all references, the old location will become garbage, so we still can't allow it while borrowed references exist (as @huonw noted). (Constrast to a borrow not of the managed object, but of a `Gc<T>` which refers to it: in that case we will still rewrite the `Gc<T>` with impunity, and accordingly we must declare `Gc<T>` non-`Freeze`.)\n\n> I think this property (that `&` reference should pin their referent) is the essence of my argument for why we should adopt a mostly-copying strategy that pins the references reachable from the stack (or reachable from `&` references that are in `~` objects recursively reachable from the stack). I admit that there remain two strategies for pinning here: 1. Pin based on immediate-reachability from the stack (or the `~`heap), as described in the previous sentence\n\nMy thoughts here are still the same: I can see how this would straightforwardly handle _most_ cases, but we need to handle _all_ of them, and it's not obvious to me what the story for the remainder is. In particular I'm still concerned about two things: \n1. How would you detect `&` references stored inside arbitrary (library-defined) non-`~` smart pointer types? \n2. How would you detect `&` references to the interior of a managed object?\n\n> or 2. do the pinning when the borrow occurs and then unpin when the borrow expires, which I believe is what you are thinking of.\n\nSomething like that. In the tradition of starting with a simple solution which is obviously correct, consider:\n\n```\npub struct Gc<T> { priv contents: *GcContents<T> }\nstruct GcContents<T> { pins: Cell<uint>, object: T }\npub struct PinRef<'s, T> { priv contents: &'s GcContents<T> }\npub fn borrow<'s, T>(gc: &'s Gc<T>) -> PinRef<'s, T> {\n    unsafe { \n        (*gc.contents).pins.set((*gc.contents).pins.get() + 1);\n        PinRef { contents: &*gc.contents }\n     }\n}\npub fn get<'s, 'x, T>(pr: &'s PinRef<'x, T>) -> &'s T {\n    &pr.contents.object\n}\nimpl<T> Drop for PinRef<T> {\n    fn drop(&mut self) {\n        self.contents.pins.set(self.contents.pins.get() - 1)\n    }\n}\n```\n\n(I now regret using the word \"obviously\": it's not obvious to me that I got all of that right.) But in any case, the basic idea that just as with `RefCell`, borrows are delineated by RAII increment and decrement of a counter, and thereby the GC can tell whether the object is pinned by checking `pins > 0` does seem to be obviously correct, and points 1. and 2. from above don't present any additional difficulty. The question is whether it's possible to make a solution that's more efficient than this without compromising its correctness.\n\n> I do not yet know how to handle doing the unpin exactly when the borrow expires, which is one reason strategy 2 worries me, although maybe we can do something that just keeps things pinned for longer than strictly necessary, I am not yet sure.\n\nCould you elaborate on what kind of mechanisms you were thinking about here?\n\n@huonw, re: interior references, I think my concerns can be distilled down to the fact that the borrow checker doesn't let you do it. Any time you take out a loan on the interior of an object, whether owned box, tuple, or `HashMap`, the borrow checker will disallow moving the object before the loan has expired. A lot of thought has gone into the borrow checker to make sure that its rules are a sufficient condition for safety. Any time we want the GC to do something which the borrow checker would reject, I would want to have at least a sketch of a proof that it's still safe, and not just for specific types, but all types.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34439765/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34442672",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-34442672",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 34442672,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NDQyNjcy",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-07T14:52:50Z",
    "updated_at": "2014-02-07T14:54:27Z",
    "body": "@glaebhoerl I'll address your questions in reverse order\n\n> -    How would you detect & references to the interior of a managed object?\n\nMy assumption is either (1.) we require the owning pointer to the managed object to be kept alive on the stack for as long as it has outstanding `&`references (since the presence of the owning pointer on the stack will pin the managed object in place), which may require some IR / LLVM-integration effort to keep LLVM from dead-code-eliminating those owning pointers, or (2.) we require a page map for the managed heap, so that `&`references to interiors of managed objects can be mapped to the metadata for the managed object.\n\nI have more hands-on experience with (2) than (1), but either should be workable.\n\n> -    How would you detect & references stored inside arbitrary (library-defined) non-~ smart pointer types?\n\nLet me see if I understand this scenario correctly.  Any kind of value, including the smart-pointers holding the  `&`references, will end up being put either: onto the task's stack, into a ~-allocated object, into a gc-heap-allocated object, or into memory acquired externally to the runtime (e.g. via `malloc`).\n\nThe main worrisome case that I can see here is `&`references stored in malloc'ed memory (since we can handle pointers on the stack or in `~`-allocated storage conseratively and we cannot put `&`references into gc-heap-allocated objects).\n\nBut at that point we must be in the realm of user-defined tracers, no?  (Or user-annotations on the types that yield tracers, etc; this is a topic I've been sidestepping since I wanted to get the basics working first.)\n\nOr are you talking about the pointer to malloc'ed memory then itself being transmuted to a `&`reference or a `~`reference (and then later transmuted back to a `*u8` and then freed in a drop method somewhere)?  I'll admit I haven't thought too carefully about this because I had assumed a lot of these use-cases would need to be dealt with via user-annotation.\n\nI continue to worry that I jump into responding to your questions while being unsure that I actually understand the scenarios you are describing...\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34442672/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34443435",
    "html_url": "https://github.com/rust-lang/rust/pull/11399#issuecomment-34443435",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11399",
    "id": 34443435,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NDQzNDM1",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-07T15:00:28Z",
    "updated_at": "2014-02-07T15:00:28Z",
    "body": "\b(also I am fully aware that @glaebhoerl has posed questions to me that I have not answered.  That's mostly because it takes too long for me to come up with concise answers, while lengthy answers make this long thread even more unmanageable.  I wonder whether there is a better forum for us to carry on this discussion...)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34443435/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
