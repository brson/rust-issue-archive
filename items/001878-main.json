{
  "url": "https://api.github.com/repos/rust-lang/rust/issues/1878",
  "repository_url": "https://api.github.com/repos/rust-lang/rust",
  "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/1878/labels{/name}",
  "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/1878/comments",
  "events_url": "https://api.github.com/repos/rust-lang/rust/issues/1878/events",
  "html_url": "https://github.com/rust-lang/rust/pull/1878",
  "id": 3324271,
  "node_id": "MDExOlB1bGxSZXF1ZXN0ODY0MTc2",
  "number": 1878,
  "title": "new libuv bindings",
  "user": {
    "login": "olsonjeffery",
    "id": 10408,
    "node_id": "MDQ6VXNlcjEwNDA4",
    "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/olsonjeffery",
    "html_url": "https://github.com/olsonjeffery",
    "followers_url": "https://api.github.com/users/olsonjeffery/followers",
    "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}",
    "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions",
    "organizations_url": "https://api.github.com/users/olsonjeffery/orgs",
    "repos_url": "https://api.github.com/users/olsonjeffery/repos",
    "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}",
    "received_events_url": "https://api.github.com/users/olsonjeffery/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 10,
  "created_at": "2012-02-22T00:07:14Z",
  "updated_at": "2014-06-22T14:32:49Z",
  "closed_at": "2012-02-29T01:57:22Z",
  "author_association": "CONTRIBUTOR",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/rust-lang/rust/pulls/1878",
    "html_url": "https://github.com/rust-lang/rust/pull/1878",
    "diff_url": "https://github.com/rust-lang/rust/pull/1878.diff",
    "patch_url": "https://github.com/rust-lang/rust/pull/1878.patch",
    "merged_at": null
  },
  "body": "Included in this pull request are bindings for `uv_async_*` calls and some of the `uv_timer_*` calls (init, start and stop).\n\nFirst, some samples (from the tests.. the code is in std::uv):\n\n```\nimport uv = std::uv;\nlet test_loop = uv::loop_new();\nlet exit_port = comm::port::<bool>();\nlet exit_chan = comm::chan::<bool>(exit_port);\nuv::async_init(test_loop, {|new_async|\n    uv::close(new_async) {||\n        comm::send(exit_chan, true);\n    };\n}, {|new_async|\n    uv::async_send(new_async);\n});\nuv::run(test_loop);\nassert comm::recv(exit_port);\n```\n\n(The call to `uv::async_init` takes two callbacks: the first one is the actual callback to be invoked by calls to `uv::async_send`, while the latter is a callback that is processed once the uv_async handle is created).\n\nand again with a uv_timer:\n\n```\nlet test_loop = uv::loop_new();\nlet exit_port = comm::port::<bool>();\nlet exit_chan = comm::chan::<bool>(exit_port);\nuv::timer_init(test_loop) {|new_timer|\n    uv::timer_start(new_timer, 1u32, 0u32) {|started_timer|\n        uv::timer_stop(started_timer) {|stopped_timer|\n            uv::close(stopped_timer) {||\n                comm::send(exit_chan, true);\n            };\n        };\n    };\n}; \nuv::run(test_loop);\nassert comm::recv(exit_port);\n```\n\nObviously, a _lot_ of the API and handle types are missing but the core pattern is in place for adding new handles.\n## How it works, briefly:\n### From the user's perspective:\n\nuser calls uv::loop_new() and gets a uv_loop in return. They use the uv_loop for operations to _create_ new handles (uv_async, uv_timer, etc). The functions to create the new handle take callbacks that are invoked asynchronously after the handle is added to the loop. In these callbacks, the user gets access to the new handle and can now do various operations against libuv. It's all async, and all thread safe. So: creating new handles is async.\n\nThey can, at their leisure, start the libuv event loop by calling uv::run() or uv::run_in_bg() (the former is blocking like its C counterpart, while the latter is not). uv::run() will return when the last handle associated with it is unref'd via uv::close(). We don't really have a need for a uv::loop_delete().. the loop is cleaned up after uv_run() returns and probably shouldn't be used again.\n### Under the hood:\n\nWhen the user calls uv::loop_new(), we spin up a new scheduler that blocks on incoming messages, within a while loop, on a port that it creates. It sends the channel back out to the invoker (who returns it to the user as a uv_loop). We also register a (unref'd, so it doesn't affect loop lifetime) async handle whose job is buffer incoming requests, from the user, for processing by libuv. All method calls from the user (with the exception of uv::run() and uv::async_send()) are buffered through this async handle (called the op_handle).\n\nWhen the user calls uv::run(), we create a new, single-threaded, scheduler that contains the libuv loop and call uv_run() there. Any operations that the user did on the loop before running will be processed at this time.\n\nEventually, the last handle is unref'd and uv_run() returns. We clean up the op_handle and then notify the rust loop to exit.\n## What's missing\n1. Most other handles that make libuv useful.\n2. doesn't really hew to the core vision of working with C fns/structs directly from rust (I didn't map the uv_handle structs as brson did in the c->rust email). This would be a pretty clean refactor, IMO, would do away with a level of callbacks. Cleanly mapping out the structs to avoid landmines will be interesting, though.\n3. probably some spit and polish on the c/c++ front. it looks like the kernel->malloc()s and free()s add up, but that's about it. I'm pretty blah about the handle_data struct, too (especially once we start mapping handles that have trickier callback/data requirements). In general, cleanly using/abusing the `void*` data in `uv_*_t` structs will be interesting, especially when managed primarily from rust.\n4. I'm pretty blah about how a bunch of the uv::foo() methods are, probably, going to take what i called an \"after_cb\", to be processed when it's done. We're basically node.js, now. This is the effect of having it be async-all-the-way-down. I did play with using chans to \"send out\" the handle once its created, but then the caller is just blocking while waiting for it, which felt like it was purpose-defeating, to me. Maybe if we had promises (do we?)?\n\nI hope this change passes muster. Thanks for reading!\n",
  "closed_by": {
    "login": "brson",
    "id": 147214,
    "node_id": "MDQ6VXNlcjE0NzIxNA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/brson",
    "html_url": "https://github.com/brson",
    "followers_url": "https://api.github.com/users/brson/followers",
    "following_url": "https://api.github.com/users/brson/following{/other_user}",
    "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
    "organizations_url": "https://api.github.com/users/brson/orgs",
    "repos_url": "https://api.github.com/users/brson/repos",
    "events_url": "https://api.github.com/users/brson/events{/privacy}",
    "received_events_url": "https://api.github.com/users/brson/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/1878/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/1878/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "_meta": {
    "type": "pr"
  }
}
