[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/11668932",
    "html_url": "https://github.com/rust-lang/rust/issues/4284#issuecomment-11668932",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/4284",
    "id": 11668932,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExNjY4OTMy",
    "user": {
      "login": "jesse99",
      "id": 425055,
      "node_id": "MDQ6VXNlcjQyNTA1NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/425055?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jesse99",
      "html_url": "https://github.com/jesse99",
      "followers_url": "https://api.github.com/users/jesse99/followers",
      "following_url": "https://api.github.com/users/jesse99/following{/other_user}",
      "gists_url": "https://api.github.com/users/jesse99/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jesse99/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jesse99/subscriptions",
      "organizations_url": "https://api.github.com/users/jesse99/orgs",
      "repos_url": "https://api.github.com/users/jesse99/repos",
      "events_url": "https://api.github.com/users/jesse99/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jesse99/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-12-25T04:08:24Z",
    "updated_at": "2012-12-25T04:08:24Z",
    "body": "I spent quite a while trying to come up with a decent test case but I was unable to. However the code below is similar to what I am doing, although unfortunately it does not expose the problem.\n\n```\nextern mod std;\n\nfn handle_connection(notify: pipes::Chan<()>)\n{\n    do task::spawn_sched(task::ManualThreads(2)) |move notify|\n    {\n        let (push_port, push_chan) = pipes::stream();\n        let push_chan = pipes::SharedChan(push_chan);\n\n        let mut tasks = ~[];\n        loop\n        {\n            let exit_chan = pusher(push_chan.clone());\n            vec::push(&mut tasks, exit_chan);\n\n            // In the real code this happens in response to a message sent\n            // as a result of a socket closing.\n            if tasks.len() == 1\n            {\n                notify.send(());\n                close_tasks(tasks);\n                break;\n            }\n\n            push_port.recv();\n            error!(\"received\");\n        }\n    }\n}\n\nfn close_tasks(tasks: &[pipes::Chan<()>])\n{\n    for tasks.each |task|\n    {\n        task.send(());\n    }\n    // In the real code I get the failure unless I sleep for a bit here.\n}\n\nfn pusher(push_chan: pipes::SharedChan<~str>) -> pipes::Chan<()>\n{\n    let (exit_port, exit_chan) = pipes::stream();\n    let push_chan = push_chan.clone();\n    do task::spawn_sched(task::ThreadPerCore) |move push_chan, move exit_port|\n    {\n        while !exit_port.peek()\n        {\n            error!(\"sending\");\n            push_chan.send(~\"hmm\");\n            libc::funcs::posix88::unistd::sleep(1);\n        }\n    }\n    exit_chan\n}\n\nfn main()\n{\n    let (port, chan) = pipes::stream();\n    handle_connection(chan);\n    port.recv();\n}\n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/11668932/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/11675234",
    "html_url": "https://github.com/rust-lang/rust/issues/4284#issuecomment-11675234",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/4284",
    "id": 11675234,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExNjc1MjM0",
    "user": {
      "login": "jesse99",
      "id": 425055,
      "node_id": "MDQ6VXNlcjQyNTA1NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/425055?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jesse99",
      "html_url": "https://github.com/jesse99",
      "followers_url": "https://api.github.com/users/jesse99/followers",
      "following_url": "https://api.github.com/users/jesse99/following{/other_user}",
      "gists_url": "https://api.github.com/users/jesse99/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jesse99/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jesse99/subscriptions",
      "organizations_url": "https://api.github.com/users/jesse99/orgs",
      "repos_url": "https://api.github.com/users/jesse99/repos",
      "events_url": "https://api.github.com/users/jesse99/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jesse99/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-12-25T18:36:04Z",
    "updated_at": "2012-12-25T18:36:04Z",
    "body": "Managed to get a repro while trying to repro a different pipes problem. The code is a bit complex but should still be a somewhat reasonable test case:\n\n```\nextern mod std;\nuse core::send_map::linear::{LinearMap};\n\nenum StateMesg\n{\n    AddListener(~str, pipes::Chan<int>),    // str is used to identify the listener\n    RemoveListener(~str),\n    Shutdown,\n}\n\ntype StatePort = pipes::Port<StateMesg>;\ntype StateChan = pipes::Chan<StateMesg>;\n\npub enum ControlEvent\n{\n    RefreshEvent,\n    CloseEvent,\n}\npub type PushChan = pipes::SharedChan<~str>;\npub type ControlPort = pipes::Port<ControlEvent>;\npub type ControlChan = pipes::Chan<ControlEvent>;\npub type OpenSse = fn~ (channel: PushChan) -> ControlChan;\npub type SseTasks = ~[(~str, ControlChan)];\n\nfn main()\n{\n    let state_chan = pipes::SharedChan(manage_state());\n    let up: OpenSse = |push| {uptime_sse(state_chan.clone(), push)};\n\n    let (exit_port, exit_chan) = pipes::stream();\n    handle_connection(exit_port, up);\n\n    libc::funcs::posix88::unistd::sleep(3);\n//    state_chan.send(Shutdown);\n    exit_chan.send(());\n\n    // Not quite sure how to shutdown the manage_state task so for now\n    // we'll forcibly exit.\n    libc::funcs::posix88::unistd::sleep(1);\n    libc::exit(0);\n}\n\nfn manage_state() -> StateChan\n{\n    error!(\"starting manage_state\");\n    let (state_port, state_chan) : (StatePort, StateChan) = pipes::stream();\n    do task::spawn_sched(task::ManualThreads(1)) |move state_port|\n    {\n        let mut time = 0;\n        let mut listeners = LinearMap();\n        loop\n        {\n            time += 1;\n            libc::funcs::posix88::unistd::sleep(1);\n            error!(\"sending new state\");\n            for listeners.each_value |ch: &pipes::Chan<int>| {ch.send(copy(time))};\n\n            if state_port.peek()\n            {\n                match state_port.recv()\n                {\n                    AddListener(key, ch) =>\n                    {\n                        let added = listeners.insert(key, ch);\n                        assert added;\n                    }\n                    RemoveListener(key) =>\n                    {\n                        listeners.remove(&key);\n                    }\n                    Shutdown =>\n                    {\n                        error!(\"exiting manage_state\");\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    state_chan\n}\n\nfn uptime_sse(registrar: pipes::SharedChan<StateMesg>, push: PushChan) -> ControlChan\n{\n    error!(\"starting sse client\");\n    let (control_port, control_chan): (ControlPort, ControlChan) = pipes::stream();\n    do task::spawn_sched(task::ThreadPerCore) |move control_port, move registrar, move push|\n    {\n        let (notify_port, notify_chan) = pipes::stream();\n\n        let key = fmt!(\"uptime %?\", ptr::addr_of(&notify_port));\n        registrar.send(AddListener(copy key, notify_chan));\n\n        loop\n        {\n            let mut time = 0;\n            match pipes::select2i(&notify_port, &control_port)\n            {\n                either::Left(_) =>\n                {\n                    error!(\"pushing new state\");\n                    let new_time = notify_port.recv();\n                    time = new_time;\n                    push.send(fmt!(\"retry: 5000\\ndata: %?\\n\\n\", time));\n                }\n                either::Right(_) =>\n                {\n                    match control_port.recv()\n                    {\n                        RefreshEvent =>\n                        {\n                            push.send(fmt!(\"retry: 5000\\ndata: %?\\n\\n\", time));\n                        }\n                        CloseEvent =>\n                        {\n                            error!(\"exiting sse client\");\n                            registrar.send(RemoveListener(key));\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    control_chan\n}\n\npub fn handle_connection(exit: pipes::Port<()>, opener: OpenSse)\n{\n    error!(\"starting connection\");\n    do task::spawn_sched(task::ManualThreads(1))\n    {\n        let (sse_port, sse_chan) = pipes::stream();\n        let sse_chan = pipes::SharedChan(sse_chan);\n\n        let mut sse_tasks = ~[];\n        let control_chan = opener(sse_chan);\n        vec::push(&mut sse_tasks, (~\"some path\", control_chan));\n\n        loop\n        {\n            match pipes::select2i(&exit, &sse_port)\n            {\n                either::Left(_) =>\n                {\n                    error!(\"exiting connection\");\n                    exit.recv();\n                    close_sses(&sse_tasks);\n                    break;\n                }\n                either::Right(_) =>\n                {\n                    let body = sse_port.recv();\n                    error!(\"received %s state\", body);\n                }\n            }\n        }\n    }\n}\n\npub fn close_sses(tasks: &SseTasks)\n{\n    error!(\"closing all sse\");\n    for tasks.each |&(_path, control_ch)|\n    {\n        control_ch.send(CloseEvent);\n    };\n\n    // With this commented out we get the \"you dun goofed\" failure.\n//    libc::funcs::posix88::unistd::sleep(1);\n}\n\n```\n\nWhen I run this I get:\n\n```\nRUST_LOG=3 && rustc test.rs\nwarning: no debug symbols in executable (-arch x86_64)\nrust: ~\"starting manage_state\"\nrust: ~\"starting connection\"\nrust: ~\"starting sse client\"\nrust: ~\"sending new state\"\nrust: ~\"sending new state\"\nrust: ~\"pushing new state\"\nrust: ~\"received retry: 5000\\ndata: 2\\n\\n state\"\nrust: ~\"exiting connection\"\nrust: ~\"closing all sse\"\nrust: task failed at 'you dun goofed', test.rs:1\nrust: task failed at 'connection closed', test.rs:1\nrust: domain main @0x7fb3fb81a610 root task failed\nrust: ~\"sending new state\"\n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/11675234/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/14217732",
    "html_url": "https://github.com/rust-lang/rust/issues/4284#issuecomment-14217732",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/4284",
    "id": 14217732,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE0MjE3NzMy",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-02-28T05:34:02Z",
    "updated_at": "2013-02-28T05:34:02Z",
    "body": "@eholk \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/14217732/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19084452",
    "html_url": "https://github.com/rust-lang/rust/issues/4284#issuecomment-19084452",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/4284",
    "id": 19084452,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE5MDg0NDUy",
    "user": {
      "login": "Aatch",
      "id": 342416,
      "node_id": "MDQ6VXNlcjM0MjQxNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Aatch",
      "html_url": "https://github.com/Aatch",
      "followers_url": "https://api.github.com/users/Aatch/followers",
      "following_url": "https://api.github.com/users/Aatch/following{/other_user}",
      "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions",
      "organizations_url": "https://api.github.com/users/Aatch/orgs",
      "repos_url": "https://api.github.com/users/Aatch/repos",
      "events_url": "https://api.github.com/users/Aatch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Aatch/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-06-07T01:34:07Z",
    "updated_at": "2013-06-07T01:34:07Z",
    "body": "This still happens. Here is an updated test case:\n\n``` rust\nextern mod extra;\nuse std::hashmap::HashMap;\nuse std::*;\n\nenum StateMesg\n{\n    AddListener(~str, comm::Chan<int>),    // str is used to identify the listener\n    RemoveListener(~str),\n    Shutdown,\n}\n\ntype StatePort = comm::Port<StateMesg>;\ntype StateChan = comm::Chan<StateMesg>;\n\npub enum ControlEvent\n{\n    RefreshEvent,\n    CloseEvent,\n}\npub type PushChan = comm::SharedChan<~str>;\npub type ControlPort = comm::Port<ControlEvent>;\npub type ControlChan = comm::Chan<ControlEvent>;\npub type OpenSse = ~fn (channel: PushChan) -> ControlChan;\npub type SseTasks = ~[(~str, ControlChan)];\n\nfn main()\n{\n    let state_chan = comm::SharedChan::new(manage_state());\n    let up: OpenSse = |push| {uptime_sse(state_chan.clone(), push)};\n\n    let (exit_port, exit_chan) = comm::stream();\n    handle_connection(exit_port, up);\n\n    unsafe {\n        libc::sleep(3);\n        exit_chan.send(());\n\n        libc::sleep(1);\n        libc::exit(0);\n    }\n}\n\nfn manage_state() -> StateChan\n{\n    error!(\"starting manage_state\");\n    let (state_port, state_chan) : (StatePort, StateChan) = comm::stream();\n    do task::spawn_sched(task::ManualThreads(1))\n    {\n        let mut time = 0;\n        let mut listeners = HashMap::new();\n        loop\n        {\n            time += 1;\n            unsafe {\n            libc::sleep(1);\n            }\n            error!(\"sending new state\");\n            for listeners.each_value |ch: &comm::Chan<int>| {ch.send(time)};\n\n            if state_port.peek()\n            {\n                match state_port.recv()\n                {\n                    AddListener(key, ch) =>\n                    {\n                        let added = listeners.insert(key, ch);\n                        assert!(added);\n                    }\n                    RemoveListener(key) =>\n                    {\n                        listeners.remove(&key);\n                    }\n                    Shutdown =>\n                    {\n                        error!(\"exiting manage_state\");\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    state_chan\n}\n\nfn uptime_sse(registrar: comm::SharedChan<StateMesg>, push: PushChan) -> ControlChan\n{\n    error!(\"starting sse client\");\n    let (control_port, control_chan): (ControlPort, ControlChan) = comm::stream();\n    let control_cell = cell::Cell(control_port);\n    do task::spawn_sched(task::ThreadPerCore)\n    {\n        let mut (notify_port, notify_chan) = comm::stream();\n\n        let mut control_port = control_cell.take();\n\n        let key = fmt!(\"uptime %?\", ptr::to_unsafe_ptr(&notify_port));\n        registrar.send(AddListener(copy key, notify_chan));\n\n        loop\n        {\n            let mut time = 0;\n            match comm::select2i(&mut notify_port, &mut control_port)\n            {\n                either::Left(_) =>\n                {\n                    error!(\"pushing new state\");\n                    let new_time = notify_port.recv();\n                    time = new_time;\n                    push.send(fmt!(\"retry: 5000\\ndata: %?\\n\\n\", time));\n                }\n                either::Right(_) =>\n                {\n                    match control_port.recv()\n                    {\n                        RefreshEvent =>\n                        {\n                            push.send(fmt!(\"retry: 5000\\ndata: %?\\n\\n\", time));\n                        }\n                        CloseEvent =>\n                        {\n                            error!(\"exiting sse client\");\n                            registrar.send(RemoveListener(key));\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    control_chan\n}\n\npub fn handle_connection(exit: comm::Port<()>, opener: OpenSse)\n{\n    let exit_cell = cell::Cell(exit);\n    error!(\"starting connection\");\n    do task::spawn_sched(task::ManualThreads(1))\n    {\n        let mut (sse_port, sse_chan) = comm::stream();\n        let sse_chan = comm::SharedChan::new(sse_chan);\n        let mut exit = exit_cell.take();\n\n        let mut sse_tasks = ~[];\n        let control_chan = opener(sse_chan);\n        vec::push(&mut sse_tasks, (~\"some path\", control_chan));\n\n        loop\n        {\n            match pipes::select2i(&mut exit, &mut sse_port)\n            {\n                either::Left(_) =>\n                {\n                    error!(\"exiting connection\");\n                    exit.recv();\n                    close_sses(&sse_tasks);\n                    break;\n                }\n                either::Right(_) =>\n                {\n                    let body = sse_port.recv();\n                    error!(\"received %s state\", body);\n                }\n            }\n        }\n    }\n}\n\npub fn close_sses(tasks: &SseTasks)\n{\n    error!(\"closing all sse\");\n    for tasks.each |&(_path, control_ch)|\n    {\n        control_ch.send(CloseEvent);\n    };\n    // With this commented out we get the \"you dun goofed\" failure.\n//    libc::funcs::posix88::uniextra::sleep(1);\n}\n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19084452/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21083782",
    "html_url": "https://github.com/rust-lang/rust/issues/4284#issuecomment-21083782",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/4284",
    "id": 21083782,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxMDgzNzgy",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-17T00:15:43Z",
    "updated_at": "2013-07-17T00:15:43Z",
    "body": "This is not a bug. At the bottom of the test case is the unsafe argument pattern `|&(_path, control_ch)|`, which illegally copies a noncopyable channel, resulting in double destruction. The program is no longer accepted (even after being re-modernized).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21083782/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21217474",
    "html_url": "https://github.com/rust-lang/rust/issues/4284#issuecomment-21217474",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/4284",
    "id": 21217474,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxMjE3NDc0",
    "user": {
      "login": "eholk",
      "id": 105766,
      "node_id": "MDQ6VXNlcjEwNTc2Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eholk",
      "html_url": "https://github.com/eholk",
      "followers_url": "https://api.github.com/users/eholk/followers",
      "following_url": "https://api.github.com/users/eholk/following{/other_user}",
      "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eholk/subscriptions",
      "organizations_url": "https://api.github.com/users/eholk/orgs",
      "repos_url": "https://api.github.com/users/eholk/repos",
      "events_url": "https://api.github.com/users/eholk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eholk/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-18T21:48:02Z",
    "updated_at": "2013-07-18T21:48:02Z",
    "body": "I'm glad to see cases I thought were impossible are apparently impossible.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21217474/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
