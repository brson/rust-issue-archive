[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32815303",
    "html_url": "https://github.com/rust-lang/rust/issues/11695#issuecomment-32815303",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11695",
    "id": 32815303,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODE1MzAz",
    "user": {
      "login": "liigo",
      "id": 346530,
      "node_id": "MDQ6VXNlcjM0NjUzMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/346530?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/liigo",
      "html_url": "https://github.com/liigo",
      "followers_url": "https://api.github.com/users/liigo/followers",
      "following_url": "https://api.github.com/users/liigo/following{/other_user}",
      "gists_url": "https://api.github.com/users/liigo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/liigo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/liigo/subscriptions",
      "organizations_url": "https://api.github.com/users/liigo/orgs",
      "repos_url": "https://api.github.com/users/liigo/repos",
      "events_url": "https://api.github.com/users/liigo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/liigo/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-21T02:08:35Z",
    "updated_at": "2014-01-21T02:08:35Z",
    "body": "Drop?\n\n2014/1/21 Bryan Murphy notifications@github.com\n\n> I can't always guarantee that users are going to properly use a library\n> (calling init methods, cleanup methods, etc.).\n> \n> Occasionally things die horribly and you want to provide stronger\n> guarantees about when things fail.\n> \n> Is there a way to hook up to an exit signal of sorts to execute code when\n> a program exits regardless of the exit mechanism? Something like Python\n> atexit?\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/mozilla/rust/issues/11695\n> .\n\n## \n\nby _Liigo_, http://blog.csdn.net/liigo/\nGoogle+  https://plus.google.com/105597640837742873343/\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32815303/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32819004",
    "html_url": "https://github.com/rust-lang/rust/issues/11695#issuecomment-32819004",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11695",
    "id": 32819004,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODE5MDA0",
    "user": {
      "login": "bmurphy1976",
      "id": 270488,
      "node_id": "MDQ6VXNlcjI3MDQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/270488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bmurphy1976",
      "html_url": "https://github.com/bmurphy1976",
      "followers_url": "https://api.github.com/users/bmurphy1976/followers",
      "following_url": "https://api.github.com/users/bmurphy1976/following{/other_user}",
      "gists_url": "https://api.github.com/users/bmurphy1976/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bmurphy1976/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bmurphy1976/subscriptions",
      "organizations_url": "https://api.github.com/users/bmurphy1976/orgs",
      "repos_url": "https://api.github.com/users/bmurphy1976/repos",
      "events_url": "https://api.github.com/users/bmurphy1976/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bmurphy1976/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-21T03:41:49Z",
    "updated_at": "2014-01-21T03:41:49Z",
    "body": "By Drop do you mean the Drop destructor trait?  I've used that to set a \"static mut Option<>\" variable, however the Drop destructor does not run on exit and I was told on irc that this was likely going to be disallowed in the future. \n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32819004/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32834967",
    "html_url": "https://github.com/rust-lang/rust/issues/11695#issuecomment-32834967",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11695",
    "id": 32834967,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODM0OTY3",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-21T10:04:51Z",
    "updated_at": "2014-01-21T10:04:51Z",
    "body": "An `atexit` handler only runs when you can a specific `exit` function tied to it. A user could always just run out of memory (causing an `abort`) or call `abort` themselves.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32834967/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32835855",
    "html_url": "https://github.com/rust-lang/rust/issues/11695#issuecomment-32835855",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11695",
    "id": 32835855,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODM1ODU1",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-21T10:18:10Z",
    "updated_at": "2014-01-21T10:18:30Z",
    "body": "@bmurphy1976 have you considered designing your library so that one must pass around a `Context` struct in order to use its core methods?  Then the type system would force the user to call your library's `init` function (since that would be how they would get their hands on a context), and you would implement the `Drop` trait on the context struct.\n\nAlternatively, if you do not want to thread a context argument through your program logic, an alternative is to make the entry point of your library take a proc that it invokes for the rest of the program.  In other words, a single instance of continuation-passing style (CPS), but without CPS-transforming the whole program.  Then that initialization routine has a local variable at the base of the stack, and you put the impl of `Drop` on that, so that when the program either returns or fails, your destructor runs.\n\nBasically I'm just describing a couple ways that you could revise your library design so that you _would_ be able to use the `Drop` trait.\n\n---\n\n(As for the feature request itself, I'm ambivalent about whether to add this particular feature.  If people find it useful then I will not object, but I'm not yet convinced this is dire need for it in the runtime.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32835855/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32894629",
    "html_url": "https://github.com/rust-lang/rust/issues/11695#issuecomment-32894629",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11695",
    "id": 32894629,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODk0NjI5",
    "user": {
      "login": "bmurphy1976",
      "id": 270488,
      "node_id": "MDQ6VXNlcjI3MDQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/270488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bmurphy1976",
      "html_url": "https://github.com/bmurphy1976",
      "followers_url": "https://api.github.com/users/bmurphy1976/followers",
      "following_url": "https://api.github.com/users/bmurphy1976/following{/other_user}",
      "gists_url": "https://api.github.com/users/bmurphy1976/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bmurphy1976/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bmurphy1976/subscriptions",
      "organizations_url": "https://api.github.com/users/bmurphy1976/orgs",
      "repos_url": "https://api.github.com/users/bmurphy1976/repos",
      "events_url": "https://api.github.com/users/bmurphy1976/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bmurphy1976/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-21T15:23:22Z",
    "updated_at": "2014-01-21T15:23:22Z",
    "body": "Thanks.  I've considered the context approach and I'm not a big fan of the CPS approach (for this particular problem anyway). \n\nAt the moment I'm coming from the perspective of designing a wrapper for a very common C library.  Ultimately, I would want to balance \"ensuring things are done right\" with \"the simplest/easiest to use API possible.\"  \n\nAsking users to pass around a context everywhere, manually clean up on exit, or use CPS passing style are all \"busywork\" to me.   Sometimes, our users just want to call a URL and fetch a json file.  All this init, teardown, cleanup, nonsense is ceremony.\n\nAnyway, something to consider.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32894629/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/37523612",
    "html_url": "https://github.com/rust-lang/rust/issues/11695#issuecomment-37523612",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11695",
    "id": 37523612,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3NTIzNjEy",
    "user": {
      "login": "dcbishop",
      "id": 284268,
      "node_id": "MDQ6VXNlcjI4NDI2OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/284268?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dcbishop",
      "html_url": "https://github.com/dcbishop",
      "followers_url": "https://api.github.com/users/dcbishop/followers",
      "following_url": "https://api.github.com/users/dcbishop/following{/other_user}",
      "gists_url": "https://api.github.com/users/dcbishop/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dcbishop/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dcbishop/subscriptions",
      "organizations_url": "https://api.github.com/users/dcbishop/orgs",
      "repos_url": "https://api.github.com/users/dcbishop/repos",
      "events_url": "https://api.github.com/users/dcbishop/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dcbishop/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-03-13T11:42:28Z",
    "updated_at": "2014-03-13T11:45:31Z",
    "body": "I'm considering this problem myself due to SDL requiring initialization of it's subsystems and needing to have sdl_Quit called at exit.\n\nFor my current approach I'm considering making a static. mutex locked reference count of objects using SDL and putting the code in the objects drop function that only runs when it's the last reference. Does require a little bit of unsafe code but other than that should work.\n\nMy main concern is whether or not SDL can be reinitialized after SDL_Quit is called (There are also functions like SDL_VideoInit and SDL_VideoQuit which could give more fine grained control over everything).\n\n@pnkfelix \nI was considering the context approach, but nothing would prevent someone creating 2 contexts and destroying one of them causing the global deinitilization stuff to fire while leaving a context that expects everything to still be initialized.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/37523612/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/58008774",
    "html_url": "https://github.com/rust-lang/rust/issues/11695#issuecomment-58008774",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11695",
    "id": 58008774,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU4MDA4Nzc0",
    "user": {
      "login": "eddyb",
      "id": 77424,
      "node_id": "MDQ6VXNlcjc3NDI0",
      "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eddyb",
      "html_url": "https://github.com/eddyb",
      "followers_url": "https://api.github.com/users/eddyb/followers",
      "following_url": "https://api.github.com/users/eddyb/following{/other_user}",
      "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions",
      "organizations_url": "https://api.github.com/users/eddyb/orgs",
      "repos_url": "https://api.github.com/users/eddyb/repos",
      "events_url": "https://api.github.com/users/eddyb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eddyb/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-10-06T12:17:59Z",
    "updated_at": "2014-10-06T12:17:59Z",
    "body": "@dcbishop You could use an `Once` (or an `AtomicBool`) in a `static mut` to ensure only one context can exist at any given time.\nAfter #17718 is fully implemented, such code could be safe, AFAIK.\n\nAs for the proposed feature, it seems similar to global destructors (which would require an RFC, but many devs are opposed to it, so I doubt it has much of a chance).\nHowever, our TLD (`task_local` data) allows destructors (that run on task death, but not aborts), so that may be used instead (where thread locality is applicable/helpful).\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/58008774/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/71138096",
    "html_url": "https://github.com/rust-lang/rust/issues/11695#issuecomment-71138096",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11695",
    "id": 71138096,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcxMTM4MDk2",
    "user": {
      "login": "steveklabnik",
      "id": 27786,
      "node_id": "MDQ6VXNlcjI3Nzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/steveklabnik",
      "html_url": "https://github.com/steveklabnik",
      "followers_url": "https://api.github.com/users/steveklabnik/followers",
      "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}",
      "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions",
      "organizations_url": "https://api.github.com/users/steveklabnik/orgs",
      "repos_url": "https://api.github.com/users/steveklabnik/repos",
      "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/steveklabnik/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-23T02:27:29Z",
    "updated_at": "2015-01-23T02:27:29Z",
    "body": "I'm pulling a massive triage effort to get us ready for 1.0. As part of this, I'm moving stuff that's wishlist-like to the RFCs repo, as that's where major new things should get discussed/prioritized.\n\nThis issue has been moved to the RFCs repo: rust-lang/rfcs#712\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/71138096/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
