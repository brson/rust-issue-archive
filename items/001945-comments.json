[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/4425610",
    "html_url": "https://github.com/rust-lang/rust/issues/1945#issuecomment-4425610",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1945",
    "id": 4425610,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MjU2MTA=",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-03-09T22:04:20Z",
    "updated_at": "2012-03-09T22:04:20Z",
    "body": "I'd differentiate cases here.\n- For functions where the partial-ness arises from failure to handle sparse refinements of relatively dense and pervasive input datatypes (out of range integers, wrong-case options, etc.) I'd prefer to `fail` for now and work on ways of possibly expressing static refinement types at the typestate level, in a way that's not too clunky for the user.\n- For functions that interface with the OS or unpredictable environment, I'd like to `fail` when they fail.\n- For functions where the partial-ness is either based on user-provided helper functions (find, filter, etc.) or associative queries of predictably-sparse input/key domains (hashmaps or such) I think it's more reasonable to provide versions that return options.\n\nThe basis of this preference is, in a word, \"frequency\". Datatypes involved in the first set are pervasive (numbers, containers), have a lot of operations, and most operations fail on few and sparsely-distributed cases (0, empty vector, out-of-range index) relative to the dense set of successful cases. IOW these are cases most easily understood as exceptions-to-a-rule. Currently we model exceptions-to-rules (in terms of proportion) as failures, so I'd carry on with that.\n\nI understand that frequency is not always easy to judge, and sometimes you'll want \"both interfaces\" (hashmaps I think usually have a failing and option-returning variant). When frequency is hard to judge, provision of one or the other, or both, becomes more a matter of taste. I think it's generally ok to support both if a user asks for both, in which case we're faced with an even smaller question: what to name them when providing both. For this I think the one that returns non-option should be the shorter of the two names -- that is, provide `foo` and `maybe_foo` -- because each function appeals to a different audience. The one that fails appeals to the programmer who prefers \"implicit, quiet, dynamic code\"; the one that is more work to call appeals to the programmer who prefers \"explicit, bureaucratic, static\" code.\n\nAside from all that, I also want to reiterate, when `fail` is unacceptable in the first two cases, my general wariness about encoding very-rare-frequency exceptional cases as `option` or `result` in the libraries. I don't think reinventing monadic style in rust is a good path to go down. It's expensive-by-default at runtime, and produces compositionality problems that take extra machinery to solve. If \"handling\" very-exceptional cases (rather than magnifying them as faults and crashing the subsystem) remains an important behavior people really want to support, I will suggest as I did last year that we revive the earlier non-unwinding signal/handler system I had in earlier versions of rust (similar to the system in Mesa).\n\nThe design is sketched here:\n\nhttps://mail.mozilla.org/pipermail/rust-dev/2011-November/000999.html\n\nIt's important to understand that this design works quite differently from exceptions. Handlers are dynamically scoped as in exceptions, but It never unwinds unless it's failing, and failure remains idempotent. Non-failure does not unwind, just recovers at the signal site.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/4425610/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/4970587",
    "html_url": "https://github.com/rust-lang/rust/issues/1945#issuecomment-4970587",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1945",
    "id": 4970587,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NzA1ODc=",
    "user": {
      "login": "kud1ing",
      "id": 391975,
      "node_id": "MDQ6VXNlcjM5MTk3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/391975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kud1ing",
      "html_url": "https://github.com/kud1ing",
      "followers_url": "https://api.github.com/users/kud1ing/followers",
      "following_url": "https://api.github.com/users/kud1ing/following{/other_user}",
      "gists_url": "https://api.github.com/users/kud1ing/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kud1ing/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kud1ing/subscriptions",
      "organizations_url": "https://api.github.com/users/kud1ing/orgs",
      "repos_url": "https://api.github.com/users/kud1ing/repos",
      "events_url": "https://api.github.com/users/kud1ing/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kud1ing/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-04-05T08:35:20Z",
    "updated_at": "2012-04-05T08:35:36Z",
    "body": "Would it be possible or even sensible for Rust to have return-type polymorphism?\nThat would allow a `head` to return an `option<T>` and an unsafe `head` which returns a `T`.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/4970587/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/4970769",
    "html_url": "https://github.com/rust-lang/rust/issues/1945#issuecomment-4970769",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1945",
    "id": 4970769,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NzA3Njk=",
    "user": {
      "login": "kud1ing",
      "id": 391975,
      "node_id": "MDQ6VXNlcjM5MTk3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/391975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kud1ing",
      "html_url": "https://github.com/kud1ing",
      "followers_url": "https://api.github.com/users/kud1ing/followers",
      "following_url": "https://api.github.com/users/kud1ing/following{/other_user}",
      "gists_url": "https://api.github.com/users/kud1ing/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kud1ing/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kud1ing/subscriptions",
      "organizations_url": "https://api.github.com/users/kud1ing/orgs",
      "repos_url": "https://api.github.com/users/kud1ing/repos",
      "events_url": "https://api.github.com/users/kud1ing/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kud1ing/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-04-05T08:49:38Z",
    "updated_at": "2012-04-05T08:52:04Z",
    "body": "When i read \"very-rare-frequency exceptional cases\" i understand this as \"such problems will almost never occur, we should not bother too much\". Do i misread you here?\n\nI wonder because similar complains regarding functions like `head` are raised again and again in the Haskell world:\nhttp://www.reddit.com/r/haskell/comments/lf71l/deprecate_preludehead_and_partial_functions/\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/4970769/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/4992201",
    "html_url": "https://github.com/rust-lang/rust/issues/1945#issuecomment-4992201",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1945",
    "id": 4992201,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5OTIyMDE=",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-04-06T08:17:41Z",
    "updated_at": "2012-04-06T08:17:41Z",
    "body": "```\nWhen i read \"very-rare-frequency exceptional cases\" i understand this as\n\"such problems will almost never occur, we should not bother too much\".\nDo i misread you here?\n```\n\nYes, you are misreading. I'm not saying they're no big deal; I'm saying that the mechanism of \"returning an option\" for functions with very-rare failure modes is sufficiently unpleasant that we have more language-engineering to do to solve it. I think using options, like using strings, booleans or integers, is a matter of taste; having the flexible and useful hammer of sum types tempts us to view any \"finite set of alternatives\" problem as a potential nail. I don't think returning option types for all failure cases (and combining them together when there are multiple forms of failure, a la multiple nested exception monads) is always the right approach. It's too awkward for casual users on interfaces that rarely fail. We need a different, more subtle technique for those cases. I have suggested a couple. I'm open to others.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/4992201/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/5105972",
    "html_url": "https://github.com/rust-lang/rust/issues/1945#issuecomment-5105972",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1945",
    "id": 5105972,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMDU5NzI=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-04-13T00:12:55Z",
    "updated_at": "2012-04-13T00:12:55Z",
    "body": "I don't see clear consensus on this and it seems like we have plenty to do for 1.0, so I suggest we postpone this discussion.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/5105972/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/9998187",
    "html_url": "https://github.com/rust-lang/rust/issues/1945#issuecomment-9998187",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1945",
    "id": 9998187,
    "node_id": "MDEyOklzc3VlQ29tbWVudDk5OTgxODc=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-11-01T22:17:16Z",
    "updated_at": "2012-11-01T22:17:16Z",
    "body": "Closing since @graydon 's condition system is now checked in.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/9998187/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
