[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/5265078",
    "html_url": "https://github.com/rust-lang/rust/issues/2267#issuecomment-5265078",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/2267",
    "id": 5265078,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjUwNzg=",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-04-22T02:36:26Z",
    "updated_at": "2012-04-22T02:39:16Z",
    "body": "_TL;DR_ I agree we need global data, possibly a mutex type. Let's push libraries as far as we can before adding too many unloved language features.\n\nThis is similar to the problem that @olsonjeffery is encountering with the uv bindings. With uv, the standard library needs access to a single global resource (a uv loop) that is available to any task, must be initialized zero or one times, and shutdown when the runtime exits.\n\nThe solution we are currently using uses two library functions to create a lazily-initialized, globally accessible task.\n\n### What uv is trying to do\n\nThis is how the resource is initialized:\n- Whenever the uv library gets access to the global uv loop it does so by sending messages to another task\n- It gets access to that task by requesting a channel from the `chan_from_global_ptr` function, which takes a pointer to a globally-known memory location and returns a channel\n- If `chan_from_global_ptr` does not find an existing channel handle at the global ptr location it creates a task and provides it a port to listen on, returning the channel. It's guaranteed to only do this once ever, across all threads.\n\nThis is how the resource is deinitialized:\n- Once the uv task is spawned it converts itself into a \"weak\" task using the `weaken_task` function\n- While weakened the task no longer counts toward the kernel's list of live tasks\n- When all normal tasks exit the uv task is told to exit via a channel, it cleans up the global resource, and the runtime exits\n\nThis could work for other cases too. For instance, we discussed earlier on IRC how it could be used for a getenv/setenv daemon. It may also work for initializing crypto libraries and serializing access to them if necessary.\n\n### What ssl could do similarly\n\nHere's how we could possibly use these functions to provide safe access to a crypto library that requires initialization, deinitialization and isn't thread safe if we allow for one rule\n\n> All native crypto calls are done on a special-purpose single-threaded scheduler.\n> We may use any number of tasks, but they all must run on this scheduler.\n\nWe would guarantee single initialization and deinitialization the same way as uv. And I could imagine a crypto API that takes a unique closure and lets you execute arbitrary calls within the context of the crypto scheduler, then further APIs that dress that up in synchronous function calls.\n\nIf being forced into another task to do crypto is truly intolerable then we would need some kind of mutex as you suggest.\n\n### Global data\n\nEven the scheme I'm using requires access to global data; there is clearly a need. The way uv handles it is by stashing a word-sized global in the runtime kernel, but this isn't a solution for everybody. Probably unsafe global variables is inevitable.\n\nThe one thing that really weirds me out about this is that this language will allow rust data to \"leak\" out of the runtime's control in a way that feels different from any other part of the language. In particular, if there are two Rust runtimes running at the same time, then they both will see the same global data. For the purpose of most libraries this means they will also need to coordinate truly global initialization and deinitialization between runtimes and shield runtimes' data from each other.\n\nOf course we can't actually run multiple runtimes, but the runtime will be embeddable, and I don't want to be one of these lame libraries that isn't threadsafe.\n\n### Rust mutexes\n\nIt's come up a few times now where it would be nice to have a mutex in Rust. We can't just use pthread mutexes because they don't understand the Rust scheduler (if the scheduler deschedules a task while it holds a lock then ... I can't even imagine the consequences but surely they aren't good).\n\nI have not put much thought into it yet because I think we should push actor-based programming as far as we can. Most of the time when you want a lock the code can be expressed with actors. Tasks and messages are the bet we've made. We can create inefficient locks on top of tasks where synchronization is really easier to express with locks. If we find that we must have fast mutexes then it will require serious thinking.\n\n### Static initialization\n\nPlease let's resist adding this to the language with our very most. I believe we can solve this in the library for many use cases.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/5265078/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/5265442",
    "html_url": "https://github.com/rust-lang/rust/issues/2267#issuecomment-5265442",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/2267",
    "id": 5265442,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjU0NDI=",
    "user": {
      "login": "erickt",
      "id": 84711,
      "node_id": "MDQ6VXNlcjg0NzEx",
      "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/erickt",
      "html_url": "https://github.com/erickt",
      "followers_url": "https://api.github.com/users/erickt/followers",
      "following_url": "https://api.github.com/users/erickt/following{/other_user}",
      "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/erickt/subscriptions",
      "organizations_url": "https://api.github.com/users/erickt/orgs",
      "repos_url": "https://api.github.com/users/erickt/repos",
      "events_url": "https://api.github.com/users/erickt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/erickt/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-04-22T03:54:32Z",
    "updated_at": "2012-04-22T03:54:32Z",
    "body": "Great response. I agree I'd hate to have static initialization. \n\nThe globally accessible, lazily created task would be perfect for these SSL libraries. I believe all I'd need really is something like:\n\n```\nexport ctx::{};\n\nenum ctx { token }\nfn gnutls_init() -> ctx {\n    let ch = spawn_global_unique { |token_port|\n        weaken_task() { |weak_exit_port|\n            libgnutls::gnutls_global_init();\n\n            let mut continue = true;\n            while continue {\n                continue = either::either(\n                    { |exit| false },\n                    { |token_chan| comm::send(token_chan, token) },\n                    comm::select2(weak_exit_port, token_port);\n            }\n\n            libgnutls::gnutls_global_deinit();\n        }\n    };\n\n    comm::recv(ch)\n}\n\nfn gnutls_certificate_allocate_credentials(ctx: ctx) { ... }\n```\n\nWhere `spawn_global_unique` is my hypothetical function that only runs once. Rust's runtime hide away allocating a the global pointer for me.\n\nI don't think we need to run the SSL functions inside their own thread though. Beyond synchronizing the init functions, the rest of the API is thread safe, with one exception. The SSL socket wrappers can't be used by more than one thread at a time, but we can already protect against that in rust.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/5265442/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/16896816",
    "html_url": "https://github.com/rust-lang/rust/issues/2267#issuecomment-16896816",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/2267",
    "id": 16896816,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2ODk2ODE2",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-04-24T00:02:01Z",
    "updated_at": "2013-04-24T00:02:01Z",
    "body": "I think with unsafe global data the lazy initialization problem is solved trivially with a global mutex and a flag. Global shutdown is trickier, especially if you assume that a single process may host multiple Rust 'runtime' instances (which I do).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/16896816/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/16897158",
    "html_url": "https://github.com/rust-lang/rust/issues/2267#issuecomment-16897158",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/2267",
    "id": 16897158,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2ODk3MTU4",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-04-24T00:05:14Z",
    "updated_at": "2013-04-24T00:05:14Z",
    "body": "I'm going to close this because I think any customizable before-main initialization is a non-starter, and the other possible solutions either exist or are planned. `core::unstable::global` can be used to do lazy initialization per-runtime (which is usually the same as per-process), and unsafe globals (and therefore global mutexes) are on the drawing board.\n\nFeel free to reopen if you disagree.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/16897158/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
