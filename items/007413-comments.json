[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22890842",
    "html_url": "https://github.com/rust-lang/rust/issues/7413#issuecomment-22890842",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7413",
    "id": 22890842,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyODkwODQy",
    "user": {
      "login": "emberian",
      "id": 704250,
      "node_id": "MDQ6VXNlcjcwNDI1MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emberian",
      "html_url": "https://github.com/emberian",
      "followers_url": "https://api.github.com/users/emberian/followers",
      "following_url": "https://api.github.com/users/emberian/following{/other_user}",
      "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emberian/subscriptions",
      "organizations_url": "https://api.github.com/users/emberian/orgs",
      "repos_url": "https://api.github.com/users/emberian/repos",
      "events_url": "https://api.github.com/users/emberian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emberian/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-19T17:52:32Z",
    "updated_at": "2013-08-19T17:52:32Z",
    "body": "Cannot reproduce with:\n\n``` rust\nuse std::io;\nuse ptrace::word;\n\nmod posix {\n    use std::libc;\n    use std::os;\n    use std::ptr;\n    use std::str;\n    use std::vec;\n\n    mod c {\n        use std::libc;\n\n        extern {\n            fn fork() -> libc::pid_t;\n            fn exit(status: libc::c_int) -> !;\n            fn waitpid(pid: libc::pid_t, status: *libc::c_int, flags: libc::c_int) -> libc::c_int;\n            fn execvp(file: *libc::c_char, argv: **libc::c_char) -> !;\n        }\n    }\n\n    pub enum ForkResult {\n        ForkFailure(int),\n        ForkChild,\n        ForkParent(int),\n    }\n\n    pub enum WaitPidResult {\n        WaitPidFailure(int),\n        WaitPidSuccess(int, int),\n    }\n\n    pub fn fork() -> ForkResult {\n        unsafe {\n            let pid = c::fork();\n\n            match pid {\n                -1 => ForkFailure(os::errno()),\n                0 => ForkChild,\n                pid => ForkParent(pid as int),\n            }\n        }\n    }\n\n    pub fn waitpid(pid: int, flags: int) -> WaitPidResult {\n        unsafe {\n            let status : libc::c_int = 0;\n\n            let pid = c::waitpid(pid as libc::pid_t, &status as *libc::c_int, flags as libc::c_int);\n\n            if pid == -1 {\n                WaitPidFailure(os::errno())\n            } else {\n                WaitPidSuccess(pid as int, status as int)\n            }\n        }\n    }\n\n    // this is probably pretty awful...\n    fn str_array_to_char_pp(ary: &[~str], callback: &fn(**libc::c_char)) {\n        fn helper_fn(ptrs: &mut ~[*libc::c_char], ary: &[~str], callback: &fn(**libc::c_char)) {\n            match ary {\n                [] => {\n                    ptrs.push(ptr::null());\n                    callback(vec::raw::to_ptr(*ptrs));\n                },\n                    [ref head, ..tail] => {\n                        do head.to_c_str().with_ref() |raw_str| {\n                            ptrs.push(raw_str);\n                            helper_fn(ptrs, tail, |c| callback(c));\n                        }\n                    },\n            }\n        }\n\n        let mut ptrs : ~[*libc::c_char] = vec::with_capacity(ary.len());\n\n        helper_fn(&mut ptrs, ary, callback);\n    }\n\n    pub fn exec(command_and_args: &[~str]) {\n        unsafe {\n            do command_and_args[0].to_c_str().with_ref() |command| {\n                do str_array_to_char_pp(command_and_args) |args| {\n                    c::execvp(command, args);\n                }\n            }\n        }\n    }\n\n    pub fn exit(status: int) -> ! {\n        unsafe {\n            c::exit(status as libc::c_int)\n        }\n    }\n\n    pub static SIGTRAP : int = 5;\n}\n\nmod ptrace {\n    use std::libc;\n    use std::ptr;\n\n    extern {\n        fn ptrace(request: libc::c_int, pid: libc::pid_t, addr: *libc::c_void, data: *libc::c_void) -> libc::c_long;\n    }\n\n    pub type word = u64;\n\n    static TRACEME : libc::c_int = 0;\n    static SYSCALL : libc::c_int = 24;\n    static SETOPTIONS : libc::c_int = 0x4200;\n\n    pub fn trace_me() {\n        unsafe {\n            ptrace(TRACEME, 0, ptr::null(), ptr::null());\n        }\n    }\n\n    pub fn setoptions(pid: int, options: int) {\n        unsafe {\n            ptrace(SETOPTIONS, pid as libc::pid_t, ptr::null(), options as *libc::c_void);\n        }\n    }\n\n    pub fn syscall(pid: int) {\n        unsafe {\n            ptrace(SYSCALL, pid as libc::pid_t, ptr::null(), ptr::null());\n        }\n    }\n\n    pub static TRACESYSGOOD : int = 0x00000001;\n    pub static TRACEFORK : int = 0x00000002;\n    pub static TRACEEXEC : int = 0x00000010;\n}\n\nenum TraceEvent {\n    SystemCall {\n        syscall_no : word,\n        arguments : (word, word, word, word, word, word),\n    },\n    Other,\n}\n\nfn init_trace(child_pid: int) {\n    match posix::waitpid(child_pid, 0) {\n        posix::WaitPidFailure(_) => (),\n        posix::WaitPidSuccess(pid, status) => {\n            if status & posix::SIGTRAP != 0 {\n                ptrace::setoptions(pid, ptrace::TRACEFORK | ptrace::TRACESYSGOOD | ptrace::TRACEEXEC);\n                ptrace::syscall(pid);\n            }\n        },\n    }\n}\n\nfn resume_trace(child_pid: int) {\n    ptrace::syscall(child_pid);\n}\n\nfn next_trace(callback: &fn(int, TraceEvent)) -> bool {\n    loop {\n        let result = posix::waitpid(-1, 0);\n\n        match result {\n            posix::WaitPidFailure(_) => return false,\n            posix::WaitPidSuccess(pid, status) => {\n                if ((status >> 8) & (0x80 | posix::SIGTRAP)) != 0 {\n                    callback(pid, SystemCall {\n                             syscall_no: 0,\n                             arguments: ( 0, 0, 0, 0, 0, 0 ),\n                             });\n                } else {\n                    callback(pid, Other);\n                }\n                resume_trace(pid);\n            },\n        }\n    }\n}\n\nfn run_parent(child_pid: int) {\n    init_trace(child_pid);\n\n    do next_trace() |_, event| {\n        match event {\n            // XXX changing _args to _ fixes the segfault (?!?!?!)\n            SystemCall { syscall_no: _, arguments: _args } => {\n            }\n            _ => (),\n        };\n    };\n}\n\nfn main() {\n    let result = posix::fork();\n\n    match result {\n        posix::ForkChild => {\n            ptrace::trace_me();\n\n            posix::exec([~\"ls\"]);\n            posix::exit(255);\n        }\n        posix::ForkFailure(_) => {\n            io::println(\"An error occurred\");\n        }\n        posix::ForkParent(child_pid) => {\n            run_parent(child_pid);\n        }\n    }\n}\n```\n\n@hoelzro  can you confirm?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22890842/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/23980596",
    "html_url": "https://github.com/rust-lang/rust/issues/7413#issuecomment-23980596",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7413",
    "id": 23980596,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzOTgwNTk2",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-09-07T03:21:07Z",
    "updated_at": "2013-09-07T03:21:07Z",
    "body": "Closing because I think that this is done now. A fair amount of work was done awhile back to fix `match` and related cases.\n\nIf you continue to run into problems though, feel free to comment/re-open!\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/23980596/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/23989514",
    "html_url": "https://github.com/rust-lang/rust/issues/7413#issuecomment-23989514",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7413",
    "id": 23989514,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzOTg5NTE0",
    "user": {
      "login": "hoelzro",
      "id": 107804,
      "node_id": "MDQ6VXNlcjEwNzgwNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/107804?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hoelzro",
      "html_url": "https://github.com/hoelzro",
      "followers_url": "https://api.github.com/users/hoelzro/followers",
      "following_url": "https://api.github.com/users/hoelzro/following{/other_user}",
      "gists_url": "https://api.github.com/users/hoelzro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hoelzro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hoelzro/subscriptions",
      "organizations_url": "https://api.github.com/users/hoelzro/orgs",
      "repos_url": "https://api.github.com/users/hoelzro/repos",
      "events_url": "https://api.github.com/users/hoelzro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hoelzro/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-09-07T08:57:17Z",
    "updated_at": "2013-09-07T08:57:17Z",
    "body": "@alexcrichton Thanks for following up on this; I had forgotten that I'd created this issue!  I have \"ported\" my code to Rust HEAD, and it now runs without segfaults.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/23989514/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
