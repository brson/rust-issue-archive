[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19269868",
    "html_url": "https://github.com/rust-lang/rust/issues/7059#issuecomment-19269868",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7059",
    "id": 19269868,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE5MjY5ODY4",
    "user": {
      "login": "bstrie",
      "id": 865233,
      "node_id": "MDQ6VXNlcjg2NTIzMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bstrie",
      "html_url": "https://github.com/bstrie",
      "followers_url": "https://api.github.com/users/bstrie/followers",
      "following_url": "https://api.github.com/users/bstrie/following{/other_user}",
      "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions",
      "organizations_url": "https://api.github.com/users/bstrie/orgs",
      "repos_url": "https://api.github.com/users/bstrie/repos",
      "events_url": "https://api.github.com/users/bstrie/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bstrie/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-06-11T15:37:15Z",
    "updated_at": "2013-06-11T15:38:35Z",
    "body": "Define \"most specialized\". The one with the highest number of generic bounds? Then when you refactor your code to collapse several bounds into one via trait inheritance, you've silently changed the meaning of the program. So then perhaps you could count the number of generic bounds by recursively expanding each trait into the ones it inherits from... but now fussing with traits anywhere higher in the inheritance chain can again silently change which function is selected, except arguably worse because it's action-at-a-distance.\n\n\"First that matches\" also doesn't work, because non-closure functions have no concept of order. Note that this program works:\n\n``` rust\nfn main() {\n    foo();\n    bar();\n\n    fn bar() {\n        foo();\n        println(\"bar\");\n    }\n\n    fn foo() {\n        println(\"foo\");\n    }\n}\n```\n\nI'm not necessarily opposed to this idea, but there needs to be a concrete proposal that considers these complications.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19269868/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19270940",
    "html_url": "https://github.com/rust-lang/rust/issues/7059#issuecomment-19270940",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7059",
    "id": 19270940,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE5MjcwOTQw",
    "user": {
      "login": "auroranockert",
      "id": 49616,
      "node_id": "MDQ6VXNlcjQ5NjE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/49616?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/auroranockert",
      "html_url": "https://github.com/auroranockert",
      "followers_url": "https://api.github.com/users/auroranockert/followers",
      "following_url": "https://api.github.com/users/auroranockert/following{/other_user}",
      "gists_url": "https://api.github.com/users/auroranockert/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/auroranockert/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/auroranockert/subscriptions",
      "organizations_url": "https://api.github.com/users/auroranockert/orgs",
      "repos_url": "https://api.github.com/users/auroranockert/repos",
      "events_url": "https://api.github.com/users/auroranockert/events{/privacy}",
      "received_events_url": "https://api.github.com/users/auroranockert/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-06-11T15:52:40Z",
    "updated_at": "2013-06-11T15:52:40Z",
    "body": "In this specific case it is quite obvious what would be the most specific trait, since Signed implies Ord, Zero, Neg<Self> and more.\n\nI would consider the following rules something to start discussing,\n1. Create a list of all generic fns with that name.\n2. Remove all fns that don't match the signature of the call.\n3. Remove from the list any fns with bounds that are implied by the bounds of another fn in the list.\n4. If there is more than one fn, throw an error.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19270940/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19273522",
    "html_url": "https://github.com/rust-lang/rust/issues/7059#issuecomment-19273522",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7059",
    "id": 19273522,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE5MjczNTIy",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-06-11T16:31:36Z",
    "updated_at": "2013-06-11T16:31:36Z",
    "body": "This is basically proposing something like the \"most specific instance\" rule in GHC when you pass in the `-fallow-overlapping-instances` flag. It may seem like a simple rule at first glance, but in GHC it has just caused more ambiguities (see http://web.cecs.pdx.edu/~jgmorris/pubs/morris-icfp2010-instances.pdf ). In general we should be paying attention to the trajectory of overlapping instances in Haskell when we consider these changes.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19273522/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19282308",
    "html_url": "https://github.com/rust-lang/rust/issues/7059#issuecomment-19282308",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7059",
    "id": 19282308,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE5MjgyMzA4",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-06-11T18:23:34Z",
    "updated_at": "2013-06-11T18:23:34Z",
    "body": "I like the idea of specializing functions, but it seems like there are other ways to do it. Most of the time you just want a version for `Bar + Foo` and then `Bar + !Foo`. Are trait bound complements something we could have?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19282308/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19284425",
    "html_url": "https://github.com/rust-lang/rust/issues/7059#issuecomment-19284425",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7059",
    "id": 19284425,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE5Mjg0NDI1",
    "user": {
      "login": "auroranockert",
      "id": 49616,
      "node_id": "MDQ6VXNlcjQ5NjE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/49616?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/auroranockert",
      "html_url": "https://github.com/auroranockert",
      "followers_url": "https://api.github.com/users/auroranockert/followers",
      "following_url": "https://api.github.com/users/auroranockert/following{/other_user}",
      "gists_url": "https://api.github.com/users/auroranockert/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/auroranockert/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/auroranockert/subscriptions",
      "organizations_url": "https://api.github.com/users/auroranockert/orgs",
      "repos_url": "https://api.github.com/users/auroranockert/repos",
      "events_url": "https://api.github.com/users/auroranockert/events{/privacy}",
      "received_events_url": "https://api.github.com/users/auroranockert/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-06-11T18:56:51Z",
    "updated_at": "2013-06-11T18:56:51Z",
    "body": "@thestinger Yeah, that is essentially the same thing as I want, just with different syntax.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19284425/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19327204",
    "html_url": "https://github.com/rust-lang/rust/issues/7059#issuecomment-19327204",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7059",
    "id": 19327204,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE5MzI3MjA0",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-06-12T13:59:50Z",
    "updated_at": "2013-07-02T00:00:19Z",
    "body": "In Haskell the reason it's impossible to have complements of constraints (or more generally to branch on the \"otherwise\" case in any way) is the open-world assumption. There's no way to rule out the possibility of an instance (`impl for`) being introduced in a different module. But this is tied in with the possibility of orphan instances in that language. Rust restricts `impls for` to the same crate as the trait or the same crate as the type, so if the compiler has full-crate knowledge of `impl`s (alternately if they're restricted to same `mod` instead of same crate), it could determine with certainty when a trait is _not_ implemented. This could in theory allow trait complements, and from there full boolean expressions on traits, because you can implement `or` with `and` and `not`. At that point it probably makes more sense to actually rename `+` to `&&` and introduce `||`.\n\nWhat this ticket is asking for is actually more than that, because it's also asking for a kind of implicit C++-style overloading on functions. We already have implicit overloading for the `self` argument of method calls, so I can't really say \"it's better to keep overloading restricted to traits\", but in any case it's a separate issue.\n\nConsidering only the trait complements / boolean trait expressions half of it, obviously `!Trait` would not have any methods you could call, nor `TraitA || TraitB`. But it would still be useful:\n- The `impl for` overlap checker could take bounds into consideration, which would both increase expressiveness and reduce confusion: in Haskell the absence of this regularly confuses newcomers. This is basically (with a bit more boilerplate) what would allow expressing the `abs` example in the OP. You could also do things like a `maybe_to_str` that uses `ToStr` if there's an `impl` for it and returns `\"couldn't describe\"` or `None` otherwise, or whatever. Or with the current `Copy` (for implicitly copyable types) vs `Clone` (for explicit copies) situation, it would allow you to actually write a default `impl<T: Copy> Clone for T` without conflicting with other `impl`s of `Clone` for user-defined types that aren't implicitly copyable.\n- `||` is useless for \"normal\" traits, but it has utility with built-in ones: there's a few places around `RcMut`, `DeepClone`, and such where either a `Const` or an `Owned` bound would suffice to rule out cycles, but you can't provide separate `impl`s for both without conflicts. Here you could express it directly as `T: Const || Owned`.\n\nDrawbacks:\n- It adds more complexity to the language. Obviously.\n- Checking for conflicts between generic `impl`s -- whether both bounds can be satisfied at the same time -- seems to be the SAT problem, which is NP-complete. I don't know whether people would actually write `impl`s complex enough that this becomes a problem in practice.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/19327204/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22050795",
    "html_url": "https://github.com/rust-lang/rust/issues/7059#issuecomment-22050795",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7059",
    "id": 22050795,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMDUwNzk1",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-03T06:49:18Z",
    "updated_at": "2013-08-03T06:49:18Z",
    "body": "@bjz has [a proposal for overlapping impl precedence](https://gist.github.com/bjz/5855557); reproduced here for posterity:\n\n> One issue that limits the utility of traits is the fact that impling on the generic type `T` means that it is impossible to impl on anything else. Default methods will go some way to alleviating this, but it is still useful to have 'one impl to rule them all', then specialize on a per-type basis.\n> \n> ### Precedence Hierarchy for Trait Impls\n> \n> One option could be to have a precedence hierarchy for trait overloading. For example, in descending levels of precedence:\n> \n> | Precedence/Name | Examples |\n> | --- | --- |\n> | 1. Concrete types | `float`, `~str`, `(int, int)`, `Option<int>` |\n> | 2. Parameterized | `Option<T>`, `(T, int)`, `&[T]` |\n> | 3. Generic | `T`, `&T`, `~T`, `@T` |\n> \n> This could lead to complex resolve issues however, which could lead to increased compile times, and thorny edge cases. It also might be hard for users to reason about which implementation is being used.\n> \n> #### Errors\n> \n> `impl<T> Foo for (T, float, int)` `impl<T,U> Foo for (T, U, int)` would be ok. `impl<T,U> Foo for (T, float, U)` `impl<T,U> Foo for (T, U, int)` would give an error.\n> \n> ### Set operations for trait constraints?\n> \n> Impls for `T: Foo & !Bar`, `T: !Foo & Bar` could co-exist? Might be hard for a human to reason about in a large codebase.\n\n---\n\nI think the arguments about overlapping instances in Haskell don't fully apply because Rust doesn't have the (entire) open world assumption like Haskell. In particular, I believe that, for any \"pattern\" that overlaps, Rust can see all of the possibilities at once, because at least one of the trait or type have to be defined in the current crate. E.g. you _can't_ write\n\n``` rust\n// crate1.rs\ntrait Foo {}\nimpl<T,U> Foo for (T,U) {}\n\n// crate2.rs\nimpl<T> Foo for (T, int) {}\n\n// crate3.rs\nimpl<U> Foo for (float, U) {}\n```\n\nand so you can never have the situation where importing `crate3` (having imported `crate2` previously) suddenly makes it not compile/behave different.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22050795/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22054982",
    "html_url": "https://github.com/rust-lang/rust/issues/7059#issuecomment-22054982",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7059",
    "id": 22054982,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMDU0OTgy",
    "user": {
      "login": "chris-morgan",
      "id": 392868,
      "node_id": "MDQ6VXNlcjM5Mjg2OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/392868?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chris-morgan",
      "html_url": "https://github.com/chris-morgan",
      "followers_url": "https://api.github.com/users/chris-morgan/followers",
      "following_url": "https://api.github.com/users/chris-morgan/following{/other_user}",
      "gists_url": "https://api.github.com/users/chris-morgan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chris-morgan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chris-morgan/subscriptions",
      "organizations_url": "https://api.github.com/users/chris-morgan/orgs",
      "repos_url": "https://api.github.com/users/chris-morgan/repos",
      "events_url": "https://api.github.com/users/chris-morgan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chris-morgan/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-03T13:32:59Z",
    "updated_at": "2013-08-03T13:32:59Z",
    "body": "My own specific desire with it is very simple, to do with augmented assignment (#5992).\n\nGiven a trait definition like this:\n\n``` rust\npub trait AddAssign<RHS> {\n    #[inline]\n    fn add_assign(&mut self, rhs: &RHS);\n}\n```\n\nWhat I really want is simply this:\n\n``` rust\nimpl<LHS: Add<RHS, LHS>, RHS> AddAssign<RHS> for LHS {\n    fn add_assign(&mut self, rhs: &RHS) {\n        *self = *self + *rhs;\n    }\n}\n```\n\nThis has the effect of making `+=` work for any type where `+` works. But alas, this can't work at present.\n\nA couple of ideas of mine:\n- Have a `priority` attribute: it could have a default of 1, meaning that I could tack `#[priority = 0]` onto that `impl` block. Highest priority impl in scope wins\u2014if there is more than one highest, you get an error indicating you can alter the priority to prefer one over the other where both are satisfied. This is explicit, which might be good or bad. I think it'd work fine and it would get implementers to think about it and be aware of it, but if abused it could lead to surprises for users. The original example shown could then be like this:\n  \n  ``` rust\n  #[priority=2]\n  pub fn abs<T: Signed>(value: T) -> T { value.abs() }\n  #[priority=1]\n  pub fn abs<T: Ord + Zero + Neg<T>>(v: T) -> T { if v < Zero::zero() { v.neg() } else { v } }\n  ```\n  \n  This also leaves scope for a more intelligent, automatic solution later if it were deemed appropriate (the existence of the attribute could then trigger an error indicating how it's changed).\n- Use a boolean attribute `#[default_impl]`, indicating that it can be overridden by an `impl` unadorned by `#[default_impl]`. My own feeling is that this would satisfy the majority of cases where specialisation is really _really_ useful, but it's certainly not as powerful; it can't do the first example other than as a nasty hack.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22054982/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22145456",
    "html_url": "https://github.com/rust-lang/rust/issues/7059#issuecomment-22145456",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7059",
    "id": 22145456,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMTQ1NDU2",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-05T22:22:38Z",
    "updated_at": "2013-08-05T22:32:10Z",
    "body": "@huonw, good point. I believe you could still have that situation when importing different modules from the same crate? But maybe that's no longer concern-worthy? The other criticism levelled in the SO answer still holds: if upstream adds a new, more specific impl, that could silently change the behaviour of downstream code. It seems like a good idea to preserve the property that merely adding something new can't change the behaviour of something that already exists. I think this will be a problem with _any_ system where you have 'one impl to rule them all' that you can override on a per-case basis. Would it be so burdensome to have to write an empty `impl Trait for Type { }`, instead of it being fully automatic?\n\n(Apropos, GHC has a feature called [DefaultSignatures](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#class-default-signatures). Basically what that does is it lets you write a default implementation for a method with a more specific signature than the method itself (e.g. additional trait bounds), and the default is generated only if the more specific signature is satisfied. But you still have to declare the `impl`.)\n\nFWIW I think a system with explicitly negated traits and strict-but-taking-bounds-into-consideration overlap checking would _also_ allow similar problems:\n\n```\ntrait Trait1 { ... }\ntrait Trait2 { ... }\nimpl<T: Trait1> Trait2 for T { ... }\nimpl<T: !Trait1> Trait2 for T { ... } // these cannot possibly overlap, so our hypothetical compiler accepts it\n```\n\nNow if you add an `impl Trait1 for Foo`, that could cause code using `Foo: Trait2` to change behaviour. I'm not sure whether this is \"less bad\" in any way? (At least it's being somewhat more explicit about the logic...)\n\n@chris-morgan, two questions:\n- Would it be so awful if you had to write `impl<RHS> AddAssign<RHS> for LHS { }` for a given LHS that already impls `Add`?\n- Would it be tolerable if the \"default\" `AddAssign` impl you propose would be allowed, _and_ you could still add other impls, _but_ only for types that don't impl `Add` (so there's no overlap)? I think this is basically what you could get with the explicit-negation-and-fine-grained-overlap-checking scheme... (though as above that doesn't seem to be free of problems either).\n\nYour `#[default_impl]` idea would be similar to the GHC/Haskell status quo: what the `OverlappingInstances` language extension actually does is it sets a \"this instance is overlappable\" flag for the instances in that module. So it's opt-in, which is at least better than overlap being allowed globally. Might be the least-bad option if the use case is undeniable and we don't find a better solution.\n\nI believe Rust used to have explicit import/export of `impl`s, but that was dropped in favor of requiring global coherence. I'm wondering if some of the reasons behind that decision (which I'm not familiar with) might not also apply here?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22145456/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22152633",
    "html_url": "https://github.com/rust-lang/rust/issues/7059#issuecomment-22152633",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7059",
    "id": 22152633,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMTUyNjMz",
    "user": {
      "login": "chris-morgan",
      "id": 392868,
      "node_id": "MDQ6VXNlcjM5Mjg2OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/392868?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chris-morgan",
      "html_url": "https://github.com/chris-morgan",
      "followers_url": "https://api.github.com/users/chris-morgan/followers",
      "following_url": "https://api.github.com/users/chris-morgan/following{/other_user}",
      "gists_url": "https://api.github.com/users/chris-morgan/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chris-morgan/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chris-morgan/subscriptions",
      "organizations_url": "https://api.github.com/users/chris-morgan/orgs",
      "repos_url": "https://api.github.com/users/chris-morgan/repos",
      "events_url": "https://api.github.com/users/chris-morgan/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chris-morgan/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-06T01:22:14Z",
    "updated_at": "2013-08-06T01:22:14Z",
    "body": "@glehel:\n1. Is it so awful for people to need to write `#[deriving(Clone,DeepClone,Eq,IForgetWhatElseShouldGoHere)]`? There's argument about that, with many in favour of simplifying things because normally you _will_ want these things automatically filled in. `AddAssign` is the same: it doesn't tend to make sense for `x = x + y` to work and `x += y` not to work.\n   \n   Also, it does not end up simply `impl<RHS> AddAssign<RHS> for LHS;`, as the trait cannot have a default implementation; it would need to include the `fn add_assign(&mut self, rhs: &RHS) { *self = *self + *other; }`. That's one of the problems I perceive with the current implementation of default trait implementations: often it's quite reasonable for a trait _not_ to require constraints, but for a default implementation to require constraints; in this case, the best I can do for a default implementation is:\n   \n   ``` rust\n     pub trait AddAssign<RHS>: Add<RHS, Self> {\n         #[inline]\n         fn add_assign(&mut self, rhs: &RHS) {\n             *self = *self + *rhs;\n         }\n     }\n   ```\n   \n   ... but still, it is conceivable that one might have a type where they do not wish to implement `Add` (it might be an extremely expensive operation, and something like `+` would mask that) but do wish to implement `AddAssign` (as it can be implemented cheaply), so I don't like an implementation of `AddAssign<RHS>` to _require_ an implementation of `Add<RHS, Self>`, where there can be no good reason for it beyond the convenience of the default method.\n2. No, it would not be tolerable to only be able to overridde `AddAssign` if `Add` is not implemented. As a generalisation, if one is supported, both should be. (This isn't quite true, e.g. `&str` implements `Add` but cannot implement `AddAssign`, but if the bare type can be modified then it should be true.) However, while the default `AddAssign` impl will _work_ in most cases, it will almost never be quite the most efficient way to do it, as `AddAssign` can be an in-place modification\u2014e.g. for a `struct MyInt{ i: int }` one can do `self.i += other.i` rather than what effectively becomes `*self = *MyInt { i: self.i + other.i }`. As you can see, this could rapidly become more expensive.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22152633/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22153610",
    "html_url": "https://github.com/rust-lang/rust/issues/7059#issuecomment-22153610",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7059",
    "id": 22153610,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMTUzNjEw",
    "user": {
      "login": "glaebhoerl",
      "id": 1216629,
      "node_id": "MDQ6VXNlcjEyMTY2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glaebhoerl",
      "html_url": "https://github.com/glaebhoerl",
      "followers_url": "https://api.github.com/users/glaebhoerl/followers",
      "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}",
      "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions",
      "organizations_url": "https://api.github.com/users/glaebhoerl/orgs",
      "repos_url": "https://api.github.com/users/glaebhoerl/repos",
      "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glaebhoerl/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-06T01:50:49Z",
    "updated_at": "2013-08-06T01:50:49Z",
    "body": "@chris-morgan, wrt\n\n> That's one of the problems I perceive with the current implementation of default trait implementations: often it's quite reasonable for a trait not to require constraints, but for a default implementation to require constraints\n\nthat's exactly what GHC's `DefaultSignatures` allows. I'm not sure how it could be formulated for Rust; where in Haskell you'd write (try to ignore the IO noise):\n\n```\nclass AddAssign rhs self where\n    add_assign :: IORef self -> rhs -> IO () -- signature of method\n    default add_assign :: Add rhs self self => IORef self -> rhs -> IO () -- signature for default\n    add_assign self rhs = do\n        self' <- readIORef self\n        writeIORef self (add self' rhs)\n```\n\nif you try to translate that to Rust:\n\n```\ntrait AddAssign<RHS> {\n    fn add_assign(&mut self, rhs: &RHS); //method\n    fn add_assign<???>(&mut self, rhs: &RHS) { *self = *self + *rhs; } //default\n}\n```\n\nWhat goes in `???`? `Self: Add<RHS, Self>`? But AFAIK you can only introduce new type variables there, not put constraints on existing ones. (Would be nice to have an explicit `default` too, or some other way to make the meaning more obvious, but Rust doesn't have it as a keyword.)\n\nAnyways, the point is not to bikeshed syntax, I originally wanted to translate it into Rust to help explain what it does.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22153610/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22167748",
    "html_url": "https://github.com/rust-lang/rust/issues/7059#issuecomment-22167748",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7059",
    "id": 22167748,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMTY3NzQ4",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-06T09:35:11Z",
    "updated_at": "2013-08-06T09:35:11Z",
    "body": "FWIW, both @thestinger and I have also found uses for implementing a default method when `Self` implements a certain trait, without having to inherit from that trait. (i.e. In some instances one can provide a useful default, but not always.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22167748/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/41677559",
    "html_url": "https://github.com/rust-lang/rust/issues/7059#issuecomment-41677559",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7059",
    "id": 41677559,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxNjc3NTU5",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-04-29T13:48:39Z",
    "updated_at": "2014-04-29T13:48:39Z",
    "body": "This can & should be converted into a new-style RFC.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/41677559/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/41689234",
    "html_url": "https://github.com/rust-lang/rust/issues/7059#issuecomment-41689234",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7059",
    "id": 41689234,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxNjg5MjM0",
    "user": {
      "login": "japaric",
      "id": 5018213,
      "node_id": "MDQ6VXNlcjUwMTgyMTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/japaric",
      "html_url": "https://github.com/japaric",
      "followers_url": "https://api.github.com/users/japaric/followers",
      "following_url": "https://api.github.com/users/japaric/following{/other_user}",
      "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/japaric/subscriptions",
      "organizations_url": "https://api.github.com/users/japaric/orgs",
      "repos_url": "https://api.github.com/users/japaric/repos",
      "events_url": "https://api.github.com/users/japaric/events{/privacy}",
      "received_events_url": "https://api.github.com/users/japaric/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-04-29T15:14:52Z",
    "updated_at": "2014-04-29T15:14:52Z",
    "body": "I've been playing with vectors, matrices and BLAS, and I've encounter this issue repeatedly. See [this gist](https://gist.github.com/japaric/11401627) for an example.\n\nI've independently reach the solutions formulated by @chris-morgan in his first comment. Namely:\n- Annotate with #[fallback] the generic/weak implementation. This solves cases where two implementations collide, by ignoring the #[fallback] implementation.\n- The above idea can be extended with priorities, to solve the collision of three or more implementations. (But I have yet to encounter this situation in practice)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/41689234/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/56625034",
    "html_url": "https://github.com/rust-lang/rust/issues/7059#issuecomment-56625034",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7059",
    "id": 56625034,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2NjI1MDM0",
    "user": {
      "login": "rust-highfive",
      "id": 7378925,
      "node_id": "MDQ6VXNlcjczNzg5MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rust-highfive",
      "html_url": "https://github.com/rust-highfive",
      "followers_url": "https://api.github.com/users/rust-highfive/followers",
      "following_url": "https://api.github.com/users/rust-highfive/following{/other_user}",
      "gists_url": "https://api.github.com/users/rust-highfive/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rust-highfive/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rust-highfive/subscriptions",
      "organizations_url": "https://api.github.com/users/rust-highfive/orgs",
      "repos_url": "https://api.github.com/users/rust-highfive/repos",
      "events_url": "https://api.github.com/users/rust-highfive/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rust-highfive/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-09-24T04:59:27Z",
    "updated_at": "2014-09-24T04:59:27Z",
    "body": "This issue has been moved to the RFCs repo: rust-lang/rfcs#290\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/56625034/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
