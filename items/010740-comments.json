[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/29564093",
    "html_url": "https://github.com/rust-lang/rust/issues/10740#issuecomment-29564093",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10740",
    "id": 29564093,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI5NTY0MDkz",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-01T00:02:15Z",
    "updated_at": "2013-12-01T00:02:15Z",
    "body": "I have investigated how to implement `-ffunction-sections` and `-fdata-sections`, and to do this we need to call llvm's `TargetMachine::setFunctionSections(true)` and `TargetMachine::setDataSections(true)`, so from an implementation perspective these two optimizations are very easy to implement. I'm much more worried about the impact they have on compile times.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/29564093/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31438042",
    "html_url": "https://github.com/rust-lang/rust/issues/10740#issuecomment-31438042",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10740",
    "id": 31438042,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDM4MDQy",
    "user": {
      "login": "comex",
      "id": 47517,
      "node_id": "MDQ6VXNlcjQ3NTE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/47517?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/comex",
      "html_url": "https://github.com/comex",
      "followers_url": "https://api.github.com/users/comex/followers",
      "following_url": "https://api.github.com/users/comex/following{/other_user}",
      "gists_url": "https://api.github.com/users/comex/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/comex/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/comex/subscriptions",
      "organizations_url": "https://api.github.com/users/comex/orgs",
      "repos_url": "https://api.github.com/users/comex/repos",
      "events_url": "https://api.github.com/users/comex/events{/privacy}",
      "received_events_url": "https://api.github.com/users/comex/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-02T05:12:12Z",
    "updated_at": "2014-01-02T05:17:02Z",
    "body": "This affects me; I'm not sure how much 500K (see below) matters in the long run for my use cases (including a kernel module), but it's very far from paying only for what I use.  On OS X, the base size of a statically linked binary is:\n\n```\n% rustc -O a.rs; du -sh a\n2.6M    a\n```\n\n--link-args -dead_strip brings it down:\n\n```\n% rustc -O a.rs --link-args -dead_strip; du -sh a \n1.2M    a\n```\n\nUsing the libnative example at https://gist.github.com/anonymous/8162357 helps:\n\n```\n% rustc -O a.rs --link-args -dead_strip; du -sh a    \n568K    a\n```\n\nand -Z lto brings it down a bit more:\n\n```\n% rustc -O a.rs --link-args -dead_strip -Z lto; du -sh a\n472K    a\n```\n\nBut this is still way too high for my liking.  Most of the file is text:\n\n```\n % size /tmp/a\n__TEXT  __DATA  __OBJC  others  dec hex\n323584  28672   0   4295098368  4295450624  100076000\n```\n\nA lot of the functions seem to come from unused methods in traits like IoFactory, so it would be very nice (perhaps difficult?) to have some way to prune them from vtables.\n\nWith [rust-core](https://github.com/thestinger/rust-core) I get a 12K binary.  That's a fairly trivial result in some sense, since it just means that without any pretty printing for failure, _everything_ has been optimized away, but the bare minimum for that pretty printing is much closer to 12K than 472K.  I could just use rust-core for vaguely embedded stuff, but I don't think this is a good solution in the long run.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31438042/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31475987",
    "html_url": "https://github.com/rust-lang/rust/issues/10740#issuecomment-31475987",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10740",
    "id": 31475987,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDc1OTg3",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-02T19:09:54Z",
    "updated_at": "2014-01-02T19:09:54Z",
    "body": "The best prospects you have of a small statically linked binary is to use LTO (as you found out), but you should not be running with `-dead_strip` because that can corrupt libraries and the object files (such as discarding metadata) and is not guaranteed to always work with the objects that rust generates.\n\nYou are correct in that the vtables are the major cause of bloat right now. As a result, all I/O code is pulled in to all binaries even if they don't use it (if they're statically linked). This is a consequence of our decision of the architecture of I/O and I don't forsee it changing soon.\n\nIf you care about using the standard library and having small binaries (not kernel modules), then I would highly recommend dynamic linking as an option. Dynamic linking is optimized for exactly this use case (one library implementation shared among many binaries).\n\nIf you care about the size of your libraries if you're making a kernel module, then these numbers are all irrelevant. You cannot use `libnative` or `libgreen` with a kernel module because they're all implemented on top of libc, which is not available in the kernel. There would be a separate library (`libkernel` if you write it) which would implement the relevant functionality that `libstd` expects to have (tasks, stdio, etc). Using LTO works exactly as well as you would expect it to, and a `libkernel` that didn't have large vtables would optimize to a very small module.\n\nAnd finally, the embedded context is the same as the kernel context. If you're writing an embedded kernel, you cannot use libnative or even rust-core. You are forced to write your own implementation of various components. If you're worried about generating embedded binaries that are large, then I recommend that you use dynamic linking instead.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31475987/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31476260",
    "html_url": "https://github.com/rust-lang/rust/issues/10740#issuecomment-31476260",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10740",
    "id": 31476260,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDc2MjYw",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-02T19:13:17Z",
    "updated_at": "2014-01-02T19:13:17Z",
    "body": "You can use rust-core for an embedded kernel, it doesn't have any required dependencies. There's just not much available yet with allocators blocked on fixing destructors.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31476260/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31495865",
    "html_url": "https://github.com/rust-lang/rust/issues/10740#issuecomment-31495865",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10740",
    "id": 31495865,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDk1ODY1",
    "user": {
      "login": "comex",
      "id": 47517,
      "node_id": "MDQ6VXNlcjQ3NTE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/47517?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/comex",
      "html_url": "https://github.com/comex",
      "followers_url": "https://api.github.com/users/comex/followers",
      "following_url": "https://api.github.com/users/comex/following{/other_user}",
      "gists_url": "https://api.github.com/users/comex/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/comex/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/comex/subscriptions",
      "organizations_url": "https://api.github.com/users/comex/orgs",
      "repos_url": "https://api.github.com/users/comex/repos",
      "events_url": "https://api.github.com/users/comex/events{/privacy}",
      "received_events_url": "https://api.github.com/users/comex/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-03T00:00:24Z",
    "updated_at": "2014-01-03T00:00:24Z",
    "body": "@alexcrichton Good point regarding libkernel.\n\nIt seems like -dead_strip not working properly should be considered a bug, to be fixed by defining whatever metadata needs to be kept in libraries as an exported symbol.  Thus unnecessary data could still be removed in statically linked executables, without having to deal with the overhead of LTO.\n\nI think I am going to try to implement stripping dead virtual methods in a somewhat hacky way in LLVM to see how much it helps in practice.\n\nOn a somewhat related note, based on quickly skimming the resulting binary in IDA, I'm somewhat suspicious that part of the problem may be that rustc just generates more verbose code for idiomatic Rust than you see in idiomatic C, e.g. doing a lot of copying things around between the stack and registers, though I could be completely wrong.  Is there any easy way to get the equivalent of -Oz/-Os in rustc?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31495865/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31508325",
    "html_url": "https://github.com/rust-lang/rust/issues/10740#issuecomment-31508325",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10740",
    "id": 31508325,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNTA4MzI1",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-03T07:04:06Z",
    "updated_at": "2014-01-03T07:04:06Z",
    "body": "I do not forsee officially supporting flags like `-dead_strip` or `--gc-sections` because this implies a close reliance on the system linker which we wish to not have. We would have to instruct the linker to retain certain symbols which is more of a pain than a gain on most platforms. I do not consider this a bug. Our LTO infrastructure will always preserve symbols correctly for a rust program, and this is the recommended method of cutting down program sizes.\n\nRust generates a very large amount of IR, but that does not mean that an optimized rust binary is slower or larger than C. Rust has always been on-par with C/C++ code (that I have examined). The only downside is that O0 is like 30x slower than C++ O0 (due to our large amount of codegen). Thankfully LLVM is a pretty good optimizer.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31508325/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31508995",
    "html_url": "https://github.com/rust-lang/rust/issues/10740#issuecomment-31508995",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10740",
    "id": 31508995,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNTA4OTk1",
    "user": {
      "login": "comex",
      "id": 47517,
      "node_id": "MDQ6VXNlcjQ3NTE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/47517?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/comex",
      "html_url": "https://github.com/comex",
      "followers_url": "https://api.github.com/users/comex/followers",
      "following_url": "https://api.github.com/users/comex/following{/other_user}",
      "gists_url": "https://api.github.com/users/comex/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/comex/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/comex/subscriptions",
      "organizations_url": "https://api.github.com/users/comex/orgs",
      "repos_url": "https://api.github.com/users/comex/repos",
      "events_url": "https://api.github.com/users/comex/events{/privacy}",
      "received_events_url": "https://api.github.com/users/comex/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-03T07:31:32Z",
    "updated_at": "2014-01-03T07:31:32Z",
    "body": "I do not understand what you mean about dead_strip.  Supporting dead_strip properly on OS X requires two things:\n- Ensure that anything that is in a magic section is also referenced from an exported symbol.  I think this is a matter of just making rust_metadata exported.\n- Ensure that MH_SUBSECTIONS_VIA_SYMBOLS is set for all objects that do not have multiple symbols which must be kept together.  This is already true because LLVM always sets that flag.\n\nI don't think that making one symbol public is more of a pain than a gain; LTO is nice but it is rather slow.  I guess this could be a different issue report, though.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31508995/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
