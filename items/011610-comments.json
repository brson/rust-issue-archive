[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32581545",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-32581545",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 32581545,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTgxNTQ1",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-17T05:43:36Z",
    "updated_at": "2014-01-17T05:43:36Z",
    "body": "@sanxiyn @yichoi Is v7 the ARM we should be using by default?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32581545/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32581729",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-32581729",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 32581729,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTgxNzI5",
    "user": {
      "login": "yichoi",
      "id": 3222276,
      "node_id": "MDQ6VXNlcjMyMjIyNzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3222276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yichoi",
      "html_url": "https://github.com/yichoi",
      "followers_url": "https://api.github.com/users/yichoi/followers",
      "following_url": "https://api.github.com/users/yichoi/following{/other_user}",
      "gists_url": "https://api.github.com/users/yichoi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yichoi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yichoi/subscriptions",
      "organizations_url": "https://api.github.com/users/yichoi/orgs",
      "repos_url": "https://api.github.com/users/yichoi/repos",
      "events_url": "https://api.github.com/users/yichoi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yichoi/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-17T05:48:54Z",
    "updated_at": "2014-01-17T05:48:54Z",
    "body": "@brson yep\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32581729/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32675539",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-32675539",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 32675539,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNjc1NTM5",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-18T06:00:51Z",
    "updated_at": "2014-01-18T06:00:51Z",
    "body": "I didn't see where `extra::sync` got converted to the new mutex from send_deferred.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32675539/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32697864",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-32697864",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 32697864,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNjk3ODY0",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-19T00:44:39Z",
    "updated_at": "2014-01-19T00:56:28Z",
    "body": "I see that you went with this approach to maximize native performance (which might be possible to improve in #11520, haven't really tried), but is an implementation that is completely unfair in the combination of native and green threads really acceptable to ship as a core synchronization primitive?\n\nAs written, a native task will always be blocked forever on lock() if there are enough contending green tasks, which seems to make a Mutex unreliable in such a configuration.\n\nIn fact, as far as I can tell, a set of N + 1 green tasks, where N is the number of concurrent task schedulers, (i.e. typically the number of CPU cores) that take a mutex in a loop without sleeping/scheduling with the mutex unlocked (perhaps because they do all their sleeping while holding the mutex) seems enough to make sure that native tasks will never get the mutex.\n\nAnd if such a configuration is not really usable and native performance must be optimal, then maybe the best option is to ban mixing native and green tasks for either a given mutex (create one or the other depending on the type of the task that calls Mutex::new()) or the whole process, which means that one can have two separate implementations of all primitives.\n\nThat way, one can directly use the OS primitives in the native case, and use the algorithms that the Linux kernel uses for it's own sleepable primitives for the green tasks, providing optimal performance and eliminating the need of engineering from scratch primitives for the unique Rust use case of mixed native/green tasks.\n\n[There's also the issue that using yields is bad (e.g. if one sends SIGSTOP or breaks a thread in a debugger at the wrong time, the others will be spinning forever) and neither glibc nor Linux use them in library code, but at least that doesn't impact the correctness of programs.]\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32697864/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32698710",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-32698710",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 32698710,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNjk4NzEw",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-19T01:38:20Z",
    "updated_at": "2014-01-19T01:38:20Z",
    "body": "Is there a modification to this strategy that can prevent native thread starvation in the presence of green thread contention?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32698710/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32701147",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-32701147",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 32701147,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzAxMTQ3",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-19T04:57:20Z",
    "updated_at": "2014-01-19T04:57:20Z",
    "body": "It might be possible to always unlock and relock the lock on unlock (at some performance cost, and perhaps losing the guarantee) and then add a check for the queue being empty to native tasks to prevent the opposite.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32701147/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32701214",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-32701214",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 32701214,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzAxMjE0",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-19T05:03:02Z",
    "updated_at": "2014-01-19T05:30:58Z",
    "body": "I think there is at least one race condition in the code: as the comment in the code says, one can ignore the case when the MPSC queue is inconsistent _IF_ the pusher is guaranteed to see that held has been set to false.\n\nHowever, there is no fence that guarantees that the self.held.store(false, atomics::Relaxed) won't be moved after the q.pop().\n\nIt looks like there needs to be a SeqCst fence there and a SeqCst fence after the push in lock(), or alternatively either the MPSC queue or the held variable need to be manipulated with SeqCst (acquire and release don't seem to enough, since they aren't StoreLoad fences).\n\nAlso, there should be at least a compiler optimization barrier (an empty volatile asm!() with a memory clobber should work, not sure if LLVM has something better) after the write to held in lock(), since otherwise the compiler could in principle move that store arbitrarily down after inlining lock(), resulting in green tasks spinning for a long time; likewise, there should be at least a compiler barrier before the held store in unlock() for the same reason.\n\n#[inline(never)] on both lock() and unlock() would also work, but with the negative side effect of always preventing inlining.\n\nA fence, but I think all real CPUs guarantee that stores are made visible as soon as possible, so it should not be needed.\n\nI'm not sure whether that makes it free from race conditions or if there are others.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32701214/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32702933",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-32702933",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 32702933,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzAyOTMz",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-19T07:35:02Z",
    "updated_at": "2014-01-19T07:41:53Z",
    "body": "I changed the code in #10520 (see https://github.com/bill-myers/rust/tree/mutex-lockless) to start cmpxchg loops with a relaxed load, which seems to be a bit faster on Haswell compared to starting with an optimistic cmpxchg.\n\nAfter that change to #10520, and adding SeqCst to the held store in unlock in this pull (which means it's going to use xchg instead of mov), they both take around 2.5 seconds real time to unlock a mutex a million times from each of 8 native tasks on an HT 4-core mobile 2.2GHz Haswell (with Linux on bare hardware), while using unstable::Mutex directly takes 1.7 seconds.\n\nThe original racy code in this pull after removing the assert!() on held results in 2 seconds, and completely removing both held load and store results in 1.85 seconds (but both are incorrect), while #10520 without the optimization took around 2.85 seconds.\n\nSo it seems that this closes the gap on my machine, but Alex Crichton's results seemed to show a larger gap in the first place, so not sure what it would look like there with those changes (was the benchmark on #10520 perhaps done with 64-bit atomics on x86-32?)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32702933/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33000634",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-33000634",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 33000634,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMDAwNjM0",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-22T08:06:02Z",
    "updated_at": "2014-01-22T08:06:02Z",
    "body": "I've updated with what @brson and I talked about today\n- Every atomic has a `SeqCst` ordering. This does have a slowdown in the benches that I had. If I put `Relaxed` in a few locations (so the stores aren't `xchg`s) it's about 5-10% slower than a pthread mutex. Right now it's slower than that, but I believe that having `SeqCst` until we understand better is the right way forward\n- The mutex is a little more fair (still not completely fair) by alternating who is woken up (native threads favor green and green threads favor native).\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33000634/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33075571",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-33075571",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 33075571,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMDc1NTcx",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-22T22:22:16Z",
    "updated_at": "2014-01-22T22:23:02Z",
    "body": "Is this still faster than https://github.com/bill-myers/rust/tree/mutex-lockless on 64-bit Linux on x86 when using atomics::SeqCnt?\n\nComparing performance with atomics relaxed makes little sense, since that means benchmarking an incorrect implementation, and the atomics are in fact the main source of slowdown.\n\nAnyway, I think both https://github.com/bill-myers/rust/tree/mutex-lockless and this should be acceptable from a \"doesn't break programs\" perspective.\n\nWith the key insight of alternating between green and native tasks, I think there is actually a third option, which would involve taking this pull request, and removing the need to yield, in the following way:\n1. Replace the MPSC queue with the one from #11520, which doesn't need yields and allows to check that the queue is either empty or that someone else popped without the lock by checking that q.producer == 0\n2. Remove the held variable, assume that green tasks can sleep if trylock fails\n3. In unlock after doing the q.pop(), getting None and unlocking the mutex, do an extra check for q.producer != 0, and if it succeeds, then try_lock, and if that succeeds too, retry the unlocking procedure from the start\n\nCompared to this pull, it would remove yields and reduce the size of the mutex structure (yes, the mutex would be touched after unlocking, but that's not a problem in Rust as argued in #11520).\n\nI think this might perhaps be the best option.\n\nBTW, regarding the TLS hit, having a \"is_nonblocking_task\" thread-local variable (which needs to be written to only when a green task scheduler starts or stops) rather than having to fetch the task would speed it up, and perhaps make it possible to remove the is_blocking_locker variable (and eventually, one could ask the glibc maintainers to reserve a bit in the glibc thread structure for this purpose).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33075571/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33080039",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-33080039",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 33080039,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMDgwMDM5",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-22T23:13:20Z",
    "updated_at": "2014-01-22T23:13:20Z",
    "body": "I do believe that the performance comparison with Relaxed is a fair comparison. The only reason these use SeqCst is that I don't personally feel like I have a good enough understanding of atomics in order to relax the constraints. This causes a store to become an `xchg` on x86, but that is completely unnecessary and it can most certainly just be a `mov` (whereas with a `cmpxchg` it must always be a compare-and-swap).\n\nAs I've discussed before, relaxing the constraint of re-using the mutex in unlock is something I believe to be unacceptable. There is code which does this today in rust (seen [here](https://github.com/mozilla/rust/blob/master/src/libgreen/sched.rs#L737-L739)), and you cannot have \"just use an arc\" as a solution.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33080039/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33083511",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-33083511",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 33083511,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMDgzNTEx",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-22T23:59:48Z",
    "updated_at": "2014-01-22T23:59:48Z",
    "body": "The store to held in unlock must be an xchg, since otherwise the loads in q.pop() can be moved before it.\n\nThe fetch_and_sub and fetch_and_add must be lock xadd since just xadd is not even atomic::Relaxed.\n\nLoads are implemented as mov regardless of atomic memory model.\n\nThe stores to held in lock() can indeed be relaxed.\n\nSo I think code generation with all SeqCst is the optimal one on x86 (although SeqCst might not be the optimal choice otherwise), except for storing true in held, with can and should be relaxed.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33083511/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33083695",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-33083695",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 33083695,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMDgzNjk1",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T00:02:08Z",
    "updated_at": "2014-01-23T00:02:08Z",
    "body": "> The store to held in unlock must be an xchg, since otherwise the loads in q.pop() can be moved before it.\n\nThe x86 _architecture_ does not do this, the _compiler_ may do this. The `SeqCst` ordering is telling the _compiler_ to not re-order it, and I don't know the best way to tell the compiler \"don't reorder this and don't make this and xchg\"\n\n> The fetch_and_sub and fetch_and_add must be lock xadd since just xadd is not even atomic::Relaxed.\n\nThis is only in the contended case, so speed is much less of a worry once you've reached this situation\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33083695/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33084577",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-33084577",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 33084577,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMDg0NTc3",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T00:15:27Z",
    "updated_at": "2014-01-23T00:16:54Z",
    "body": "No, x86 architecture CPUs with out of order execution (i.e. all the desktop/mobile ones) can move loads before stores (to a different memory location, of course) unless the store is an xchg or there is a locked op, xchg or fence in the middle.\n\nSo assuming q.pop() checks that the queue is empty with only reads, then storing false to held must be done with an xchg (or mov + mfence or similar).\n\nSee https://en.wikipedia.org/wiki/Memory_ordering, \"Stores reordered after loads\", for instance.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33084577/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33085455",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-33085455",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 33085455,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMDg1NDU1",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T00:28:34Z",
    "updated_at": "2014-01-23T00:28:34Z",
    "body": "@alexcrichton: There are still multiple levels of atomic ordering guarantees on x86 itself. You'll get different instructions from relaxed and sequential consistency. The compiler is still free to reorder the atomic instructions _within_ a thread if it can figure out what's going on. IIRC, we mark _all_ atomic operations as volatile unnecessarily so we're probably not getting code generation as good as C++ atomics. They should be split out into `volatile_` intrinsics or we should approach volatile in another way.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33085455/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33101034",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-33101034",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 33101034,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTAxMDM0",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T06:48:49Z",
    "updated_at": "2014-01-23T06:48:49Z",
    "body": "I'm satisfied with this approach and want to merge it. Further improvements can be made in future pull requests.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33101034/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33406149",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-33406149",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 33406149,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDA2MTQ5",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-27T18:40:38Z",
    "updated_at": "2014-01-27T18:49:34Z",
    "body": "I think the only simple way of solving this is to switch to locks that don't have special behavior when recursively locked.\n\nOn Windows Vista, I think you can use SRW locks for that.\n\nOn Windows XP I think it should work to implement mutexes as an auto-reset event that starts as signalled, use WaitForSingleObject to lock it, and SetEvent(TRUE) to unlock it.\n\nOtherwise, you need to, at least:\n1. Forbid running native task code on a thread after it scheduled any green tasks (otherwise that native task code might not be able to block on a mutex taken by that same native thread when it was executing a green task)\n2. Turn self.held into a tri-state value, and add a new state for when a thread is between the \"self.held = true\" and the lock.unlock() in unlock so that you don't race on q.pop() due to try_lock succeeding early in the green task lock case\n\nBTW, I just noticed that locking a mutex on a native thread and unlocking it on another is undefined behavior according to POSIX, which means that Rust should refuse to compile for any unknown POSIX platform, and it should be checked that this does indeed work on all supported POSIX platforms (I think Linux should be fine as long as one uses PTHREAD_MUTEX_NORMAL, but haven't checked in detail).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33406149/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33407246",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-33407246",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 33407246,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDA3MjQ2",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-27T18:50:49Z",
    "updated_at": "2014-01-27T18:50:49Z",
    "body": "@bill-myers: It's not a good idea to depend on undefined behavior based on glibc implementation details. They're willing to break any such incorrect code at any time, and lock elision may do exactly that as it matures and becomes the default.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33407246/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33411552",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-33411552",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 33411552,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDExNTUy",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-27T19:31:44Z",
    "updated_at": "2014-01-27T19:31:44Z",
    "body": "@thestinger If your argument is accepted, then this Mutex implementation must be completely redesigned (the other approaches I proposed share this issue, although they may or may not more easily accomodate the changes)\n\nLock elision is actually a really important point; we can of course request to disable it, but it would be nice to take advantage of it both for native and for green tasks.\n\nMaybe we really need to go back to the drawing board, make all tasks always drop the OS mutex on unlock and redesign everything as needed to accomodate that?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33411552/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33411733",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-33411733",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 33411733,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDExNzMz",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-27T19:33:33Z",
    "updated_at": "2014-01-27T19:33:33Z",
    "body": "Here's an example of their willingness to break anything relying on undefined behavior: https://bugzilla.redhat.com/show_bug.cgi?id=638477\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33411733/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33413888",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-33413888",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 33413888,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDEzODg4",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-27T19:54:38Z",
    "updated_at": "2014-01-27T19:54:38Z",
    "body": "glibc doesn't seem to have any documentation of pthread functions other than the POSIX specification.\n\nSo, the problem of always unlocking is that it would starve green tasks at least in case the native OS mutex implements FIFO wakeups, since green tasks cannot block and thus cannot reserve a spot in the OS mutex FIFO queue.\n\nThe only solution is to make new native tasks queue as well in the MPSC queue once any green tasks are queued.\n\nThis is what #11520 did, but I think the code in this pull request can also be changed to do that.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33413888/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33415736",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-33415736",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 33415736,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDE1NzM2",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-27T20:07:09Z",
    "updated_at": "2014-01-27T20:07:09Z",
    "body": "In something as critical as mutex, I don't want to rely on undefined behavior in POSIX.\n\nI didn't realize how much of a problem it was to unlock a mutex on another thread that originally locked it. Holding an OS mutex across the lock/unlock call I'm thinking at this point is unacceptable for green threads. It's possible for green threads to migrate around os threads, so you have no guarantee that the green thread will unlock on the same os thread.\n\nFor now, I'm going to close this because this still has work to hash out.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33415736/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33433039",
    "html_url": "https://github.com/rust-lang/rust/pull/11610#issuecomment-33433039",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11610",
    "id": 33433039,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDMzMDM5",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-27T22:52:28Z",
    "updated_at": "2014-01-27T22:52:28Z",
    "body": "I have an idea of how to get around this.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33433039/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
