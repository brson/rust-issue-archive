{
  "url": "https://api.github.com/repos/rust-lang/rust/issues/15720",
  "repository_url": "https://api.github.com/repos/rust-lang/rust",
  "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/15720/labels{/name}",
  "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/15720/comments",
  "events_url": "https://api.github.com/repos/rust-lang/rust/issues/15720/events",
  "html_url": "https://github.com/rust-lang/rust/pull/15720",
  "id": 37991965,
  "node_id": "MDExOlB1bGxSZXF1ZXN0MTg0NzM3NzI=",
  "number": 15720,
  "title": "Optimized HashMap. RawTable exposes a safe interface.",
  "user": {
    "login": "pczarn",
    "id": 3356767,
    "node_id": "MDQ6VXNlcjMzNTY3Njc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/pczarn",
    "html_url": "https://github.com/pczarn",
    "followers_url": "https://api.github.com/users/pczarn/followers",
    "following_url": "https://api.github.com/users/pczarn/following{/other_user}",
    "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions",
    "organizations_url": "https://api.github.com/users/pczarn/orgs",
    "repos_url": "https://api.github.com/users/pczarn/repos",
    "events_url": "https://api.github.com/users/pczarn/events{/privacy}",
    "received_events_url": "https://api.github.com/users/pczarn/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 11,
  "created_at": "2014-07-16T15:08:34Z",
  "updated_at": "2014-08-20T14:47:42Z",
  "closed_at": "2014-08-19T05:12:49Z",
  "author_association": "CONTRIBUTOR",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/rust-lang/rust/pulls/15720",
    "html_url": "https://github.com/rust-lang/rust/pull/15720",
    "diff_url": "https://github.com/rust-lang/rust/pull/15720.diff",
    "patch_url": "https://github.com/rust-lang/rust/pull/15720.patch",
    "merged_at": null
  },
  "body": "First, a benchmark of the original hashmap implementation on Intel i3.\n\n```\nfind_existing    ... 54450 ns/iter (+/- 5524)\nfind_nonexisting ... 52472 ns/iter (+/- 1672)\nfind_pop_insert  ...   262 ns/iter (+/- 3)\nhashmap_as_queue ...   148 ns/iter (+/- 0)\ninsert           ...   183 ns/iter (+/- 6)\nnew_drop         ...   200 ns/iter (+/- 52)\nnew_insert_drop  ...   317 ns/iter (+/- 104)\n```\n## `bucket_distance` and `pop_internal`\n\nA branchless implementation of probe count calculation. A branch just avoided unsigned underflow. Since the `capacity` is a power of 2, we can ignore underflow and simply return the difference modulo capacity. We can use the fact that 'an index argument >= capacity' is acceptable later on.\n\n`pop_internal` returns `V` instead of `Option<V>`.\n\nNo more low hanging fruits...\n## iteration over buckets\n\nLet's use external iterators for their greatest advantage in Rust: to avoid bounds checks and indexing. Thus `{Empty,Full}Index` becomes `{Empty,Full}Bucket`.\n\nThe growing is done an optimized reinsertion algorithm based on `insert_hashed_ordered`. `HashMap::new()` returns a table with the capacity set to 0. Hashmaps that never had an element inserted won't allocate, as measured by `bench::new_drop`.\n\nRemoved two pointers from `RawTable` as they can be recalculated once per iteration rather than every indexing operation. `RawTable` struct is as small as `Vec` with 24 bytes.\n\nReduced code duplication between `swap` and `insert_hashed_nocheck`. Created a new method `insert_or_replace_with` that accepts a simple closure for this. Moreover, `robin_hood` will most likely get inlined.\n\n```\nfind_existing    ... 45556 ns/iter (+/- 1510)\nfind_nonexisting ... 43812 ns/iter (+/- 1212)\nfind_pop_insert  ...   224 ns/iter (+/- 9)\nhashmap_as_queue ...   134 ns/iter (+/- 0)\ninsert           ...   183 ns/iter (+/- 14)\nnew_drop         ...   118 ns/iter (+/- 2)\nnew_insert_drop  ...   241 ns/iter (+/- 29)\n```\n## safe interface\n\nThis is possible thanks to a lot of prior work by @nikomatsakis! Relevant commit: https://github.com/nikomatsakis/rust/commit/2fcb95b50e5a82c63b82241b98074869b50e1796\n\nTo eliminate the double-take issue, we must tie a bucket pointer to a reference to the table within a private structure. Only a bucket that holds a unique reference can be updated. `GapThenFull` uses a similar strategy to encapsulate two consecutive buckets and a single reference. Some of HashMap's methods became functions parameterized over mutability.\n\nWe could use an uninit reference or drop trickery to replace one zeroing of a bucket's hash per `shift` of `GapThenFull` with a single memory access. The former language feature is not planned and the latter seems inefficient.\n\n```\nfind_existing    ... 48131 ns/iter (+/- 3469)\nfind_nonexisting ... 48518 ns/iter (+/- 1785)\nfind_pop_insert  ...   238 ns/iter (+/- 5)\nhashmap_as_queue ...   131 ns/iter (+/- 2)\ninsert           ...   217 ns/iter (+/- 6)\nnew_drop         ...   120 ns/iter (+/- 11)\nnew_insert_drop  ...   238 ns/iter (+/- 25)\n```\n## split hashmap.rs into separate files\n\nTotal number of lines approaches 3000.\n## final refactoring\n\nStandalone `robin_hood`.\n\nI realized that `insert_or_update_with` can call `insert_or_replace_with` directly.\n\nInlining now started happening in microbenchmarks for some reason. Looks like `search_hashed_generic` is quite small:\n\n```\nfind_existing    ... 51137 ns/iter (+/- 8663)\nfind_nonexisting ... 17286 ns/iter (+/- 2961)\nfind_pop_insert  ...   198 ns/iter (+/- 4)\nhashmap_as_queue ...   134 ns/iter (+/- 1)\ninsert           ...   220 ns/iter (+/- 5)\nnew_drop         ...   121 ns/iter (+/- 11)\nnew_insert_drop  ...   234 ns/iter (+/- 6)\n```\n## conclusion\n\nFurther optimizations are increasingly difficult, usually they would make the code unreadable or would require new language features.\n\nIt's possible to build cache aware HashMap on top of a vector of SoAs, such as `Vec<([u64, ..N], [K, ..N], [V, ..N])>`. Possibility of in-place growing is the only performance advantage of this approach. Unfortunately, [an increase in iteration complexity](https://github.com/pczarn/code/blob/master/rust/vectrivec/mod.rs) surpasses benefits of storage reuse.\n\nDocumentation is not finished. Most methods need more comments and tests.\n\nRobin hood hashing scheme was introduced in #12081.\n\ncc @cgaebel\n",
  "closed_by": {
    "login": "alexcrichton",
    "id": 64996,
    "node_id": "MDQ6VXNlcjY0OTk2",
    "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/alexcrichton",
    "html_url": "https://github.com/alexcrichton",
    "followers_url": "https://api.github.com/users/alexcrichton/followers",
    "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
    "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
    "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
    "repos_url": "https://api.github.com/users/alexcrichton/repos",
    "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/15720/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/15720/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "_meta": {
    "type": "pr"
  }
}
