[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/13326935",
    "html_url": "https://github.com/rust-lang/rust/issues/4689#issuecomment-13326935",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/4689",
    "id": 13326935,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEzMzI2OTM1",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-02-09T05:56:48Z",
    "updated_at": "2013-02-09T06:37:51Z",
    "body": "alright, i don't suppose you'd happen to have any logs of the times it failed? I haven't been able to reproduce the test failing (i.e., the test function terminating successfully).\n\nLooking over the unwrap implementation I think it's basically impossible for the `conflict` test to fail with a localized bug, since it's testing two linked-failure tasks who go through code that looks like this:\n\n```\nif compare_and_swap(&mut ptr.unwrapper, 0, serverp) {\n    // I get to unwrap the data.\n    ...\n} else {\n    // Multiple unwrappers is illegal.\n    die!(...);\n}\n```\n\nso I think it is safe to say that exactly one of the tasks will hit the `die!`.\n\nWhat's more, the test case itself has the parent thread (the one the test harness will block on) block on its child using a future_result. Either the parent will hit the die above (in which case the test case will surely pass), or the child will hit it, in which case the child's failure should link to the parent through the parent's `recv()` call (I checked the linked failure code to make sure taskgroup killing happens before AutoNotify messaging). So it might be just as likely the race is in getting failed out of the recv call.\n\nSo far I've experimented adding delays into various parts of the unwrap implementation to see which paths this test actually exercises (the state space is not very large, so it is not a Research Problem :P ), but not seen the bug in any yet. Will continue the search another day.\n\nEDIT: reproduction successful. (I'd forgotten that there was a difference in failure semantics between when the tasks are in the main/root taskgroup and when they're running as a #[test]! Argh.) More later.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/13326935/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/13327569",
    "html_url": "https://github.com/rust-lang/rust/issues/4689#issuecomment-13327569",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/4689",
    "id": 13327569,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEzMzI3NTY5",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-02-09T07:27:19Z",
    "updated_at": "2013-02-09T07:44:40Z",
    "body": "Would you believe this is the minimized test case for this bug? No unwrap involved at all.\n\n```\n#[test] #[should_fail]\npub fn test() {\n    let mut res = None;\n    do task::task().future_result(|+r| res = Some(move r)).spawn {\n                die!(~\"woops\");\n    }\n    unsafe { libc::sleep(1); }\n    let res = option::swap_unwrap(&mut res);\n    res.recv();\n}\n```\n\nDepending on the sleep, the test will either work or not (i.e., the problem is when a failing task sends to its future_result before the parent even starts to receive on it, the linked failure doesn't take effect). I'm not sure if this is an _intended_ nondeterminism of `future_result`, but I definitely wrote `unwrap` assuming it wouldn't happen that way.\n\nanyway one possible way to fix this is to change the last line of the test case `res.recv()` to `assert res.recv() == Success` (which doesn't weaken the test case). I will meditate on this more to decide if that's the best way.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/13327569/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/13334346",
    "html_url": "https://github.com/rust-lang/rust/issues/4689#issuecomment-13334346",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/4689",
    "id": 13334346,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEzMzM0MzQ2",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-02-09T17:12:09Z",
    "updated_at": "2013-02-09T17:12:09Z",
    "body": "OK, what's going on here is linked failure doesn't propagate through a `recv()` in the special case where the pipe has data and the task doesn't need to block for it. To \"fix\" this nondeterminism at its source would involve putting a `must_fail_from_being_killed()`check in the `old_state == Full` case of `pipes::try_recv()`.\n\nAs another example, consider this program, whose main task _always succeeds_. \"Fixing\" the nondetermism above would make this program sometimes succeed (if the parent recvs before the child sends) and sometimes fail (if the child sends and fails before the parent recvs).\n\n```\nfn main() {\n    let (p,c) = pipes::stream();\n    do task::spawn |move c| {\n        c.send(());\n        assert false;\n    }\n    p.recv();\n}\n```\n\nIntroducing the extra killed check wouldn't require taking a lock (see #3213). But, I've always punted on the semantics of _when_ a linked failure killing takes effect, and adding this check feels like a patchwork special-case rather than a principled semantics change. @eholk might have input on the matter?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/13334346/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/13391014",
    "html_url": "https://github.com/rust-lang/rust/issues/4689#issuecomment-13391014",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/4689",
    "id": 13391014,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEzMzkxMDE0",
    "user": {
      "login": "eholk",
      "id": 105766,
      "node_id": "MDQ6VXNlcjEwNTc2Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eholk",
      "html_url": "https://github.com/eholk",
      "followers_url": "https://api.github.com/users/eholk/followers",
      "following_url": "https://api.github.com/users/eholk/following{/other_user}",
      "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eholk/subscriptions",
      "organizations_url": "https://api.github.com/users/eholk/orgs",
      "repos_url": "https://api.github.com/users/eholk/repos",
      "events_url": "https://api.github.com/users/eholk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eholk/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-02-11T17:18:53Z",
    "updated_at": "2013-02-11T17:18:53Z",
    "body": "Adding the `must_fail_from_being_killed()` check seems reasonable to me. In the case of failure, I think it's fine if things are somewhat nondeterministic, so I don't think it's a problem if the program above sometimes failed. What if we added a sleep before `p.recv()`? It seems like in that case you'd want this to always fail, unless you turned off link failure.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/13391014/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/13971472",
    "html_url": "https://github.com/rust-lang/rust/issues/4689#issuecomment-13971472",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/4689",
    "id": 13971472,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEzOTcxNDcy",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-02-22T21:12:53Z",
    "updated_at": "2013-02-22T21:12:53Z",
    "body": "@bblum Thanks for looking into this. I understand how `recv` misses its opportunity to fail but not why the 'assert' has any effect.\n\nThis is similar to a problem I frequently run into where I expect test cases like this to work (by failing):\n\n```\n#[test] #[should_fail]\nfn test() {\n  spawn(||fail!());\n}\n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/13971472/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/13972227",
    "html_url": "https://github.com/rust-lang/rust/issues/4689#issuecomment-13972227",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/4689",
    "id": 13972227,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEzOTcyMjI3",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-02-22T21:30:10Z",
    "updated_at": "2013-02-22T21:33:29Z",
    "body": "Yeah, those are annoying cases. It might be nice to have a spawn interface that, while letting the parent go off and do its own thing, also makes the parent block on the child (on all such children spawned this way) before actually task-exiting.\n\nThis could be done with `future_result` on top of a generalised `atexit` interface, or it could work by stashing `future_result`s inside the parent's `TCB` and having the `TCB` destructor wait on each one in the destructor (which is essentially a hardcoded version of how `atexit` would also work).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/13972227/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
