[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32153123",
    "html_url": "https://github.com/rust-lang/rust/pull/11509#issuecomment-32153123",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11509",
    "id": 32153123,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTUzMTIz",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-13T09:01:21Z",
    "updated_at": "2014-01-13T09:01:21Z",
    "body": "I greatly appreciate you taking the time to write up this implementation, it will be very useful in benchmarking and comparisons, so thank you!\n\nI firmly believe that the guarantee you are so easily batting away is vital to have. I would encourage you to read http://lwn.net/Articles/575460/ (which a quick googling about the issue brought up). I personally have run into this race. I do not believe that \"just use an arc\" is a solution. In my mind, this is equivalent to saying \"just use a gc\" if you're having trouble freeing owned pointers.\n\nRegardless, we need to discuss whether that guarantee is necessary for this mutex implementation or not. I would be uncomfortable merging this if we decided to discard the guarantee for a few reasons:\n- Lock free code is incredibly hard to get right, and there's very little documentation to what's going on inside this mutex. I attempted to closely document everything that was going on, and you seem to have just deleted all of it without replacement.\n- This implementation looks like it has a number of premature optimization which only serve to make the code more impenetrable to read (`support_nonblocking_tasks` will never be `false`, unsafe borrows, etc).\n- There's no mention of how this implementation's performance looks (I'd run green threads with RUST_THREADS=1 for now until we're able to fix scheduling to stop fanning out rust tasks to other cores so much)\n- I'm a little concerned about the size of the mutex, and it seems to me that if you already have a concurrent queue you might as well use it to make the structure smaller. I'm not sure whether this is a premature optimization or how well it plays with this implementation.\n\nFinally, I would recommend discussing these issues on an original pull request before opening up a new one. Our code of conduct states:\n\n> Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer.\n\nI personally feel in this case that you have read my opinions and immediately discounted them all as wrong. I would encourage you to work out your differences of opinion with me before brazenly deleting all my code.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32153123/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32153646",
    "html_url": "https://github.com/rust-lang/rust/pull/11509#issuecomment-32153646",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11509",
    "id": 32153646,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTUzNjQ2",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-13T09:12:27Z",
    "updated_at": "2014-01-13T09:21:59Z",
    "body": "> using a lockless algorithm that has to use thread_yield\n\nSo, it's just a low-priority spin lock and doesn't let the scheduler sleep? Or does it sleep in the scheduler until it's unlocked?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32153646/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32155792",
    "html_url": "https://github.com/rust-lang/rust/pull/11509#issuecomment-32155792",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11509",
    "id": 32155792,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTU1Nzky",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-13T09:49:28Z",
    "updated_at": "2014-01-13T09:52:25Z",
    "body": "> I firmly believe that the guarantee you are so easily batting away is vital to have. I would encourage you to read http://lwn.net/Articles/575460/ (which a quick googling about the issue brought up). I personally have run into this race. I do not believe that \"just use an arc\" is a solution. In my mind, this is equivalent to saying \"just use a gc\" if you're having trouble freeing owned pointers.\n\nI don't really understand why the reference counting should be the responsibility of a mutex. The OS can context-switch after you unlock but before you free it, so what does it really guarantee? The primary users of locking are going to be concurrently accessed data structures that are either static or use atomic reference counting.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32155792/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32178338",
    "html_url": "https://github.com/rust-lang/rust/pull/11509#issuecomment-32178338",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11509",
    "id": 32178338,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTc4MzM4",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-13T15:22:51Z",
    "updated_at": "2014-01-13T15:22:51Z",
    "body": "> I firmly believe that the guarantee you are so easily batting away is vital to have.\n> I read http://lwn.net/Articles/575460/ and that can happen mostly because C uses unsafe manual memory management (i.e. the kfree call in the code there).\n\nIn Rust, safe code cannot free memory arbitrarily and cannot be affected by this issue.\n\nUnsafe code needs to be somewhat breaking the language to deallocate a mutex early (since it invalidates the pointer the other task has), and I can't come up with a scenario where one needs to do that.\n\nFor instance, your unsafe code in Once doesn't have this issue because you properly use an external reference count in the natural way.\n\n> support_nonblocking_tasks will never be false\n> In the current form yes, but it's intended to either stay as documentation, or be converted to a static mut or compile-time option, in which case a program using only native tasks could set it.\n> \n> I'm a little concerned about the size of the mutex\n\nPossible fixes:\n1. Have an OS mutex variant that doesn't include a condition variable\n2. Conflate queue_nonempty and either queue or queue_tail\n3. Remove owner, just deadlock on recursive locking\n\nObviously removing the second lock would be ideal, but I'm not sure if that's possible.\n\n> Finally, I would recommend discussing these issues on an original pull request before opening up a new one\n\nSince the proposed alternative implementation is very different from the original one, it seems a new pull request was the only way to avoid polluting the original one; also I don't think on Github you can just post new code in response to a pull request in a way that allows to examine it easily.\n\nI'm not totally sure that this is the best approach, as it does have the drawbacks you mention; an approach that both doesn't yield and doesn't use an extra lock would be best, but I'm not sure if that's possible.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32178338/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32189583",
    "html_url": "https://github.com/rust-lang/rust/pull/11509#issuecomment-32189583",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11509",
    "id": 32189583,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTg5NTgz",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-13T17:13:45Z",
    "updated_at": "2014-01-13T17:13:45Z",
    "body": "> So, it's just a low-priority spin lock and doesn't let the scheduler sleep? Or does it sleep in the scheduler until it's unlocked?\n\nI would recommend reading the pull request for full details, it sounds like you may be conflating ideas specific to kernel locks to  user-space locks (I'm unaware of any such spin lock in user space).\n\n> In Rust, safe code cannot free memory arbitrarily and cannot be affected by this issue.\n\nYou do realize that safe code in rust has no use for a mutex, right? Using a mutex _implies_ that you're using unsafe code to share memory among more than one consumer.\n\n> Obviously removing the second lock would be ideal, but I'm not sure if that's possible.\n\nI had an implementation which did this, as I have stated before I did not choose this option.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32189583/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32190177",
    "html_url": "https://github.com/rust-lang/rust/pull/11509#issuecomment-32190177",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11509",
    "id": 32190177,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTkwMTc3",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-13T17:20:08Z",
    "updated_at": "2014-01-13T17:20:08Z",
    "body": "Oops, this is in fact not globally fair in the initial version, since green tasks will have precedence because we don't always drop the lock.\n\nUploaded a new version that is now fair and simpler, by dropping that optimization.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32190177/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32191339",
    "html_url": "https://github.com/rust-lang/rust/pull/11509#issuecomment-32191339",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11509",
    "id": 32191339,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTkxMzM5",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-13T17:32:21Z",
    "updated_at": "2014-01-13T17:32:21Z",
    "body": "> You do realize that safe code in rust has no use for a mutex, right? \n\nThat's not correct: mutexes are useful for general serialization, and sharing memory safely is only one possible use for general serialization.\n\nFor example, if you are writing a parallel web crawler, and don't want to make more one simultaneous connection to any given web server (to not overload it), you can use an HashMap mapping IP addresses to mutexes, and use the mutex to protect connections to that specific IP address.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32191339/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32192768",
    "html_url": "https://github.com/rust-lang/rust/pull/11509#issuecomment-32192768",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11509",
    "id": 32192768,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTkyNzY4",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-13T17:48:08Z",
    "updated_at": "2014-01-13T17:48:08Z",
    "body": "BTW, I might have found a lockless algorithm that works, which would obsolete the code in this pull request.\n\nSee #11462 for the details.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32192768/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32219530",
    "html_url": "https://github.com/rust-lang/rust/pull/11509#issuecomment-32219530",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11509",
    "id": 32219530,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMjE5NTMw",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-13T22:36:03Z",
    "updated_at": "2014-01-13T22:36:03Z",
    "body": "Obsolete, now proposing pull #11520 instead, with uses a lockless algorithm and also avoids all the disadvantages mentioned in the comments here.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32219530/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
