[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21279236",
    "html_url": "https://github.com/rust-lang/rust/issues/7702#issuecomment-21279236",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7702",
    "id": 21279236,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxMjc5MjM2",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-19T21:39:52Z",
    "updated_at": "2013-07-19T21:39:52Z",
    "body": "I still prefer using a task tree. We can maintain the invariant that all tasks wait on their children even if children don't propagate failure.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21279236/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21286263",
    "html_url": "https://github.com/rust-lang/rust/issues/7702#issuecomment-21286263",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7702",
    "id": 21286263,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxMjg2MjYz",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-20T01:40:06Z",
    "updated_at": "2013-07-20T01:40:06Z",
    "body": "This seems pricey to me. Even we are optimizing for the fastest possible spawn path, that would require the extra synchronization of tombstoning for tasks that wouldn't otherwise need to do it. For KillHandle, this is a refcount at each end of the task's lifecycle, and (in case of outliving children) an extra lock and allocation. Maintaining population counts would just be one atomic op.\n\nHmm, actually, I just realized that population-counting can avoid have basically zero contention in the best case by keeping the population counts per-scheduler, and making use of the number-of-schedulers-awake refcount. When the last scheduler goes to sleep, it can scan the refcounts of all other schedulers (0? process exit. nonzero? if debug mode, check for deadlock; otherwise, do nothing). Then cross-CPU contention will only happen (a) on the scheduler-awake refcount, which is only touched when schedulers go to sleep, so it can be a slowpath, and (b) when a scheduler steals work, it will need to steal a refcount from the other scheduler too.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21286263/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21286391",
    "html_url": "https://github.com/rust-lang/rust/issues/7702#issuecomment-21286391",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7702",
    "id": 21286391,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxMjg2Mzkx",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-20T01:48:37Z",
    "updated_at": "2013-07-20T01:49:22Z",
    "body": "No wait, that doesn't make any sense. Refcounts would also have to migrate when a task blocks.\n\nAnyway, task tree maintenance will still be more expensive than one global refcount, both in atomics and in space. True that we would already be doing those ops for some spawn modes, but someone who wants the fastest possible spawn will want to avoid those modes anyway.\n\nStill trying to think if we can do better than a global refcount.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21286391/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/23034775",
    "html_url": "https://github.com/rust-lang/rust/issues/7702#issuecomment-23034775",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7702",
    "id": 23034775,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzMDM0Nzc1",
    "user": {
      "login": "toddaaro",
      "id": 366431,
      "node_id": "MDQ6VXNlcjM2NjQzMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/toddaaro",
      "html_url": "https://github.com/toddaaro",
      "followers_url": "https://api.github.com/users/toddaaro/followers",
      "following_url": "https://api.github.com/users/toddaaro/following{/other_user}",
      "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions",
      "organizations_url": "https://api.github.com/users/toddaaro/orgs",
      "repos_url": "https://api.github.com/users/toddaaro/repos",
      "events_url": "https://api.github.com/users/toddaaro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/toddaaro/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-21T17:31:27Z",
    "updated_at": "2013-08-21T17:31:27Z",
    "body": "What exactly is the issue here? I don't quite see it. The current implementation is such that we shouldn't be getting early shutdown due to how handles to schedulers keep the scheduler alive. If we are missing a case due to how task killing interacts I can start thinking about this.\n\nThe hole that might exist is the main task sending Shutdown to all the schedulers while there is still work to do, but as long as work exists we can't lose all the schedulers, but maybe we would lose a fraction of the schedulers with outstanding work. A solution might be to put a set of SchedHandles inside each scheduler struct, and then having the \"I am actually really done\" logic for a scheduler destruct them. Then when all the scheduler's are done and these handles drop all the schedulers shutdown together.\n\nI'm not opposed to a global refcount though. This is a high-performance scalable datastructure for doing parallel refcounts, so it could be a good fit. If we moved to something like this for shutdown a lot of other logic in the scheduler would become simpler, and we could eliminate the sleeper list in favor of checking this.\nhttp://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.83.3091&rep=rep1&type=pdf\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/23034775/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/23059928",
    "html_url": "https://github.com/rust-lang/rust/issues/7702#issuecomment-23059928",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7702",
    "id": 23059928,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzMDU5OTI4",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-22T00:03:01Z",
    "updated_at": "2013-08-22T00:03:44Z",
    "body": "My latest leading plan is to use a global population counter that is only accessed by the \"root\" tasks in the \"watched task trees\", sort of a best-of-both-worlds between my idea and brian's idea.\n\nI attempted to implement this, but we don't have a mechanism for global (cross-scheduler) data except for using static mut variables, and those are broken when running stdtest because we end up with two copies of each one. As such it works fine for any programs run outside of libstd, but it breaks stdtest itself.\n\nHowever the logic for this plan can be seen at: https://github.com/bblum/rust/commit/ac4c3931f315b04d42e89b528a110b12dade5d4b\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/23059928/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32581314",
    "html_url": "https://github.com/rust-lang/rust/issues/7702#issuecomment-32581314",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/7702",
    "id": 32581314,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTgxMzE0",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-17T05:36:35Z",
    "updated_at": "2014-01-17T05:36:35Z",
    "body": "Closing, each pool of schedulers has a shared counter of live tasks with a shared channel back to the task that will shut down the pool. Only after the entire pool of tasks has been drained do the schedulers actually get shut down.\n\nFrom the looks of it, this issue sounds like it was asking for something along those lines.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32581314/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
