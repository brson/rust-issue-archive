[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/37239314",
    "html_url": "https://github.com/rust-lang/rust/issues/9546#issuecomment-37239314",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/9546",
    "id": 37239314,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MjM5MzE0",
    "user": {
      "login": "dotdash",
      "id": 230962,
      "node_id": "MDQ6VXNlcjIzMDk2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dotdash",
      "html_url": "https://github.com/dotdash",
      "followers_url": "https://api.github.com/users/dotdash/followers",
      "following_url": "https://api.github.com/users/dotdash/following{/other_user}",
      "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions",
      "organizations_url": "https://api.github.com/users/dotdash/orgs",
      "repos_url": "https://api.github.com/users/dotdash/repos",
      "events_url": "https://api.github.com/users/dotdash/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dotdash/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-03-10T21:51:56Z",
    "updated_at": "2014-03-10T21:51:56Z",
    "body": "LLVM already has some optimization support for pointers that are known not to be null. Unfortunately as far as function arguments are concerned, that only covers those with the `sret` or `inalloca` attribute. I brought the topic up in #llvm. Here's a transcript:\n\n```\n21:52:43 <doener> Talking about rust, we have an open issue about improvintour IR for pointers \n                  that are guaranteed to be non-null. Pointers for sret and inalloca arguments \n                  are already marked as known not to be null. I wonder if there's a way to \n                  mark other pointers as such, or if a new attribute would be required (and if \n                  so, if it would be welcome).\n21:53:29 <nlewycky> a new attribute would be required\n21:53:34 <nlewycky> last time this came up i made a counter-proposal\n21:53:46 <nlewycky> instead of simply \"non-null\" which only allows us to eliminate \"x == null\" \n                    checks\n21:54:00 <nlewycky> how about \"k bytes of ptr are dereferencable\"?\n21:54:19 <nlewycky> this allows us to do things like remove null checks (can't dereference \n                    null) and also hoist loads out of loops, etc.\n21:54:37 <nlewycky> we could also use this for c++ references, for example\n21:56:35 <zygoloid> dereferenceable(ptrtoint i8* (getelementptr {ty, i8}* null, 0, 1) to i32) ?\n21:57:22 <nlewycky> nope. let's make it an integer.\n21:57:32 <zygoloid> that is an integer :)\n21:57:57 <zygoloid> apart from my errors in writing IR, that should be sizeof(ty)\n21:57:59 <nlewycky> llvm attributes can either by no-argument, string argument or integer \n                    argument, not llvm ir.\n21:58:24 <zygoloid> but...but... i wanna use the size of an opaque type ;)\n21:58:35 <nlewycky> ...and this is exactly why\n21:58:41 <nlewycky> wait\n21:58:50 <nlewycky> are you saying you want to compile code that passes forward declared \n                    references around\n21:58:57 <zygoloid> yes please\n21:58:58 <nlewycky> then resolves the number of dereferencable bytes at lto time?\n21:59:03 <zygoloid> :)\n21:59:07 <zygoloid> that is what i want\n21:59:08  * nlewycky sighs loudly\n22:00:24 <zygoloid> nlewycky: but, you know, i'm ok punting on this\n22:00:39 <zygoloid> i don't think it matters in practice, because the type must be complete \n                    anywhere you actaully have a use of it\n22:00:51 <nlewycky> okay that's what i thought\n22:00:57 <nlewycky> i was trying to imagine how this could possibly matter\n22:01:00 <zygoloid> so we can just emit dereferenceable(1), and ask LTO to take the max\n22:01:46 <nlewycky> if you unconditionally pass a pointer to a callee that is marked \n                    dereferencable(n), your pointer may also be marked deref(n). \n                    implementation goes in functionattrs please.\n22:02:19 <zygoloid> nlewycky: i was thinking the same thing :)\n22:02:59 <zygoloid> nlewycky: can we mark loads as deref(n) too?\n22:03:23 <zygoloid> when i load my reference, i want to express to llvm that the resulting \n                    pointer is dereferenceable\n22:03:30 <nlewycky> ahhh\n22:03:33  * nlewycky ponders\n22:03:57 <zygoloid> how do you express the lifetime of a deref(n)?\n22:03:57 <nlewycky> gosh, i guess you can.\n22:04:23 <zygoloid> how do i retain deref(n) after inlining?\n22:04:29 <nlewycky> er ... no. this is a static marker. you don't get to change it.\n22:04:41 <zygoloid> then i can't use it for references, i think?\n22:04:52 <nlewycky> huh? you can't rebind a reference\n22:04:58 <zygoloid> no, but a reference's lifetime can end\n22:04:59 <nlewycky> it's propagated via functionattrs, used by the local optz'ns, discarded by \n                    the inliner.\n22:05:35 <zygoloid> ok, so i think this is actually fine\n22:06:01 <zygoloid> deref(n) remains true for any use of the pointer, and stops being true at \n                    the last use\n22:06:34 <zygoloid> but this gets us into the 'same pointer value' pain\n22:07:18 <zygoloid> eg, union { struct X { int &r; } x; struct Y { char &c; } y; };\n22:07:55 <zygoloid> if i observe that the pointer is a dereferenceable pointer to 4 bytes (for \n                    the first union member), then i change the active member to y...\n22:08:21 <nlewycky> you get to derive minimal safe dereference from the type system\n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/37239314/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/37266795",
    "html_url": "https://github.com/rust-lang/rust/issues/9546#issuecomment-37266795",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/9546",
    "id": 37266795,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MjY2Nzk1",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-03-11T06:24:55Z",
    "updated_at": "2014-03-11T06:24:55Z",
    "body": "An attribute won't really be enough, because the information is lost after inlining.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/37266795/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/37722273",
    "html_url": "https://github.com/rust-lang/rust/issues/9546#issuecomment-37722273",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/9546",
    "id": 37722273,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3NzIyMjcz",
    "user": {
      "login": "dotdash",
      "id": 230962,
      "node_id": "MDQ6VXNlcjIzMDk2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dotdash",
      "html_url": "https://github.com/dotdash",
      "followers_url": "https://api.github.com/users/dotdash/followers",
      "following_url": "https://api.github.com/users/dotdash/following{/other_user}",
      "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions",
      "organizations_url": "https://api.github.com/users/dotdash/orgs",
      "repos_url": "https://api.github.com/users/dotdash/repos",
      "events_url": "https://api.github.com/users/dotdash/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dotdash/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-03-15T10:16:14Z",
    "updated_at": "2014-03-15T10:16:14Z",
    "body": "Do you have an example where the information is needed after inlining (or more generally, where the information is useful for a pointer that is neither an argument to the function nor is it dereferenced)?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/37722273/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/43709963",
    "html_url": "https://github.com/rust-lang/rust/issues/9546#issuecomment-43709963",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/9546",
    "id": 43709963,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzA5OTYz",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-05-21T03:53:37Z",
    "updated_at": "2014-05-21T03:53:48Z",
    "body": "@dotdash: #11751 is an example where the information is likely lost during inlining. The `next` method on iterators returns `Option<&T>`, and internally it has raw pointers. It's known to the non-null when the `&T` reference is being passed to the `Some` constructor, but then it's lost information after the `Some` constructor is inlined.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/43709963/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/44099598",
    "html_url": "https://github.com/rust-lang/rust/issues/9546#issuecomment-44099598",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/9546",
    "id": 44099598,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MDk5NTk4",
    "user": {
      "login": "luqmana",
      "id": 287063,
      "node_id": "MDQ6VXNlcjI4NzA2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luqmana",
      "html_url": "https://github.com/luqmana",
      "followers_url": "https://api.github.com/users/luqmana/followers",
      "following_url": "https://api.github.com/users/luqmana/following{/other_user}",
      "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions",
      "organizations_url": "https://api.github.com/users/luqmana/orgs",
      "repos_url": "https://api.github.com/users/luqmana/repos",
      "events_url": "https://api.github.com/users/luqmana/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luqmana/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-05-24T20:57:01Z",
    "updated_at": "2014-05-24T20:57:01Z",
    "body": "With #14306 we get better in some cases:\n\n``` Rust\n#[no_mangle]\npub fn foo(x: &int) -> bool {\n    Some(x) == None\n}\n```\n\n`rustc foo.rs -O --emit=ir`:\n\n``` llvm\n; Function Attrs: nounwind readonly uwtable\ndefine i8 @foo(i64* nocapture nonnull) unnamed_addr #0 {\n\"_ZN6option30Option$LT$T$GT$...std..cmp..Eq2eq21h172342516211389848784v0.0E.exit\":\n  ret i8 0\n}\n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/44099598/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/352732172",
    "html_url": "https://github.com/rust-lang/rust/issues/9546#issuecomment-352732172",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/9546",
    "id": 352732172,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1MjczMjE3Mg==",
    "user": {
      "login": "hanna-kruppe",
      "id": 2311707,
      "node_id": "MDQ6VXNlcjIzMTE3MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2311707?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hanna-kruppe",
      "html_url": "https://github.com/hanna-kruppe",
      "followers_url": "https://api.github.com/users/hanna-kruppe/followers",
      "following_url": "https://api.github.com/users/hanna-kruppe/following{/other_user}",
      "gists_url": "https://api.github.com/users/hanna-kruppe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hanna-kruppe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hanna-kruppe/subscriptions",
      "organizations_url": "https://api.github.com/users/hanna-kruppe/orgs",
      "repos_url": "https://api.github.com/users/hanna-kruppe/repos",
      "events_url": "https://api.github.com/users/hanna-kruppe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hanna-kruppe/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2017-12-19T12:12:36Z",
    "updated_at": "2017-12-19T12:12:36Z",
    "body": "I believe this issue should be closed. It's vague, and despite this vagueness addressed as much as we can hope to without fundamentally altering LLVM:\r\n\r\n1. The example at the top is (still) optimized to a constant `false`.\r\n2. We do emit `deferencable` attributes (which implies non-null) for function arguments and return values (at least when passed as immediates).\r\n3. We emit `!nonnull` metadata on instructions that load a reference from memory. This covers arguments and return values not covered by the previous point (including aggregates that contain references), and also most locals, which are mostly codegen'd as stack slots that are loaded from on use.\r\n4. We don't seem have any such metadata or attributes for SSA temporaries, but this is because LLVM doesn't have a good way to express those. There's `assume` but AFAIK we are deliberately conservative with those because they can cause performance regressions. LLVM also generally doesn't introduce assumes when it turns a stack slot with `!nonnull` loads into SSA values. It just loses the information.\r\n\r\n[(playground for testing)](https://play.rust-lang.org/?gist=815be443c788834c1290d8356242d6e9&version=stable)\r\n\r\nI'll also point out that non-nullness of references is a special case of communicating invalid values to LLVM. For example, that references are always aligned or that `bool` is 0 or 1. The latter is addressed with `!range` metadata on loads IIRC.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/352732172/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
