[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32084277",
    "html_url": "https://github.com/rust-lang/rust/pull/11462#issuecomment-32084277",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11462",
    "id": 32084277,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDg0Mjc3",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-11T02:30:24Z",
    "updated_at": "2014-01-11T02:30:24Z",
    "body": "Is it really necessary to have the \"held\" variable?\n\nIsn't it possible to use the pthread mutex itself to figure it if it's held, by unconditionally trylocking after push in lock(), and by unlocking it before (not after like in the current code!) pop() in unlock()?\n\nNote that this probably needs an explicit memory fence in both paths.\n\nThe invariant is of course that if the pthread lock is locked, everything on the queue will be woken up eventually.\n\nYou would have the issue that the \"memory of a mutex must be guaranteed to be valid until _all unlocks_ have returned\", but I don't think this is a problem in Rust where you can't just free memory arbitrarily like in C and always have a reference count that protects shared memory.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32084277/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32084434",
    "html_url": "https://github.com/rust-lang/rust/pull/11462#issuecomment-32084434",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11462",
    "id": 32084434,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDg0NDM0",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-11T02:38:08Z",
    "updated_at": "2014-01-11T02:38:08Z",
    "body": "If the point of this mutex is to be _the_ mutex, then the clause I mentioned is incredibly important in my opinion. That's the exact problem that a mutex is trying to solve (wait for a time at which it's ok to do something). Most rust code wouldn't be susceptible to that condition, but any code that is susceptible is really going to need it (and otherwise won't have a solution in libstd.\n\nYou also can't pop outside of the lock because it's a single-consumer queue.\n\nI would _love_ to get rid of the `held` flag, but I thought about this for two days and couldn't come up with anything better.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32084434/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32084905",
    "html_url": "https://github.com/rust-lang/rust/pull/11462#issuecomment-32084905",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11462",
    "id": 32084905,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDg0OTA1",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-11T03:01:52Z",
    "updated_at": "2014-01-11T03:16:51Z",
    "body": "The problem that the mutex is trying to solve is mainly making sure that the code protected by a single mutex is globally serialized, not that as soon as you unlock it and know that nothing else is going to lock it again you can kill the structure .\n\nFiguring out when you can kill the structure is generally the job of the reference count in the structure containing the mutex; I'm not even sure that all native OS mutexes provide that guarantee (EDIT: POSIX requires that it is provided, Windows seems to say nothing).\n\nRust code without unsafe code that breaks Rust semantics cannot be affected because to call unlock() you need to pass an &mut to the mutex, and if that &mut is reborrowed, then the original &mut it is reborrowed from will continue to be semantically valid just after the unlock() call, and thus the memory must continue to be valid after the unlock(), making it irrelevant whether unlock() touches the memory or not after unlocking.\n\n> You also can't pop outside of the lock because it's a single-consumer queue.\n\nThat's a serious issue though.\n\nA possible solution is to wrap the q.pop() in an additional pthread mutex used only for that, and also keep an atomic int with the queue size, which would allow to skip taking the lock and popping when it is zero.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32084905/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32088046",
    "html_url": "https://github.com/rust-lang/rust/pull/11462#issuecomment-32088046",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11462",
    "id": 32088046,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDg4MDQ2",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-11T05:34:36Z",
    "updated_at": "2014-01-11T05:34:36Z",
    "body": "BTW, it's possible to create a mutex providing that guarantee using a mutex that doesn't, by boxing the mutex that doesn't in an UnsafeArc, and keeping a clone of the UnsafeArc in the lock guard for the mutex wrapper.\n\nBut as already argued no proper Rust code can need that guarantee, and anyway the sensible way of doing things is to put the mutex and the data it protects inside an Arc or RWARC, where the Arc or RWARC reference count determines when to destroy the object independently of the mutex.\n\nSo I think that guarantee is unimportant for Rust and should only be provided if it can be provided for free, which doesn't seem to be the case.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32088046/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32192858",
    "html_url": "https://github.com/rust-lang/rust/pull/11462#issuecomment-32192858",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11462",
    "id": 32192858,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTkyODU4",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-13T17:49:05Z",
    "updated_at": "2014-01-13T22:37:49Z",
    "body": "I think I have found a lockless algorithm that works.\n\nNote that it requires support for 64-bit atomics even on 32-bit platforms, and either limits tasks to 2^32 or requires 128-bit atomics on 64-bit platforms.\n\nHowever, while libstd doesn't currently implement those, 64-bit atomics are available on all modern 32-bit x86 and ARM systems (x86 >= Pentium Pro, ARM >= ARMv6).\n\nThe idea is that we hold the state in an atomic (u32, u32) called (queue_size, lockers).\n\nLockers is the number of threads that are about to call lock() on the internal lock or that hold the internal lock; queue_size is the number of queued tasks.\n\nBasically the \"held\" variable is replaced by lockers != 0, and having queue_size in the same atomic value allows to do the held check and enqueuing atomically.\n\nThe \"atomically\" blocks are to be implemented with compare-and-swap, the queue using the intrusive MPSC queue already written.\n\n```\n// try_lock() {\n//     if atomically {queue_size == 0 && lockers == 0} && lock.try_lock() {\n//         if atomically {let b = queue_size == 0; if b {++lockers; true} else {false}} {\n//             ok\n//         } else {\n//             lock.unlock()\n//             fail\n//         }\n//     } else {\n//         fail\n//     }\n// }\n// \n// lock() {\n//     if try_lock() {\n//         return guard;\n//     }\n//\n//     if can_block && atomically {let b = queue_size == 0; if b {++lockers; true} else {false}} {\n//         lock.lock();\n//     } else {\n//         q.push();\n//         if atomically {++queue_size; if(lockers == 0) {++lockers; true} else {false}} {\n//             // this never blocks indefinitely\n//             // this is because lockers was 0, so we have no one having or trying to get the lock\n//             // and we atomically set queue_size to a positive value, so no one will start blocking\n//             lock.lock();\n//             atomically {--queue_size}\n//             t = q.pop();\n//             if t != ourselves {\n//                 t.wakeup();\n//                 go to sleep\n//             }\n//         } else {\n//             go to sleep\n//         }\n//     }\n// }\n// \n// unlock() {\n//     if atomically {if(queue_size != 0 && lockers == 1) {--queue_size; true} else {--lockers; false}} {\n//         t = q.pop();\n//         t.wakeup();\n//     } else {\n//         lock.unlock()\n//     }\n// }\n```\n\nTransitions:\n\n```\n(0, lockers) => (0, lockers + 1) // task locks with nothing queued\n(queue_size, lockers > 1) => (queue_size, lockers - 1) // task unlocks with native task waiting\n(0, 1) => (0, 0) // task unlocks with nothing else waiting\n\n(queue_size, lockers) => (queue_size + 1, lockers) // task queues up\n(queue_size > 0, 1) => (queue_size - 1, lockers) // task unlocks, waking up queued task\n```\n\nEDIT: changed to now also be globally fair\n\nThe idea is that if lockers > 1, we don't pop the queue, but rather just unlock, which means that queued native tasks get run.\n\nNew native tasks instead queue up due to queue_size != 0\n\nEDIT 2: added try_lock, fixed lock to use it and not have a race that caused blocking on green tasks\n\nEDIT 3: and if we replace the MPSC queue implementation with one using list reversal, we can remove the last yields\n\nEDIT 4: implemented this in pull #11520, suggesting to consider that pull requests as an improvement over the code in this one (assuming the algorithm indeed works)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32192858/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32298484",
    "html_url": "https://github.com/rust-lang/rust/pull/11462#issuecomment-32298484",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11462",
    "id": 32298484,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMjk4NDg0",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-14T19:29:27Z",
    "updated_at": "2014-01-14T19:29:27Z",
    "body": "Closing, adding another crucial `Thread::yield_now()` makes me cringe, and #11520 looks like a much better alternative.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32298484/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
