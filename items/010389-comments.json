[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/28145050",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-28145050",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 28145050,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MTQ1MDUw",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-11-10T06:22:08Z",
    "updated_at": "2013-11-10T06:22:08Z",
    "body": "I'm not entirely sure how feasible it is for a program to have `0x366a806b1d5f1b2` node ids (2.5 trillion), but this is still concerning.\n\nWe could in theory have very cheap inequality among types, and then have an expensive equality check. Something which may walk the respective `TyDesc` structures in parallel to make sure that they're the same. We could also bump up the hash size to using something like sha1/sha2 and have the `type_id()` intrinsic return `[u8, ..N]` to reduce the possibility of a collision.\n\nEither way, I don't think that this is a super-pressing issue for now, but I'm nominating to discuss whether we want to get this done for 1.0. This could in theory have serious implications depending on how frequently `Any` is used.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/28145050/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/28145053",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-28145053",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 28145053,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MTQ1MDUz",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-11-10T06:22:20Z",
    "updated_at": "2013-11-10T06:22:20Z",
    "body": "Ah, it was already nominated!\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/28145053/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/28146291",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-28146291",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 28146291,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MTQ2Mjkx",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-11-10T08:17:12Z",
    "updated_at": "2013-11-10T08:22:14Z",
    "body": "Why not compare an interned version of the type data string? (i.e. what is currently passed as data to be hashed, possibly SHA-256 hashed first)\n\nThe linker can be used for interning by emitting a common symbol with the type data string as name and taking its address, and otherwise the same thing can be done manually in a global constructor.\n\nThis way it's always a pointer comparison, and there are no collisions.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/28146291/reactions",
      "total_count": 8,
      "+1": 8,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/28170402",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-28170402",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 28170402,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MTcwNDAy",
    "user": {
      "login": "DaGenix",
      "id": 2101211,
      "node_id": "MDQ6VXNlcjIxMDEyMTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2101211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DaGenix",
      "html_url": "https://github.com/DaGenix",
      "followers_url": "https://api.github.com/users/DaGenix/followers",
      "following_url": "https://api.github.com/users/DaGenix/following{/other_user}",
      "gists_url": "https://api.github.com/users/DaGenix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DaGenix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DaGenix/subscriptions",
      "organizations_url": "https://api.github.com/users/DaGenix/orgs",
      "repos_url": "https://api.github.com/users/DaGenix/repos",
      "events_url": "https://api.github.com/users/DaGenix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DaGenix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-11-11T03:07:14Z",
    "updated_at": "2013-11-11T03:07:14Z",
    "body": "I don't know how node id values are generated, but assuming that they are generated sequentially, this particular collision is not realistic. However, its not hard to find collisions for more realistic node id values by picking particular  values for the crate hashes:\n\n``` rust\nassert!(hash_struct(\"a2c55ca1a1f68\", 4080) == hash_struct(\"138b8278caab5\", 2804));\n```\n\nThe key thing to consider isn't the number of node id values, though: its the total number of type id values. Some quick (hopefully correct) math shows that there is a 0.01% chance of a collision once there are around 60 million type id values. That's still a pretty large number of type id values for a somewhat low probability of a collision, thought. So, its unclear to me how big a deal this is for the Rust 1.0 timeframe. It all depends on what the acceptable probability of a collision is.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/28170402/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/28206409",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-28206409",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 28206409,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MjA2NDA5",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-11-11T15:01:40Z",
    "updated_at": "2013-11-11T15:01:40Z",
    "body": "When I saw that @alexcrichton proposed using a hash, my first reaction was \"collision!\" but then I thought \"...but exceedingly unlikely to occur in practice\". I think this is not a matter of imminent destruction but if we can leverage the linker or some other scheme to avoid this danger, we should -- and perhaps we should just go ahead and mark the current scheme as deprecated and just plan on finding a replacement scheme.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/28206409/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/28207936",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-28207936",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 28207936,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MjA3OTM2",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-11-11T15:18:44Z",
    "updated_at": "2013-11-11T15:19:50Z",
    "body": "A cryptographic hash designed for this purpose (larger output) would be enough. Although, a larger output would be more expensive to compare (four `u64` comparisons for SHA2).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/28207936/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/29009781",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-29009781",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 29009781,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI5MDA5Nzgx",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-11-21T18:26:18Z",
    "updated_at": "2013-11-21T18:26:18Z",
    "body": "We don't need to deal with this right now.  P-low.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/29009781/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/70719932",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-70719932",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 70719932,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwNzE5OTMy",
    "user": {
      "login": "steveklabnik",
      "id": 27786,
      "node_id": "MDQ6VXNlcjI3Nzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/steveklabnik",
      "html_url": "https://github.com/steveklabnik",
      "followers_url": "https://api.github.com/users/steveklabnik/followers",
      "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}",
      "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions",
      "organizations_url": "https://api.github.com/users/steveklabnik/orgs",
      "repos_url": "https://api.github.com/users/steveklabnik/repos",
      "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/steveklabnik/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-20T19:49:13Z",
    "updated_at": "2015-01-20T19:49:13Z",
    "body": "How relevant is this issue today? I think that it's all the same, but am not sure.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/70719932/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/70747534",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-70747534",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 70747534,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwNzQ3NTM0",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-20T22:28:09Z",
    "updated_at": "2015-01-20T22:28:09Z",
    "body": "It's 64-bit so collisions are _likely_ with enough types (consider recursive type metaprogramming) and it doesn't have any check to bail out if one occurs. Bailing out is not a very good solution anyway, because it pretty much means that there's no way to compile the program, beyond using a different random seed and hoping for the best. It's a crappy situation.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/70747534/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/70843967",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-70843967",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 70843967,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwODQzOTY3",
    "user": {
      "login": "vks",
      "id": 33460,
      "node_id": "MDQ6VXNlcjMzNDYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/33460?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vks",
      "html_url": "https://github.com/vks",
      "followers_url": "https://api.github.com/users/vks/followers",
      "following_url": "https://api.github.com/users/vks/following{/other_user}",
      "gists_url": "https://api.github.com/users/vks/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vks/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vks/subscriptions",
      "organizations_url": "https://api.github.com/users/vks/orgs",
      "repos_url": "https://api.github.com/users/vks/repos",
      "events_url": "https://api.github.com/users/vks/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vks/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-21T14:16:43Z",
    "updated_at": "2015-01-21T14:16:43Z",
    "body": "Note that \"hoping for the best\" by iteratively changing the seed might work with overwhelmingly large probability after very few iterations.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/70843967/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/147919570",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-147919570",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 147919570,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE0NzkxOTU3MA==",
    "user": {
      "login": "sorear",
      "id": 92735,
      "node_id": "MDQ6VXNlcjkyNzM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/92735?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sorear",
      "html_url": "https://github.com/sorear",
      "followers_url": "https://api.github.com/users/sorear/followers",
      "following_url": "https://api.github.com/users/sorear/following{/other_user}",
      "gists_url": "https://api.github.com/users/sorear/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sorear/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sorear/subscriptions",
      "organizations_url": "https://api.github.com/users/sorear/orgs",
      "repos_url": "https://api.github.com/users/sorear/repos",
      "events_url": "https://api.github.com/users/sorear/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sorear/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-10-14T03:24:55Z",
    "updated_at": "2015-10-14T03:24:55Z",
    "body": "``` rust\nuse std::any::Any;\n\nfn main() {\n    let weird : [([u8; 188250],[u8; 1381155],[u8; 558782]); 0] = [];\n    let whoops = Any::downcast_ref::<[([u8; 1990233],[u8; 798602],[u8; 2074279]); 1]>(&weird);\n    println!(\"{}\",whoops.unwrap()[0].0[333333]);\n}\n```\n\nActually a soundness issue.  playground: http://is.gd/TwBayX\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/147919570/reactions",
      "total_count": 12,
      "+1": 12,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/148991284",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-148991284",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 148991284,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE0ODk5MTI4NA==",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-10-18T08:34:43Z",
    "updated_at": "2015-10-18T08:34:43Z",
    "body": "I'd like the lang team to devote a little time to this now that we are post 1.0.  Nominating  \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/148991284/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/152342237",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-152342237",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 152342237,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1MjM0MjIzNw==",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-10-29T22:09:16Z",
    "updated_at": "2015-10-29T22:11:29Z",
    "body": "OK, lang team discussed it, and our conclusion was that:\n1. This issue ought to be fixed, it's silly not to.\n2. This is an implementation detail that we could change whenever we want (right?)\n3. Nonetheless, we probably ought to open an RFC or at least a discuss thread, with a proposal to do better, since probably people will have some clever ideas.\n4. Probably the runtime overhead of the virtual call in the `Any` trait is way more than a `strcmp` anyhow for all realistic types.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/152342237/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/152342608",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-152342608",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 152342608,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1MjM0MjYwOA==",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-10-29T22:11:09Z",
    "updated_at": "2015-10-29T22:11:09Z",
    "body": "I was wondering about a design where we do something like:\n- generate a static string representing the full type; in static builds, at least, this will be interned by the linker;\n- generate a hash\n\ncompare the string pointers for equality (to give a fast equality check). If that fails, compare the hashes for inequality (to give a fast inequality check). If THAT fails, compare the strings for content (to handle dynamic linking).\n\nAlthough re-reading the thread I see @bill-myers may have had an even more clever solution.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/152342608/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/152342909",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-152342909",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 152342909,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1MjM0MjkwOQ==",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-10-29T22:12:54Z",
    "updated_at": "2015-10-29T22:12:54Z",
    "body": "@nikomatsakis putting the hash of the data at the start is a good idea, to increase the probability that we catch unequal things quickly.   It seems to me like @bill-myers' approach composes fine with that strategy.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/152342909/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/152407773",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-152407773",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 152407773,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1MjQwNzc3Mw==",
    "user": {
      "login": "sorear",
      "id": 92735,
      "node_id": "MDQ6VXNlcjkyNzM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/92735?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sorear",
      "html_url": "https://github.com/sorear",
      "followers_url": "https://api.github.com/users/sorear/followers",
      "following_url": "https://api.github.com/users/sorear/following{/other_user}",
      "gists_url": "https://api.github.com/users/sorear/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sorear/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sorear/subscriptions",
      "organizations_url": "https://api.github.com/users/sorear/orgs",
      "repos_url": "https://api.github.com/users/sorear/repos",
      "events_url": "https://api.github.com/users/sorear/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sorear/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-10-30T03:51:45Z",
    "updated_at": "2015-10-30T03:51:45Z",
    "body": "I doubt the \"problem\" is limited to Any.  You can probably confuse the compiler just as effectively by colliding hashes for symbol mangling, or many other things.  What is the objective here?  Since Rust is not a sandbox language, I don't think \"protect memory from malicious programmers\" should be one of our goals (we should document the types of undefined behavior that can be hit in safe code, and fix the ones that are _possible_ to hit by accident; if someone is determined to break the type system, they can already write an unsafe block, or use std::process to launch a subprocess that ptraces its parent and corrupts memory).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/152407773/reactions",
      "total_count": 5,
      "+1": 1,
      "-1": 4,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/274780814",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-274780814",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 274780814,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3NDc4MDgxNA==",
    "user": {
      "login": "hmvp",
      "id": 1734544,
      "node_id": "MDQ6VXNlcjE3MzQ1NDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1734544?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hmvp",
      "html_url": "https://github.com/hmvp",
      "followers_url": "https://api.github.com/users/hmvp/followers",
      "following_url": "https://api.github.com/users/hmvp/following{/other_user}",
      "gists_url": "https://api.github.com/users/hmvp/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hmvp/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hmvp/subscriptions",
      "organizations_url": "https://api.github.com/users/hmvp/orgs",
      "repos_url": "https://api.github.com/users/hmvp/repos",
      "events_url": "https://api.github.com/users/hmvp/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hmvp/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2017-01-24T11:37:42Z",
    "updated_at": "2017-01-24T11:37:42Z",
    "body": "Thanks to: https://www.reddit.com/r/rust/comments/5pfwjr/mitigating_underhandedness_clippy/dcrew0k/\r\nhttps://is.gd/Xb7L5r\r\n\r\nThis example works on Beta and Nightly. \r\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/274780814/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/316555783",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-316555783",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 316555783,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNjU1NTc4Mw==",
    "user": {
      "login": "Mark-Simulacrum",
      "id": 5047365,
      "node_id": "MDQ6VXNlcjUwNDczNjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Mark-Simulacrum",
      "html_url": "https://github.com/Mark-Simulacrum",
      "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers",
      "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}",
      "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions",
      "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs",
      "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos",
      "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2017-07-19T23:58:10Z",
    "updated_at": "2017-07-19T23:58:10Z",
    "body": "@nikomatsakis Should this be marked as I-unsound? I've done so for now, since that seems to be the general conclusion a couple of times by different people, but please unmark if I'm wrong.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/316555783/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/360681018",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-360681018",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 360681018,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDY4MTAxOA==",
    "user": {
      "login": "withoutboats",
      "id": 9063376,
      "node_id": "MDQ6VXNlcjkwNjMzNzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9063376?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/withoutboats",
      "html_url": "https://github.com/withoutboats",
      "followers_url": "https://api.github.com/users/withoutboats/followers",
      "following_url": "https://api.github.com/users/withoutboats/following{/other_user}",
      "gists_url": "https://api.github.com/users/withoutboats/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/withoutboats/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/withoutboats/subscriptions",
      "organizations_url": "https://api.github.com/users/withoutboats/orgs",
      "repos_url": "https://api.github.com/users/withoutboats/repos",
      "events_url": "https://api.github.com/users/withoutboats/events{/privacy}",
      "received_events_url": "https://api.github.com/users/withoutboats/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-01-26T04:24:40Z",
    "updated_at": "2018-01-26T04:25:01Z",
    "body": "> You can probably confuse the compiler just as effectively by colliding hashes for symbol mangling, or many other things.\r\n\r\nWould any of these result in incorrect runtime behavior, or just bizarre compiler errors?\r\n\r\nEDIT: The comment I'm replying to is over 2 years old.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/360681018/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/360808816",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-360808816",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 360808816,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDgwODgxNg==",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-01-26T15:05:50Z",
    "updated_at": "2018-01-26T15:05:50Z",
    "body": "> Would any of these result in incorrect runtime behavior, or just bizarre compiler errors?\r\n\r\nIt could be unsound, if it fooled `Any` into an incorrect downcast.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/360808816/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/360891989",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-360891989",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 360891989,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDg5MTk4OQ==",
    "user": {
      "login": "withoutboats",
      "id": 9063376,
      "node_id": "MDQ6VXNlcjkwNjMzNzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9063376?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/withoutboats",
      "html_url": "https://github.com/withoutboats",
      "followers_url": "https://api.github.com/users/withoutboats/followers",
      "following_url": "https://api.github.com/users/withoutboats/following{/other_user}",
      "gists_url": "https://api.github.com/users/withoutboats/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/withoutboats/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/withoutboats/subscriptions",
      "organizations_url": "https://api.github.com/users/withoutboats/orgs",
      "repos_url": "https://api.github.com/users/withoutboats/repos",
      "events_url": "https://api.github.com/users/withoutboats/events{/privacy}",
      "received_events_url": "https://api.github.com/users/withoutboats/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-01-26T20:11:07Z",
    "updated_at": "2018-01-26T20:11:07Z",
    "body": "@nikomatsakis Right, I meant sorear's other examples (name mangling and such). The fact that this can cause a soundness bug separates it from other mishashes which would just result in a compiler error.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/360891989/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437016587",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-437016587",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 437016587,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzAxNjU4Nw==",
    "user": {
      "login": "SoniEx2",
      "id": 1779619,
      "node_id": "MDQ6VXNlcjE3Nzk2MTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1779619?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SoniEx2",
      "html_url": "https://github.com/SoniEx2",
      "followers_url": "https://api.github.com/users/SoniEx2/followers",
      "following_url": "https://api.github.com/users/SoniEx2/following{/other_user}",
      "gists_url": "https://api.github.com/users/SoniEx2/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SoniEx2/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SoniEx2/subscriptions",
      "organizations_url": "https://api.github.com/users/SoniEx2/orgs",
      "repos_url": "https://api.github.com/users/SoniEx2/repos",
      "events_url": "https://api.github.com/users/SoniEx2/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SoniEx2/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-08T14:42:04Z",
    "updated_at": "2018-11-08T14:42:04Z",
    "body": "[eventbus](https://crates.io/crates/eventbus) crate uses *a lot* of Any, as it encourages you to use a lot of different event types and emulated inheritance. this could become an issue...",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437016587/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437021724",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-437021724",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 437021724,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzAyMTcyNA==",
    "user": {
      "login": "SoniEx2",
      "id": 1779619,
      "node_id": "MDQ6VXNlcjE3Nzk2MTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1779619?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SoniEx2",
      "html_url": "https://github.com/SoniEx2",
      "followers_url": "https://api.github.com/users/SoniEx2/followers",
      "following_url": "https://api.github.com/users/SoniEx2/following{/other_user}",
      "gists_url": "https://api.github.com/users/SoniEx2/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SoniEx2/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SoniEx2/subscriptions",
      "organizations_url": "https://api.github.com/users/SoniEx2/orgs",
      "repos_url": "https://api.github.com/users/SoniEx2/repos",
      "events_url": "https://api.github.com/users/SoniEx2/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SoniEx2/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-08T14:53:11Z",
    "updated_at": "2018-11-08T14:54:20Z",
    "body": "What if, instead of making TypeId bigger, we add another implementation detail that works like eventbus?\r\n\r\nCalls to Any, TypeId, etc are converted into a set of static usize that get initialized at runtime.\r\n\r\nhttps://internals.rust-lang.org/t/static-generics/8734?u=soni\r\n\r\nwe can then use an expensive check (string lookup/comparison) *once* and use a cheap check every other time.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437021724/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437057045",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-437057045",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 437057045,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzA1NzA0NQ==",
    "user": {
      "login": "strega-nil",
      "id": 3479021,
      "node_id": "MDQ6VXNlcjM0NzkwMjE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3479021?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/strega-nil",
      "html_url": "https://github.com/strega-nil",
      "followers_url": "https://api.github.com/users/strega-nil/followers",
      "following_url": "https://api.github.com/users/strega-nil/following{/other_user}",
      "gists_url": "https://api.github.com/users/strega-nil/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/strega-nil/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/strega-nil/subscriptions",
      "organizations_url": "https://api.github.com/users/strega-nil/orgs",
      "repos_url": "https://api.github.com/users/strega-nil/repos",
      "events_url": "https://api.github.com/users/strega-nil/events{/privacy}",
      "received_events_url": "https://api.github.com/users/strega-nil/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-08T16:21:29Z",
    "updated_at": "2018-11-08T16:21:51Z",
    "body": "Why not use a pointer comparison of an `inline` symbol? VTables should work well, if we remove the thing where vtables can be distinct across TUs.\r\n\r\n(in C++)\r\n```cpp\r\ntemplate <typename T>\r\nstruct VtableForAny {\r\n  std::size_t size;\r\n  std::size_t align;\r\n\r\n  void (*destroy)(void *);\r\n};\r\ntemplate <typename T>\r\ninline VtableForAny<T> VTABLE_FOR_ANY = {\r\n  sizeof(T),\r\n  alignof(T),\r\n  T::~T(),\r\n};\r\n\r\nstruct Foo {\r\n};\r\n\r\ntemplate <typename T>\r\nT *downcast(AnyRef any) {\r\n  if (any.vtable == &VTABLE_FOR_ANY<T>) {\r\n    return static_cast<T*>(any.ptr);\r\n  } else {\r\n    return nullptr;\r\n  }\r\n}\r\n```\r\nWe could do a similar translation for Rust, and this is guaranteed to work by LLVM.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437057045/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437058914",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-437058914",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 437058914,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzA1ODkxNA==",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-08T16:26:23Z",
    "updated_at": "2018-11-08T16:26:23Z",
    "body": "> if we remove the thing where vtables can be distinct across TUs.\r\n\r\nI think that would not be easy.  It's not just TUs; if you create a trait object in a `const` then it will have a vtable generated by miri, and I am not sure if that will get deduplicated with the one generated for run-time use.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437058914/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 1,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437059223",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-437059223",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 437059223,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzA1OTIyMw==",
    "user": {
      "login": "hanna-kruppe",
      "id": 2311707,
      "node_id": "MDQ6VXNlcjIzMTE3MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2311707?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hanna-kruppe",
      "html_url": "https://github.com/hanna-kruppe",
      "followers_url": "https://api.github.com/users/hanna-kruppe/followers",
      "following_url": "https://api.github.com/users/hanna-kruppe/following{/other_user}",
      "gists_url": "https://api.github.com/users/hanna-kruppe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hanna-kruppe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hanna-kruppe/subscriptions",
      "organizations_url": "https://api.github.com/users/hanna-kruppe/orgs",
      "repos_url": "https://api.github.com/users/hanna-kruppe/repos",
      "events_url": "https://api.github.com/users/hanna-kruppe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hanna-kruppe/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-08T16:27:06Z",
    "updated_at": "2018-11-08T16:27:06Z",
    "body": "@ubsan \r\n> if we remove the thing where vtables can be distinct across TUs.\r\n\r\nWe can't, for the same reason generic statics couldn't be unique across TUs if we added them (dynamic linking on Windows, possibly other platforms).",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437059223/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437069139",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-437069139",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 437069139,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzA2OTEzOQ==",
    "user": {
      "login": "strega-nil",
      "id": 3479021,
      "node_id": "MDQ6VXNlcjM0NzkwMjE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3479021?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/strega-nil",
      "html_url": "https://github.com/strega-nil",
      "followers_url": "https://api.github.com/users/strega-nil/followers",
      "following_url": "https://api.github.com/users/strega-nil/following{/other_user}",
      "gists_url": "https://api.github.com/users/strega-nil/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/strega-nil/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/strega-nil/subscriptions",
      "organizations_url": "https://api.github.com/users/strega-nil/orgs",
      "repos_url": "https://api.github.com/users/strega-nil/repos",
      "events_url": "https://api.github.com/users/strega-nil/events{/privacy}",
      "received_events_url": "https://api.github.com/users/strega-nil/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-08T16:42:47Z",
    "updated_at": "2018-11-08T16:43:21Z",
    "body": "@rkruppe ah, yeah, forgot about dynamic linking. It's likely we'd have to do a strcmp then, in the case where addresses are distinct, so you'd likely get a fast path and a slow path.\r\n\r\n@ralfjung it's absolutely possible and, in fact, quite easy. It just requires a simple LLVM attribute.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437069139/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437076158",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-437076158",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 437076158,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzA3NjE1OA==",
    "user": {
      "login": "hanna-kruppe",
      "id": 2311707,
      "node_id": "MDQ6VXNlcjIzMTE3MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2311707?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hanna-kruppe",
      "html_url": "https://github.com/hanna-kruppe",
      "followers_url": "https://api.github.com/users/hanna-kruppe/followers",
      "following_url": "https://api.github.com/users/hanna-kruppe/following{/other_user}",
      "gists_url": "https://api.github.com/users/hanna-kruppe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hanna-kruppe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hanna-kruppe/subscriptions",
      "organizations_url": "https://api.github.com/users/hanna-kruppe/orgs",
      "repos_url": "https://api.github.com/users/hanna-kruppe/repos",
      "events_url": "https://api.github.com/users/hanna-kruppe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hanna-kruppe/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-08T16:57:55Z",
    "updated_at": "2018-11-08T16:57:55Z",
    "body": "What strings do you want to compare? Lacking a global namespace, the only way I know of to get a \"type name\" that won't be the same across different crates is using the crate disambiguator, which is a hash, which is therefore susceptible to the same sort of collision. Or can we arrange for such collisions always resulting in a linker error, even when the crates are only linked together dynamically and indirectly?",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437076158/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437077009",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-437077009",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 437077009,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzA3NzAwOQ==",
    "user": {
      "login": "strega-nil",
      "id": 3479021,
      "node_id": "MDQ6VXNlcjM0NzkwMjE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3479021?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/strega-nil",
      "html_url": "https://github.com/strega-nil",
      "followers_url": "https://api.github.com/users/strega-nil/followers",
      "following_url": "https://api.github.com/users/strega-nil/following{/other_user}",
      "gists_url": "https://api.github.com/users/strega-nil/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/strega-nil/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/strega-nil/subscriptions",
      "organizations_url": "https://api.github.com/users/strega-nil/orgs",
      "repos_url": "https://api.github.com/users/strega-nil/repos",
      "events_url": "https://api.github.com/users/strega-nil/events{/privacy}",
      "received_events_url": "https://api.github.com/users/strega-nil/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-08T17:00:17Z",
    "updated_at": "2018-11-08T17:01:15Z",
    "body": "@rkruppe the name of the type, I think? That should be globally unique.\r\n\r\n`crate_name::foo::bar::Baz`\r\n\r\nmaybe `crate_name:v0.1.0::foo::bar::Baz`",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437077009/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437077559",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-437077559",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 437077559,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzA3NzU1OQ==",
    "user": {
      "login": "hanna-kruppe",
      "id": 2311707,
      "node_id": "MDQ6VXNlcjIzMTE3MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2311707?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hanna-kruppe",
      "html_url": "https://github.com/hanna-kruppe",
      "followers_url": "https://api.github.com/users/hanna-kruppe/followers",
      "following_url": "https://api.github.com/users/hanna-kruppe/following{/other_user}",
      "gists_url": "https://api.github.com/users/hanna-kruppe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hanna-kruppe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hanna-kruppe/subscriptions",
      "organizations_url": "https://api.github.com/users/hanna-kruppe/orgs",
      "repos_url": "https://api.github.com/users/hanna-kruppe/repos",
      "events_url": "https://api.github.com/users/hanna-kruppe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hanna-kruppe/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-08T17:01:54Z",
    "updated_at": "2018-11-08T17:01:54Z",
    "body": "Crate names are not globally unique, and neither are (crate name, version) tuples.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437077559/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437083456",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-437083456",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 437083456,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzA4MzQ1Ng==",
    "user": {
      "login": "strega-nil",
      "id": 3479021,
      "node_id": "MDQ6VXNlcjM0NzkwMjE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3479021?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/strega-nil",
      "html_url": "https://github.com/strega-nil",
      "followers_url": "https://api.github.com/users/strega-nil/followers",
      "following_url": "https://api.github.com/users/strega-nil/following{/other_user}",
      "gists_url": "https://api.github.com/users/strega-nil/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/strega-nil/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/strega-nil/subscriptions",
      "organizations_url": "https://api.github.com/users/strega-nil/orgs",
      "repos_url": "https://api.github.com/users/strega-nil/repos",
      "events_url": "https://api.github.com/users/strega-nil/events{/privacy}",
      "received_events_url": "https://api.github.com/users/strega-nil/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-08T17:18:58Z",
    "updated_at": "2018-11-08T17:18:58Z",
    "body": "@rkruppe huh! then I guess whatever information we pass to the hash function :P",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437083456/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437088437",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-437088437",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 437088437,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzA4ODQzNw==",
    "user": {
      "login": "hanna-kruppe",
      "id": 2311707,
      "node_id": "MDQ6VXNlcjIzMTE3MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2311707?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hanna-kruppe",
      "html_url": "https://github.com/hanna-kruppe",
      "followers_url": "https://api.github.com/users/hanna-kruppe/followers",
      "following_url": "https://api.github.com/users/hanna-kruppe/following{/other_user}",
      "gists_url": "https://api.github.com/users/hanna-kruppe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hanna-kruppe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hanna-kruppe/subscriptions",
      "organizations_url": "https://api.github.com/users/hanna-kruppe/orgs",
      "repos_url": "https://api.github.com/users/hanna-kruppe/repos",
      "events_url": "https://api.github.com/users/hanna-kruppe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hanna-kruppe/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-08T17:33:46Z",
    "updated_at": "2018-11-08T17:36:43Z",
    "body": "The disambiguator is passed in using the `-C metadata` argument, rustc doesn't know where it comes from. Arguably that places it outside of the domain of rust and thus collisions of it aren't *our* soundness problem, but let's consider Rust workflows more broadly. Typically it's computed as a hash by Cargo, and AFAIK that hashing includes a whole ton of things that are impractical to put into the binary.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437088437/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437090405",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-437090405",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 437090405,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzA5MDQwNQ==",
    "user": {
      "login": "SoniEx2",
      "id": 1779619,
      "node_id": "MDQ6VXNlcjE3Nzk2MTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1779619?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SoniEx2",
      "html_url": "https://github.com/SoniEx2",
      "followers_url": "https://api.github.com/users/SoniEx2/followers",
      "following_url": "https://api.github.com/users/SoniEx2/following{/other_user}",
      "gists_url": "https://api.github.com/users/SoniEx2/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SoniEx2/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SoniEx2/subscriptions",
      "organizations_url": "https://api.github.com/users/SoniEx2/orgs",
      "repos_url": "https://api.github.com/users/SoniEx2/repos",
      "events_url": "https://api.github.com/users/SoniEx2/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SoniEx2/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-08T17:39:56Z",
    "updated_at": "2018-11-08T17:39:56Z",
    "body": "You can work around the generic statics issue the same way eventbus does it currently.\r\n\r\nLanguage support would be an improvement over using a macro, tho.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/437090405/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/440993788",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-440993788",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 440993788,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MDk5Mzc4OA==",
    "user": {
      "login": "SoniEx2",
      "id": 1779619,
      "node_id": "MDQ6VXNlcjE3Nzk2MTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1779619?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SoniEx2",
      "html_url": "https://github.com/SoniEx2",
      "followers_url": "https://api.github.com/users/SoniEx2/followers",
      "following_url": "https://api.github.com/users/SoniEx2/following{/other_user}",
      "gists_url": "https://api.github.com/users/SoniEx2/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SoniEx2/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SoniEx2/subscriptions",
      "organizations_url": "https://api.github.com/users/SoniEx2/orgs",
      "repos_url": "https://api.github.com/users/SoniEx2/repos",
      "events_url": "https://api.github.com/users/SoniEx2/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SoniEx2/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-22T10:59:19Z",
    "updated_at": "2018-11-22T11:01:45Z",
    "body": "So, first, for fixing the collisions:\r\n\r\n```\r\nstruct TypeId(&'static [&'static [&'static str]]);\r\n```\r\n\r\nWhy this specific layout? Three reasons:\r\n\r\n1. We want an identifier that's consistent across builds, so a string.\r\n2. We want an identifier that's relatively lightweight, so we want to reuse substrings, or a slice of strings.\r\n3. We want to handle generics, which contain identifiers, so a slice of slices of strings.\r\n\r\nSo, for example, we can end up with some of the following TypeIds:\r\n\r\n```\r\nTypeId(&[&[\"rustc-1.30\", \"cargo-1.30\", \"eventbus-0.4.0\", \"Handlers<T>\"], &[\"rustc-1.30\", \"cargo-1.30\", \"ircclient-0.1.0\", \"IrcLineEvent\"]])\r\nTypeId(&[&[\"rustc-1.30\", \"cargo-1.30\", \"std-1.30\", \"result\", \"Result<T, E>\"], &[\"rustc-1.30\", \"cargo-1.30\", \"eventbus-0.4.0\", \"Handlers<T>\"], &[\"rustc-1.30\", \"cargo-1.30\", \"ircclient-0.1.0\", \"IrcMessageEvent\"], &[\"rustc-1.30\", \"cargo-1.30\", \"eventbus-0.4.0\", \"MyError\"]])\r\n```\r\n\r\nNote that these are only examples and the real thing probably wouldn't look like this, but this shows the basic idea.\r\n\r\nIt's still possible to intentionally create collisions, ofc, but that's different from accidental collisions (what we're trying to prevent here).\r\n\r\nAlso note that these are still opaque, so the contents need not be unambiguous to humans, only to the compiler (or the debugger, if we want that...).",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/440993788/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/441337522",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-441337522",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 441337522,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MTMzNzUyMg==",
    "user": {
      "login": "thepowersgang",
      "id": 955596,
      "node_id": "MDQ6VXNlcjk1NTU5Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/955596?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thepowersgang",
      "html_url": "https://github.com/thepowersgang",
      "followers_url": "https://api.github.com/users/thepowersgang/followers",
      "following_url": "https://api.github.com/users/thepowersgang/following{/other_user}",
      "gists_url": "https://api.github.com/users/thepowersgang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thepowersgang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thepowersgang/subscriptions",
      "organizations_url": "https://api.github.com/users/thepowersgang/orgs",
      "repos_url": "https://api.github.com/users/thepowersgang/repos",
      "events_url": "https://api.github.com/users/thepowersgang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thepowersgang/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-24T02:10:42Z",
    "updated_at": "2018-11-24T02:10:42Z",
    "body": "@rkruppe With your comment about the metadata string, did you mean that it's \"safe\" to use it as a disambiguator between different versions of the same crate (be it versions or feature-sets), or that we _shouldn't_ use it (because with non-cargo workflows it may not be passed).\r\n\r\nStoring the type \"name\" and comparing that (potentially with a short hash for a fail-fast option) and trusting the `-C metadata` argument to be sufficient for disambiguation sounds like it could be the best option for reducing the chance of collisions.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/441337522/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/441357754",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-441357754",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 441357754,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MTM1Nzc1NA==",
    "user": {
      "login": "hanna-kruppe",
      "id": 2311707,
      "node_id": "MDQ6VXNlcjIzMTE3MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2311707?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hanna-kruppe",
      "html_url": "https://github.com/hanna-kruppe",
      "followers_url": "https://api.github.com/users/hanna-kruppe/followers",
      "following_url": "https://api.github.com/users/hanna-kruppe/following{/other_user}",
      "gists_url": "https://api.github.com/users/hanna-kruppe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hanna-kruppe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hanna-kruppe/subscriptions",
      "organizations_url": "https://api.github.com/users/hanna-kruppe/orgs",
      "repos_url": "https://api.github.com/users/hanna-kruppe/repos",
      "events_url": "https://api.github.com/users/hanna-kruppe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hanna-kruppe/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-24T10:25:48Z",
    "updated_at": "2018-11-24T10:25:48Z",
    "body": "I didn't really mean to recommend any course of action, just list constraints. One of them is that the metadata string is itself a hash in the typical workflow and thus could have collision.\r\n\r\nBut thinking about the options you gave, it seems to me that: if we are OK with a neglegible chance for collisions, we can achieve that (in principle, I don't know how large the collision risk is today) with a single hash. Well, assuming collisions in the crate disambiguator can't be detected -- I am not sure whether there is perhaps some clever use of the linker to detect them.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/441357754/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/441359003",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-441359003",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 441359003,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MTM1OTAwMw==",
    "user": {
      "login": "SoniEx2",
      "id": 1779619,
      "node_id": "MDQ6VXNlcjE3Nzk2MTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1779619?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SoniEx2",
      "html_url": "https://github.com/SoniEx2",
      "followers_url": "https://api.github.com/users/SoniEx2/followers",
      "following_url": "https://api.github.com/users/SoniEx2/following{/other_user}",
      "gists_url": "https://api.github.com/users/SoniEx2/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SoniEx2/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SoniEx2/subscriptions",
      "organizations_url": "https://api.github.com/users/SoniEx2/orgs",
      "repos_url": "https://api.github.com/users/SoniEx2/repos",
      "events_url": "https://api.github.com/users/SoniEx2/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SoniEx2/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2018-11-24T10:50:15Z",
    "updated_at": "2018-11-24T10:50:55Z",
    "body": "I have tricks to improve performance, but they need to come after this\r\n\r\n(am I even being understood? I have no idea if ppl can understand me but they often seem to ignore me)",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/441359003/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/458099758",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-458099758",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 458099758,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1ODA5OTc1OA==",
    "user": {
      "login": "eduardosm",
      "id": 761151,
      "node_id": "MDQ6VXNlcjc2MTE1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/761151?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eduardosm",
      "html_url": "https://github.com/eduardosm",
      "followers_url": "https://api.github.com/users/eduardosm/followers",
      "following_url": "https://api.github.com/users/eduardosm/following{/other_user}",
      "gists_url": "https://api.github.com/users/eduardosm/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eduardosm/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eduardosm/subscriptions",
      "organizations_url": "https://api.github.com/users/eduardosm/orgs",
      "repos_url": "https://api.github.com/users/eduardosm/repos",
      "events_url": "https://api.github.com/users/eduardosm/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eduardosm/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2019-01-28T11:44:19Z",
    "updated_at": "2019-01-28T11:44:19Z",
    "body": "What about keeping somewhere a \"cache\" of calculated TypeIds? That cache would store a TypeId-type pair for each type for which `TypeId::of::<T>` has been called.  If a collision is detected, another TypeId is calculated using a hash table collision resolution algorithm. So, TypeIds would be the index in a hash table with 2^64 buckets. With this approach, we can continue to use a 64-bit integer as TypeId (or maybe it could be reduced to 32-bit). However, this means that, if the cache is deleted, all crates should be compiled again.\r\n\r\nWe could also forbid TypeId zero, so `size_of::<Option<TypeId>>() == size_of::<TypeId>()`.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/458099758/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/523068908",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-523068908",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 523068908,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyMzA2ODkwOA==",
    "user": {
      "login": "icefoxen",
      "id": 1335133,
      "node_id": "MDQ6VXNlcjEzMzUxMzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1335133?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/icefoxen",
      "html_url": "https://github.com/icefoxen",
      "followers_url": "https://api.github.com/users/icefoxen/followers",
      "following_url": "https://api.github.com/users/icefoxen/following{/other_user}",
      "gists_url": "https://api.github.com/users/icefoxen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/icefoxen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/icefoxen/subscriptions",
      "organizations_url": "https://api.github.com/users/icefoxen/orgs",
      "repos_url": "https://api.github.com/users/icefoxen/repos",
      "events_url": "https://api.github.com/users/icefoxen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/icefoxen/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2019-08-20T15:31:55Z",
    "updated_at": "2019-08-20T15:32:20Z",
    "body": "A... well, not resolution, but partial mitigation might be achieved just by calculating the `TypeId` of all types in a compilation run and making sure they're unique.  This doesn't solve the problem but can at least make it noisy for an end-user instead of possibly silently failing.  Doesn't help the networked/IPC use case like `eventbus` much, but it's something.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/523068908/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/523073083",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-523073083",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 523073083,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyMzA3MzA4Mw==",
    "user": {
      "login": "SoniEx2",
      "id": 1779619,
      "node_id": "MDQ6VXNlcjE3Nzk2MTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1779619?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SoniEx2",
      "html_url": "https://github.com/SoniEx2",
      "followers_url": "https://api.github.com/users/SoniEx2/followers",
      "following_url": "https://api.github.com/users/SoniEx2/following{/other_user}",
      "gists_url": "https://api.github.com/users/SoniEx2/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SoniEx2/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SoniEx2/subscriptions",
      "organizations_url": "https://api.github.com/users/SoniEx2/orgs",
      "repos_url": "https://api.github.com/users/SoniEx2/repos",
      "events_url": "https://api.github.com/users/SoniEx2/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SoniEx2/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2019-08-20T15:41:49Z",
    "updated_at": "2019-08-20T15:41:49Z",
    "body": "eventbus is not networked/IPC. the idea was to use multiple dll's/so's.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/523073083/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/524588295",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-524588295",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 524588295,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyNDU4ODI5NQ==",
    "user": {
      "login": "dlight",
      "id": 179028,
      "node_id": "MDQ6VXNlcjE3OTAyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/179028?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dlight",
      "html_url": "https://github.com/dlight",
      "followers_url": "https://api.github.com/users/dlight/followers",
      "following_url": "https://api.github.com/users/dlight/following{/other_user}",
      "gists_url": "https://api.github.com/users/dlight/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dlight/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dlight/subscriptions",
      "organizations_url": "https://api.github.com/users/dlight/orgs",
      "repos_url": "https://api.github.com/users/dlight/repos",
      "events_url": "https://api.github.com/users/dlight/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dlight/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2019-08-24T23:36:12Z",
    "updated_at": "2019-08-24T23:37:06Z",
    "body": "Why doesn't `type_id` use a [perfect hash function](https://en.wikipedia.org/wiki/Perfect_hash_function) like [rust-phf](https://github.com/sfackler/rust-phf)?\r\n\r\n> In computer science, a perfect hash function for a set S is a hash function that maps distinct elements in S to a set of integers, **with no collisions**.",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/524588295/reactions",
      "total_count": 2,
      "+1": 1,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/524605532",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-524605532",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 524605532,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyNDYwNTUzMg==",
    "user": {
      "login": "bjorn3",
      "id": 17426603,
      "node_id": "MDQ6VXNlcjE3NDI2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bjorn3",
      "html_url": "https://github.com/bjorn3",
      "followers_url": "https://api.github.com/users/bjorn3/followers",
      "following_url": "https://api.github.com/users/bjorn3/following{/other_user}",
      "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions",
      "organizations_url": "https://api.github.com/users/bjorn3/orgs",
      "repos_url": "https://api.github.com/users/bjorn3/repos",
      "events_url": "https://api.github.com/users/bjorn3/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bjorn3/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2019-08-25T06:39:33Z",
    "updated_at": "2019-08-25T06:39:33Z",
    "body": "> Why doesn't type_id use a perfect hash function like rust-phf?\r\n\r\nBecause it already has to decide on type ids during codegen of one crate, at which point type ids from upstream crates are not yet known.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/524605532/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/525109206",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-525109206",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 525109206,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyNTEwOTIwNg==",
    "user": {
      "login": "dlight",
      "id": 179028,
      "node_id": "MDQ6VXNlcjE3OTAyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/179028?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dlight",
      "html_url": "https://github.com/dlight",
      "followers_url": "https://api.github.com/users/dlight/followers",
      "following_url": "https://api.github.com/users/dlight/following{/other_user}",
      "gists_url": "https://api.github.com/users/dlight/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dlight/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dlight/subscriptions",
      "organizations_url": "https://api.github.com/users/dlight/orgs",
      "repos_url": "https://api.github.com/users/dlight/repos",
      "events_url": "https://api.github.com/users/dlight/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dlight/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2019-08-27T02:29:08Z",
    "updated_at": "2019-08-27T02:29:08Z",
    "body": "> Because it already has to decide on type ids during codegen of one crate, at which point type ids from upstream crates are not yet known.\r\n\r\nPerhaps `type_id` should have some bits for a crate id, and some bits for the per-crate phf. This way you ensure there is no collisions.",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/525109206/reactions",
      "total_count": 8,
      "+1": 8,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/525110536",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-525110536",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 525110536,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyNTExMDUzNg==",
    "user": {
      "login": "tarcieri",
      "id": 797,
      "node_id": "MDQ6VXNlcjc5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/797?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tarcieri",
      "html_url": "https://github.com/tarcieri",
      "followers_url": "https://api.github.com/users/tarcieri/followers",
      "following_url": "https://api.github.com/users/tarcieri/following{/other_user}",
      "gists_url": "https://api.github.com/users/tarcieri/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tarcieri/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tarcieri/subscriptions",
      "organizations_url": "https://api.github.com/users/tarcieri/orgs",
      "repos_url": "https://api.github.com/users/tarcieri/repos",
      "events_url": "https://api.github.com/users/tarcieri/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tarcieri/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2019-08-27T02:35:31Z",
    "updated_at": "2019-08-27T02:38:20Z",
    "body": "Depending how nuts you want to go with it, you could use the package `checksum` (truncated to 128-bits) as e.g. a SipHash key, with the crate name and the rest of the type information as the SipHash input.\r\n\r\nNo idea how hard it'd be to make rustc aware of package checksums if it isn't already, but it should suffice to eliminate collisions so long as the names of crates within the same package are unique.\r\n\r\n> The output size of SipHash is only 64-bits\r\n\r\nNote that there's a variant of SipHash with a 128-bit output as well (although I'm guessing an implementation thereof is not available in-tree)",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/525110536/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/535603909",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-535603909",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 535603909,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUzNTYwMzkwOQ==",
    "user": {
      "login": "tema3210",
      "id": 30626872,
      "node_id": "MDQ6VXNlcjMwNjI2ODcy",
      "avatar_url": "https://avatars.githubusercontent.com/u/30626872?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tema3210",
      "html_url": "https://github.com/tema3210",
      "followers_url": "https://api.github.com/users/tema3210/followers",
      "following_url": "https://api.github.com/users/tema3210/following{/other_user}",
      "gists_url": "https://api.github.com/users/tema3210/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tema3210/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tema3210/subscriptions",
      "organizations_url": "https://api.github.com/users/tema3210/orgs",
      "repos_url": "https://api.github.com/users/tema3210/repos",
      "events_url": "https://api.github.com/users/tema3210/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tema3210/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2019-09-26T17:21:57Z",
    "updated_at": "2019-09-26T17:21:57Z",
    "body": "> Depending how nuts you want to go with it, you could use the package `checksum` (truncated to 128-bits) as e.g. a SipHash key, with the crate name and the rest of the type information as the SipHash input.\r\n> \r\n> No idea how hard it'd be to make rustc aware of package checksums if it isn't already, but it should suffice to eliminate collisions so long as the names of crates within the same package are unique.\r\n> \r\n> > The output size of SipHash is only 64-bits\r\n> \r\n> Note that there's a variant of SipHash with a 128-bit output as well (although I'm guessing an implementation thereof is not available in-tree)\r\n\r\nBut usage of more than 64 bit will change size of 'TypeId' struct. That's the worse. I like idea of making crate id bits a part of TypeId.\r\nIf we change the size of TypeId to 128 bits, then we can make first 64 bit be a crate id and second to crate local typeid which,in that case, can be built buy perfect hash function.",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/535603909/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633328889",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-633328889",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 633328889,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYzMzMyODg4OQ==",
    "user": {
      "login": "Y0ba",
      "id": 1163958,
      "node_id": "MDQ6VXNlcjExNjM5NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1163958?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Y0ba",
      "html_url": "https://github.com/Y0ba",
      "followers_url": "https://api.github.com/users/Y0ba/followers",
      "following_url": "https://api.github.com/users/Y0ba/following{/other_user}",
      "gists_url": "https://api.github.com/users/Y0ba/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Y0ba/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Y0ba/subscriptions",
      "organizations_url": "https://api.github.com/users/Y0ba/orgs",
      "repos_url": "https://api.github.com/users/Y0ba/repos",
      "events_url": "https://api.github.com/users/Y0ba/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Y0ba/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2020-05-25T01:00:52Z",
    "updated_at": "2020-05-25T01:00:52Z",
    "body": "I hit this bug when tried to create type map (`HashMap<TypeId, _>`) to store global data for some types. Since static variables with generic parameters from outer functions are not allowed (this pattern was used in previous version of app written in C#) type map was the only option. Types were auto-generated from existing Protobuf-files and there were few hundreds of them. Thankfully I was able to catch collision in test where I put all types inside map and checked if they exist.\r\n\r\nAnd I think this behavior (potential collisions) should be documented in `TypeId` and `Any` docs.",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633328889/reactions",
      "total_count": 7,
      "+1": 7,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633340396",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-633340396",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 633340396,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYzMzM0MDM5Ng==",
    "user": {
      "login": "withoutboats",
      "id": 9063376,
      "node_id": "MDQ6VXNlcjkwNjMzNzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9063376?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/withoutboats",
      "html_url": "https://github.com/withoutboats",
      "followers_url": "https://api.github.com/users/withoutboats/followers",
      "following_url": "https://api.github.com/users/withoutboats/following{/other_user}",
      "gists_url": "https://api.github.com/users/withoutboats/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/withoutboats/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/withoutboats/subscriptions",
      "organizations_url": "https://api.github.com/users/withoutboats/orgs",
      "repos_url": "https://api.github.com/users/withoutboats/repos",
      "events_url": "https://api.github.com/users/withoutboats/events{/privacy}",
      "received_events_url": "https://api.github.com/users/withoutboats/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2020-05-25T02:00:22Z",
    "updated_at": "2020-05-25T02:00:22Z",
    "body": "Probably the best approach to your problem would have been to generate a separate static for each type, rather than generating a type map. A type map only really makes sense when the set of types in it can only be determined at runtime.\r\n\r\nDo you know how many *types* were generated as part of this process? You say \"few hundred\" but I assume you mean protobuf files; the chance of a collision in a map with only a few hundred types should be very low.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633340396/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633348670",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-633348670",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 633348670,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYzMzM0ODY3MA==",
    "user": {
      "login": "Y0ba",
      "id": 1163958,
      "node_id": "MDQ6VXNlcjExNjM5NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1163958?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Y0ba",
      "html_url": "https://github.com/Y0ba",
      "followers_url": "https://api.github.com/users/Y0ba/followers",
      "following_url": "https://api.github.com/users/Y0ba/following{/other_user}",
      "gists_url": "https://api.github.com/users/Y0ba/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Y0ba/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Y0ba/subscriptions",
      "organizations_url": "https://api.github.com/users/Y0ba/orgs",
      "repos_url": "https://api.github.com/users/Y0ba/repos",
      "events_url": "https://api.github.com/users/Y0ba/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Y0ba/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2020-05-25T02:42:50Z",
    "updated_at": "2020-05-25T02:42:50Z",
    "body": "> Probably the best approach to your problem would have been to generate a separate static for each type\r\n\r\nThat's what I had in C#, and at first tried in Rust something like this:\r\n```rust\r\nfn get_data<T>() -> &'static mut Data<T> {\r\n    static mut DATA: Data<T> = Data::new();\r\n    unsafe { &mut DATA }\r\n}\r\n```\r\nbut it doesn't work. Type map was a nice solution without additional codegen. But at the end I did just like you said - forked protobuf compiler and added separate static for each type in generated files.\r\n> Do you know how many types were generated as part of this process?\r\n\r\nProbably around 400. In protobuf-file there were way more, but in type map I used only a small subset of them.\r\n\r\n> the chance of a collision in a map with only a few hundred types should be very low.\r\n\r\nIndeed. I hit it accidentally and didn't even expect that.",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633348670/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633509607",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-633509607",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 633509607,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYzMzUwOTYwNw==",
    "user": {
      "login": "withoutboats",
      "id": 9063376,
      "node_id": "MDQ6VXNlcjkwNjMzNzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9063376?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/withoutboats",
      "html_url": "https://github.com/withoutboats",
      "followers_url": "https://api.github.com/users/withoutboats/followers",
      "following_url": "https://api.github.com/users/withoutboats/following{/other_user}",
      "gists_url": "https://api.github.com/users/withoutboats/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/withoutboats/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/withoutboats/subscriptions",
      "organizations_url": "https://api.github.com/users/withoutboats/orgs",
      "repos_url": "https://api.github.com/users/withoutboats/repos",
      "events_url": "https://api.github.com/users/withoutboats/events{/privacy}",
      "received_events_url": "https://api.github.com/users/withoutboats/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2020-05-25T10:44:43Z",
    "updated_at": "2020-05-25T10:44:43Z",
    "body": "You can't have generic statics but you can generate a static of a different type for each type, and then associate the static with the type using a static method on a trait.\r\n\r\nSo I believe the upper limit on a 64 bit hash would give a probability of this occurring at less than 1 in 8.3 million (512 out of 2^32). Obviously SipHash is not designed to be collision resistant and the probability is greater than this, but I can't find any good number as to how *much* greater. If the collision resistance is so low that a user has a reasonable chance of encountering a collision among less than 500 TypeIds, we should prioritize a resolution to this higher than we have - mainly because its an awful footgun as you've mentioned.\r\n\r\nDoes anyone have better numbers on the lack of collision resistance in SipHash than the birthday bound?",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633509607/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633592973",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-633592973",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 633592973,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYzMzU5Mjk3Mw==",
    "user": {
      "login": "tarcieri",
      "id": 797,
      "node_id": "MDQ6VXNlcjc5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/797?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tarcieri",
      "html_url": "https://github.com/tarcieri",
      "followers_url": "https://api.github.com/users/tarcieri/followers",
      "following_url": "https://api.github.com/users/tarcieri/following{/other_user}",
      "gists_url": "https://api.github.com/users/tarcieri/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tarcieri/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tarcieri/subscriptions",
      "organizations_url": "https://api.github.com/users/tarcieri/orgs",
      "repos_url": "https://api.github.com/users/tarcieri/repos",
      "events_url": "https://api.github.com/users/tarcieri/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tarcieri/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2020-05-25T14:15:38Z",
    "updated_at": "2020-05-25T14:15:38Z",
    "body": "From the SipHash paper, the major concerns around collision resistance are the small output size and correspondingly small birthday bound as you noted:\r\n\r\nhttps://www.131002.net/siphash/siphash.pdf\r\n\r\n> Security is also limited by the output size (64 bits). In particular, when SipHash is used as a MAC, an attacker who blindly tries 2^s tags will succeed with probability 2^(s\u221264)\r\n\r\nThe paper further notes:\r\n\r\n> We comment that SipHash is not meant to be, and (obviously) is not, collision resistant.\r\n\r\n(this is due to the small output size)",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633592973/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633602238",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-633602238",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 633602238,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYzMzYwMjIzOA==",
    "user": {
      "login": "icefoxen",
      "id": 1335133,
      "node_id": "MDQ6VXNlcjEzMzUxMzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1335133?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/icefoxen",
      "html_url": "https://github.com/icefoxen",
      "followers_url": "https://api.github.com/users/icefoxen/followers",
      "following_url": "https://api.github.com/users/icefoxen/following{/other_user}",
      "gists_url": "https://api.github.com/users/icefoxen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/icefoxen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/icefoxen/subscriptions",
      "organizations_url": "https://api.github.com/users/icefoxen/orgs",
      "repos_url": "https://api.github.com/users/icefoxen/repos",
      "events_url": "https://api.github.com/users/icefoxen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/icefoxen/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2020-05-25T14:37:33Z",
    "updated_at": "2020-05-25T14:38:34Z",
    "body": "@Y0ba Wooooah, you hit the... what, 1 in 10 million chance of this happening. Congrats! \ud83d\ude01 ",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633602238/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633610316",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-633610316",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 633610316,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYzMzYxMDMxNg==",
    "user": {
      "login": "withoutboats",
      "id": 9063376,
      "node_id": "MDQ6VXNlcjkwNjMzNzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9063376?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/withoutboats",
      "html_url": "https://github.com/withoutboats",
      "followers_url": "https://api.github.com/users/withoutboats/followers",
      "following_url": "https://api.github.com/users/withoutboats/following{/other_user}",
      "gists_url": "https://api.github.com/users/withoutboats/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/withoutboats/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/withoutboats/subscriptions",
      "organizations_url": "https://api.github.com/users/withoutboats/orgs",
      "repos_url": "https://api.github.com/users/withoutboats/repos",
      "events_url": "https://api.github.com/users/withoutboats/events{/privacy}",
      "received_events_url": "https://api.github.com/users/withoutboats/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2020-05-25T14:57:01Z",
    "updated_at": "2020-05-25T14:57:01Z",
    "body": "@tarcieri Yea, but I suspected that the collision resistance may be substantially lower (because it's not a priority), since a collision in less than 500 hashes seems surprising otherwise. The paper doesn't discuss collision resistance in any real length since even a perfect 64 bit hash would not be sufficiently resistant and its not a concern. Do you know any further information?",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633610316/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633718520",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-633718520",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 633718520,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYzMzcxODUyMA==",
    "user": {
      "login": "tarcieri",
      "id": 797,
      "node_id": "MDQ6VXNlcjc5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/797?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tarcieri",
      "html_url": "https://github.com/tarcieri",
      "followers_url": "https://api.github.com/users/tarcieri/followers",
      "following_url": "https://api.github.com/users/tarcieri/following{/other_user}",
      "gists_url": "https://api.github.com/users/tarcieri/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tarcieri/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tarcieri/subscriptions",
      "organizations_url": "https://api.github.com/users/tarcieri/orgs",
      "repos_url": "https://api.github.com/users/tarcieri/repos",
      "events_url": "https://api.github.com/users/tarcieri/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tarcieri/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2020-05-25T21:16:15Z",
    "updated_at": "2020-05-25T21:16:15Z",
    "body": "If I'm reading the birthday table correctly, 500 hashes colliding within a 64-bit hash space should have a probability around 10^-14, so that suggests something else is wrong.\r\n\r\nSipHash is allegedly a secure PRF and therefore has uniformly random outputs, so I doubt it's something wrong with the algorithm.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/633718520/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/781642724",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-781642724",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 781642724,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc4MTY0MjcyNA==",
    "user": {
      "login": "lahwran",
      "id": 550498,
      "node_id": "MDQ6VXNlcjU1MDQ5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/550498?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lahwran",
      "html_url": "https://github.com/lahwran",
      "followers_url": "https://api.github.com/users/lahwran/followers",
      "following_url": "https://api.github.com/users/lahwran/following{/other_user}",
      "gists_url": "https://api.github.com/users/lahwran/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lahwran/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lahwran/subscriptions",
      "organizations_url": "https://api.github.com/users/lahwran/orgs",
      "repos_url": "https://api.github.com/users/lahwran/repos",
      "events_url": "https://api.github.com/users/lahwran/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lahwran/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2021-02-18T21:21:12Z",
    "updated_at": "2021-02-18T21:23:44Z",
    "body": "checking in about this since I'm scanning through I-unsound issues. This one has been open for the longest. I read through the thread, but I may have missed it - what's the current situation with fixing this soundness hole? or in other words, what would a motivated contributor need to do to bring this issue from its current state into a merged pull request merged that closes this issue? I see discussion, but if I read correctly we're undecided on an actual solution. Taking a guess, would this plan be close enough to reality to be worth starting on for such a motivated contributor?\r\n\r\n1. select one of the suggested solutions from this thread based on current discussion\r\n2. prototype it (or should this come later after rfc?)\r\n3. write an rfc, show the prototype\r\n4. [proceed through rfc process]\r\n5. [proceed through rustc merge process]\r\n\r\nIs this a full listing of the highest level of steps?",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/781642724/reactions",
      "total_count": 15,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 15,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/825140900",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-825140900",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 825140900,
    "node_id": "MDEyOklzc3VlQ29tbWVudDgyNTE0MDkwMA==",
    "user": {
      "login": "workingjubilee",
      "id": 46493976,
      "node_id": "MDQ6VXNlcjQ2NDkzOTc2",
      "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/workingjubilee",
      "html_url": "https://github.com/workingjubilee",
      "followers_url": "https://api.github.com/users/workingjubilee/followers",
      "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}",
      "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions",
      "organizations_url": "https://api.github.com/users/workingjubilee/orgs",
      "repos_url": "https://api.github.com/users/workingjubilee/repos",
      "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/workingjubilee/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2021-04-22T19:51:53Z",
    "updated_at": "2021-04-22T19:53:12Z",
    "body": "Yes, @lahwran, that sounds like a reasonable start.\r\n\r\nMany RFCs in the past have been more successful when they come from an initial prototyping phase, because they have real experience that informs the RFC. Nonetheless, it isn't _required_. However, given that this has had a lot of hypothesizing and little action, it still seems advisable.\r\n\r\nGiven that most of this affects internals and so _should_ be mooostly invisible, I am not entirely sure how much an RFC is even needed, except insofar as it relates to the TypeId's _public_ interface, as was mentioned in #84391. But that might boil down to just having things be slightly out-of-order compared to your list.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/825140900/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1094073742",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1094073742",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1094073742,
    "node_id": "IC_kwDOAAsO6M5BNj2O",
    "user": {
      "login": "eddyb",
      "id": 77424,
      "node_id": "MDQ6VXNlcjc3NDI0",
      "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eddyb",
      "html_url": "https://github.com/eddyb",
      "followers_url": "https://api.github.com/users/eddyb/followers",
      "following_url": "https://api.github.com/users/eddyb/following{/other_user}",
      "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions",
      "organizations_url": "https://api.github.com/users/eddyb/orgs",
      "repos_url": "https://api.github.com/users/eddyb/repos",
      "events_url": "https://api.github.com/users/eddyb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eddyb/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2022-04-09T15:56:57Z",
    "updated_at": "2022-04-09T15:56:57Z",
    "body": "Update: finally opened #95845 with a (v0) mangling-based `TypeId` representation, which should mitigate hash collisions.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1094073742/reactions",
      "total_count": 10,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 3,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 7
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1793873760",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1793873760",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1793873760,
    "node_id": "IC_kwDOAAsO6M5q7Fdg",
    "user": {
      "login": "tgross35",
      "id": 13724985,
      "node_id": "MDQ6VXNlcjEzNzI0OTg1",
      "avatar_url": "https://avatars.githubusercontent.com/u/13724985?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tgross35",
      "html_url": "https://github.com/tgross35",
      "followers_url": "https://api.github.com/users/tgross35/followers",
      "following_url": "https://api.github.com/users/tgross35/following{/other_user}",
      "gists_url": "https://api.github.com/users/tgross35/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tgross35/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tgross35/subscriptions",
      "organizations_url": "https://api.github.com/users/tgross35/orgs",
      "repos_url": "https://api.github.com/users/tgross35/repos",
      "events_url": "https://api.github.com/users/tgross35/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tgross35/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2023-11-05T23:00:04Z",
    "updated_at": "2023-11-05T23:00:04Z",
    "body": "Now that `TypeId` is 128 bits, what should be done here? The chances of a collision are significantly lower but still not impossible. I saw some mentions here of prepending crate name or some form of crate ID to the data to be hashed but it didn't seem like there was a concrete resolution.\r\n\r\nIt probably wouldn't be a bad idea to have the compiler check for collisions with every type it knows about, even if that doesn't cover 100% of cases.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1793873760/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1794188765",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1794188765",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1794188765,
    "node_id": "IC_kwDOAAsO6M5q8SXd",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2023-11-06T06:56:04Z",
    "updated_at": "2023-11-06T06:56:04Z",
    "body": "IIRC there were plans to use 64bit of that for a hash and the other 64bit for a pointer where the full type ID is stored. Then we'd have a fast test for `!=` (different hashes), and with sufficient linker magic a fast test for `==` (compare the pointer; rely on linker deduplication to make the pointers the same cross-crate). That would be fully sound without relying on a hash and hopefully also not be slower than today for the vast majority of cases.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1794188765/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1866989561",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1866989561",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1866989561,
    "node_id": "IC_kwDOAAsO6M5vR__5",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2023-12-21T22:06:27Z",
    "updated_at": "2023-12-21T22:06:27Z",
    "body": "> IRC there were plans to use 64bit of that for a hash and the other 64bit for a pointer where the full type ID is stored. Then we'd have a fast test for != (different hashes), and with sufficient linker magic a fast test for == (compare the pointer; rely on linker deduplication to make the pointers the same cross-crate). That would be fully sound without relying on a hash and hopefully also not be slower than today for the vast majority of cases.\r\n\r\nWas that https://github.com/rust-lang/rust/pull/95845, which was closed without being merged? Or is there a new effort?",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1866989561/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867075788",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1867075788",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1867075788,
    "node_id": "IC_kwDOAAsO6M5vSVDM",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2023-12-22T00:15:30Z",
    "updated_at": "2023-12-22T00:15:30Z",
    "body": "> Now that TypeId is 128 bits, what should be done here? \r\n\r\nFirst, like I mentioned in https://github.com/rust-lang/compiler-team/issues/608#issuecomment-1866992894, we can't infer much about the collision resistance of `TypeId` values based on the length (64 vs. 128 bits, or whatever).\r\n\r\n> The chances of a collision are significantly lower but still not impossible. I saw some mentions here of prepending crate name or some form of crate ID to the data to be hashed but it didn't seem like there was a concrete resolution.\r\n\r\nType documentation for `TypeId` starts with \"A TypeId represents a globally unique identifier for a type.\" However, we all seem to agree that is wrong. At a minimum the documentation should be updated to be more realistic about how a TypeId can be safely used. AFAICT, TypeId cannot be safely used (that's why this issue is marked \"I-unsound\"), so it seems like some parts of the `TypeId` API should be marked `unsafe`. At a minimum, the safety hazards of `TypeId` should be documented in the documentation.\r\n\r\n> It probably wouldn't be a bad idea to have the compiler check for collisions with every type it knows about, even if that doesn't cover 100% of cases.\r\n\r\nThat would require whole program analysis, including dead code. Also, \"every type it knows about\" seems impractical because types can be constructed from other generic types, and the compiler cannot consider all ways generic types can be instantiated.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867075788/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867086193",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1867086193",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1867086193,
    "node_id": "IC_kwDOAAsO6M5vSXlx",
    "user": {
      "login": "the8472",
      "id": 1065730,
      "node_id": "MDQ6VXNlcjEwNjU3MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/the8472",
      "html_url": "https://github.com/the8472",
      "followers_url": "https://api.github.com/users/the8472/followers",
      "following_url": "https://api.github.com/users/the8472/following{/other_user}",
      "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/the8472/subscriptions",
      "organizations_url": "https://api.github.com/users/the8472/orgs",
      "repos_url": "https://api.github.com/users/the8472/repos",
      "events_url": "https://api.github.com/users/the8472/events{/privacy}",
      "received_events_url": "https://api.github.com/users/the8472/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2023-12-22T00:32:56Z",
    "updated_at": "2023-12-22T00:41:33Z",
    "body": "> we can't infer much about the collision resistance of TypeId values based on the length (64 vs. 128 bits, or whatever).\r\n\r\nTheoretically perhaps. In practice we assume that siphash128 has sufficient quality that random collisions are vanishingly unlikely, not only for TypeId but also for internal compiler state that requires distinct items to produce distinct hashes.\r\nIf a collision is found that is a bug and will be fixed, for example by replacing it with a stronger hash function. Like Tantalum-180m1 it is observationally ~stable~ fit for its purpose.\r\n\r\n> AFAICT, TypeId cannot be safely used\r\n\r\nIt is the expectation that it can be safely used within probabilistic limits that exceed the reliability of all available physical computer systems. Modulo malicious inputs, which afaik are outside **rustc**'s threat model (though you may want to get official word from T-compiler on that).\r\nDeviation from that expectation would be a bug like any other.\r\n\r\n\r\nre: https://github.com/rust-lang/compiler-team/issues/608#issuecomment-1867079270\r\n\r\n> OK, I'll take that to mean you agree that the original argument isn't sound. \r\n\r\nI'll note that willingness to discuss the finer details does not imply agreement.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867086193/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867092993",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1867092993",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1867092993,
    "node_id": "IC_kwDOAAsO6M5vSZQB",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2023-12-22T00:45:19Z",
    "updated_at": "2023-12-22T00:45:54Z",
    "body": "> Theoretically perhaps. In practice we assume that siphash128 has sufficient quality that random collisions are vanishingly unlikely, \r\n\r\nWho is \"we\"? I don't assume that at all, and neither do the SipHash designers, AFAI understand what they wrote.\r\n\r\n> not only for TypeId but also for internal compiler state that requires distinct items to produce distinct hashes.\r\n\r\nYes, this is all extremely problematic.\r\n\r\n> If a collision is found that is a bug and will be fixed, for example by replacing it with a stronger hash function.\r\n\r\nWhy wait until a collision is found?\r\n\r\n> > OK, I'll take that to mean you agree that the original argument isn't sound.\r\n\r\n> I'll note that willingness to discuss the finer details does not imply agreement.\r\n\r\nSpecifically, the original claim was that a 128-bit hash has a birthday bound of collisions of 1/(2^64). The implication is that since TypeId is now 128 bits, the likelihood of a \"natural\" collision is 1/(2^64). This is the argument I am saying is unsound. I don't think anybody is disagreeing that it is unsound.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867092993/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867107681",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1867107681",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1867107681,
    "node_id": "IC_kwDOAAsO6M5vSc1h",
    "user": {
      "login": "the8472",
      "id": 1065730,
      "node_id": "MDQ6VXNlcjEwNjU3MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/the8472",
      "html_url": "https://github.com/the8472",
      "followers_url": "https://api.github.com/users/the8472/followers",
      "following_url": "https://api.github.com/users/the8472/following{/other_user}",
      "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/the8472/subscriptions",
      "organizations_url": "https://api.github.com/users/the8472/orgs",
      "repos_url": "https://api.github.com/users/the8472/repos",
      "events_url": "https://api.github.com/users/the8472/events{/privacy}",
      "received_events_url": "https://api.github.com/users/the8472/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2023-12-22T01:10:38Z",
    "updated_at": "2023-12-22T01:10:38Z",
    "body": "> Why wait until a collision is found?\r\n\r\nMy understanding is that all unkeyed hash functions, including state-of-the-art cryptographic ones, lack mathematical proof of their collision resistance and instead only various heuristics and approximations are used that suggest but do not prove that functions have desirable statistical and cryptographic properties.\r\n\r\nSo no matter which one you choose you have to treat them as hopefully-secure-until-someone-proves-the-opposite. The main difference is how much confidence one has in that (not) happening anytime soon.\r\n\r\n> Who is \"we\"?\r\n\r\nThe rust-lang teams that are involved when these issues come up. This isn't unanimous, but aiui the disagreement usually rests on formally-provable properties being nicer than probabilistic arguments.\r\n\r\n> Yes, this is all extremely problematic.\r\n\r\nCould you elaborate? What problems is this causing?\r\n\r\n> The implication is that since TypeId is now 128 bits, the likelihood of a \"natural\" collision is 1/(2^64). This is the argument I am saying is unsound. I don't think anybody is disagreeing that it is unsound.\r\n\r\nSome recent arguments about siphash collision probabilities were made here: https://github.com/rust-lang/rust/pull/107925#issuecomment-1427151276",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867107681/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867130154",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1867130154",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1867130154,
    "node_id": "IC_kwDOAAsO6M5vSiUq",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2023-12-22T01:48:47Z",
    "updated_at": "2023-12-22T01:49:38Z",
    "body": "> My understanding is that all unkeyed hash functions, including state-of-the-art cryptographic ones, lack mathematical proof of their collision resistance and instead only various heuristics and approximations are used that suggest but do not prove that functions have desirable statistical and cryptographic properties.\r\n\r\nUsually we don't use hashes equality as substitution for value equality unless the hash function is believed to have a collision birthday bound around 1/2^128. Like SHA-256/SHA512-256/SHA3-256/etc. would be the minimum. Again, the SipHash authors in their paper specifically disclaim collision resistance for such purposes. The original paper specifically says \"We comment that SipHash is not meant to be, and (obviously) is not, collision resistant.\" [0] So besides the output being shorter than we'd use for this purpose, the whole usage is specifically disclaimed by the inventors. The paper is at https://cr.yp.to/siphash/siphash-20120918.pdf. \r\n\r\n> > Yes, this is all extremely problematic.\r\n> Could you elaborate? What problems is this causing?\r\n\r\nAny part of the compiler that assumes infers that x == y when hash(x) == hash(y) for some types x and y is going to allow an attacker to publish a crate on crates.io that looks totally benign but causes the compiler to miscompile crates involved in a compilation, with probably P, which is the collision resistance of the hash function. Somebody could put up a totally valid PR for my own crates that implements useful and correct functionality which I would be happy to accept, which triggers this, and I would have no way of knowing.\r\n\r\nSo then, we have to ask ourselves:\r\n\r\n0. Why are we even using cryptography for this in the first place, when it is completely unneeded? Notice how clang implements `std::type_index` which is pointer sized, i.e. smaller than Rust's `TypeId` now.\r\n1. If we must insist on using cryptography, what is the acceptable probability P that we're willing to live with? Hopefully higher than 1/2^64. \r\n2. If we must insist on continuing to use cryptography for this, what is the collision resistance of the hashing function we're currently doing, the way we're currently doing it? People have posted claims regarding this, but I don't see anybody accepting those claims as valid, and I don't see us finding a consensus about it. How are we going to come to a consensus on the answer?\r\n\r\nNow we have to ask ourselves, is it prudent to wait for somebody to publish an attack and put it on crates.io, e.g. one that causes a `TypeId` collision with `std::io::Error` or something else commonly used? It looks like it would be hugely disruptive, and potentially within script kiddie territory. Even worse, if/when it would happen, we would probably waste a lot of time debating how bad it is.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867130154/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867167397",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1867167397",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1867167397,
    "node_id": "IC_kwDOAAsO6M5vSral",
    "user": {
      "login": "the8472",
      "id": 1065730,
      "node_id": "MDQ6VXNlcjEwNjU3MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/the8472",
      "html_url": "https://github.com/the8472",
      "followers_url": "https://api.github.com/users/the8472/followers",
      "following_url": "https://api.github.com/users/the8472/following{/other_user}",
      "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/the8472/subscriptions",
      "organizations_url": "https://api.github.com/users/the8472/orgs",
      "repos_url": "https://api.github.com/users/the8472/repos",
      "events_url": "https://api.github.com/users/the8472/events{/privacy}",
      "received_events_url": "https://api.github.com/users/the8472/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2023-12-22T02:53:20Z",
    "updated_at": "2023-12-22T03:08:29Z",
    "body": "> is going to allow an attacker to publish a crate on crates.io that looks totally benign but causes the compiler to miscompile crates involved in a compilation, with probably P,\r\n\r\n> e.g. one that causes a TypeId collision with std::io::Error or something else commonly used? \r\n\r\nThose would require preimage attacks, not collisions. To create a collision an attacker must control both types, which means they're screwing up just their own crate. Which, yes, could still  be problematic, just not the scenario you're describing here.\r\n\r\nAdditionally this might be easy to mitigate, if it isn't already. siphash is designed as a keyed hash function. I don't know what the constraints wrt. reproducible builds are but perhaps a random seed could be included in the crate metadata that would change the hash output whenever a clean build is made of a crate.\r\n\r\n> Somebody could put up a totally valid PR for my own crates that implements useful and correct functionality which I would be happy to accept, which triggers this, and I would have no way of knowing.\r\n\r\nTheoretically yes, practically an attack does not necessarily give an attacker sufficiently fine control to disguise this in human-readable text, especially if they only control part of the input.\r\n\r\n\r\nAnyway, this is putting the cart before the horse. As I wrote earlier, afaik such things are outside rustc's threat model because this would be a mouse hole compared to the open barn doors that are build rs, proc macros, llvm miscompilations and other  randomly-occurring or exploitable sources of soundness issues. If this were the last thing before rustc could be considered a provably-secure compiler then it could be reevaluated. Until then it's likely Good Enough\u2122.\r\nAnd to reiterate, just because something is not a security issue doesn't mean it won't be fixed. If siphash is found to be weaker than expected it can swapped out for something better. It's not set in stone.\r\n\r\n> Why are we even using cryptography for this in the first place, when it is completely unneeded? Notice how clang implements std::type_index which is pointer sized, i.e. smaller than Rust's TypeId now.\r\n\r\nRust has no RTTI, so this would incur additional footprint costs.\r\n\r\n> If we must insist on using cryptography, what is the acceptable probability P that we're willing to live with? Hopefully higher than 1/2^64.\r\n\r\nThat number may not be astronomically small, but it's still GPU-years small. I.e. it's unlikely to arise by chance. If we were trying to defend against well-funded adversaries intentionally searching for collisions then yes, it should be increased.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867167397/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867351685",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1867351685",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1867351685,
    "node_id": "IC_kwDOAAsO6M5vTYaF",
    "user": {
      "login": "bjorn3",
      "id": 17426603,
      "node_id": "MDQ6VXNlcjE3NDI2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bjorn3",
      "html_url": "https://github.com/bjorn3",
      "followers_url": "https://api.github.com/users/bjorn3/followers",
      "following_url": "https://api.github.com/users/bjorn3/following{/other_user}",
      "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions",
      "organizations_url": "https://api.github.com/users/bjorn3/orgs",
      "repos_url": "https://api.github.com/users/bjorn3/repos",
      "events_url": "https://api.github.com/users/bjorn3/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bjorn3/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2023-12-22T07:49:19Z",
    "updated_at": "2023-12-22T07:49:19Z",
    "body": "> I don't know what the constraints wrt. reproducible builds are but perhaps a random seed could be included in the crate metadata that would change the hash output whenever a clean build is made of a crate.\r\n\r\nMany people need reproducibility. Note that we do already include a hash of the full rustc version string though through StableCrateId. This includes the commit hash for the official builds and thus isn't predictable for future versions. And when distros rebuild rustc the version string is almost certainly different and thus so is the TypeId.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867351685/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867353749",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1867353749",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1867353749,
    "node_id": "IC_kwDOAAsO6M5vTY6V",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2023-12-22T07:52:00Z",
    "updated_at": "2023-12-22T07:53:44Z",
    "body": "I agree with @the8472 . It is also my understanding that rustc's threat model does not, in general, include maliciously crafted input (as in, source code). Where practical the toolchain will be made resistant to such inputs, but for TypeId collisions so far this has not been considered practical.\r\n\r\nThis was discussed before, I think it was [here](https://github.com/rust-lang/rust/pull/95845#issuecomment-1125245372).\r\n\r\nAssuming a non-malicious, i.e. randomly picked, input program, the probability analysis seems correct to me.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1867353749/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1868051176",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1868051176",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1868051176,
    "node_id": "IC_kwDOAAsO6M5vWDLo",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2023-12-22T20:32:33Z",
    "updated_at": "2023-12-22T20:32:33Z",
    "body": "> > is going to allow an attacker to publish a crate on crates.io that looks totally benign but causes the compiler to miscompile crates involved in a compilation, with probably P,\r\n> \r\n> > e.g. one that causes a TypeId collision with std::io::Error or something else commonly used?\r\n> \r\n> Those would require preimage attacks, not collisions. \r\n\r\nWe don't have an argument in favor of preimage resistance of SipHash. Again, SipHash is a PRF, all the security assumptions we have for SipHash are premised on having a random secret key. So we don't have any argument in favor of sigifnicant collision resistance or (second) preimage resistance for SipHash with a fixed key being used as a hash function.\r\n\r\n> > Somebody could put up a totally valid PR for my own crates that implements useful and correct functionality which I would be happy to accept, which triggers this, and I would have no way of knowing.\r\n> \r\n> Theoretically yes, practically an attack does not necessarily give an attacker sufficiently fine control to disguise this in human-readable text, especially if they only control part of the input.\r\n\r\nWe don't know how easy or hard it would be. Finding out would be a likely be a huge amount of work.\r\n\r\n> Anyway, this is putting the cart before the horse. As I wrote earlier, afaik such things are outside rustc's threat model because this would be a mouse hole compared to the open barn doors that are build rs, proc macros,\r\n\r\nIt's true that users are responsible for ensuring security in the face of build.rs and proc macros. However, users cannot be responsible for preventing TypeId collisions because it's not practical for them to detect them.\r\n\r\n> And to reiterate, just because something is not a security issue doesn't mean it won't be fixed.\r\n\r\nOTOH, if it wasn't a security issue, I wouldn't bother putting any effort into it. It is a security issue. It is the very annoying kind where probably nobody can justify spending the effort to analyze how practical an attack would be, or to create a PoC.\r\n\r\n> If siphash is found to be weaker than expected it can swapped out for something better. It's not set in stone.\r\n\r\nWhat is the \"expected\" strength of SipHash for collision resistance and preimage resistance when used with a fixed key as a hash function? AFAICT there has been no attempt to get an expected strength. The paper that introduced SipHash specifically warned against having any such expectation.\r\n\r\n> > Why are we even using cryptography for this in the first place, when it is completely unneeded? Notice how clang implements std::type_index which is pointer sized, i.e. smaller than Rust's TypeId now.\r\n> \r\n> Rust has no RTTI, so this would incur additional footprint costs.\r\n\r\nTo do it like clang, in the most naive way, it would cost at most 1 byte of \"RTTI info\" per type where the type ID is actually used. Let's say we moved to word-size type IDs like clang. Then on 32-bit targets type ID would cost 4 + 1 = 5 bytes, and on 64-bit targets type IDs would cost 8 + 1 = 9 bytes. Currently with 128-bit TypeIDs in Rust, each type ID cost 16 bytes. So it seems like the hash-based approach actually costs more space than doing it like clang's `std::type_index` does. (More code is required to move 128-bit values around than word-size values, this probably understates the cost of the hash-based approach.)\r\n\r\n(IDK if it is possible to instead use the address of the `Any` vtable for each type to avoid that extra byte. Otherwise I know of a theoretical way of avoiding the extra byte with the clang-like approach but IDK how practical it is.)\r\n\r\n> > If we must insist on using cryptography, what is the acceptable probability P that we're willing to live with? Hopefully higher than 1/2^64.\r\n> \r\n> That number may not be astronomically small, but it's still GPU-years small. I.e. it's unlikely to arise by chance. If we were trying to defend against well-funded adversaries intentionally searching for collisions then yes, it should be increased.\r\n\r\nIt is an unfortunate situation that it is extremely expensive to evaluate the security and correctness of the hash-based approach, such that no \"good people\" can afford to take the time to do it, as we have little to gain. Only adversaries could justify the effort. Already, I think we're at the breaking point of the amount of effort we want to spend on this.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1868051176/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1868056154",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1868056154",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1868056154,
    "node_id": "IC_kwDOAAsO6M5vWEZa",
    "user": {
      "login": "bjorn3",
      "id": 17426603,
      "node_id": "MDQ6VXNlcjE3NDI2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bjorn3",
      "html_url": "https://github.com/bjorn3",
      "followers_url": "https://api.github.com/users/bjorn3/followers",
      "following_url": "https://api.github.com/users/bjorn3/following{/other_user}",
      "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions",
      "organizations_url": "https://api.github.com/users/bjorn3/orgs",
      "repos_url": "https://api.github.com/users/bjorn3/repos",
      "events_url": "https://api.github.com/users/bjorn3/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bjorn3/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2023-12-22T20:41:50Z",
    "updated_at": "2023-12-22T20:44:35Z",
    "body": "> To do it like clang, in the most naive way, it would cost at most 1 byte of \"RTTI info\" per type where the type ID is actually used.\r\n\r\nHow does clang ensure that this value is globally unique for a given type even across dylibs? AFAIU on Windows there is no way to ensure two DLL's defining the same global variable will get a single instance. This is also why statics can't be generic. And how is a `Hash` implementation for `TypeId` consistent for multiple executions of the same program possible with this scheme? The only thing you can hash would be the pointer itself, which due to ASLR is non-deterministic between executions.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1868056154/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1868300480",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1868300480",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1868300480,
    "node_id": "IC_kwDOAAsO6M5vXADA",
    "user": {
      "login": "the8472",
      "id": 1065730,
      "node_id": "MDQ6VXNlcjEwNjU3MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/the8472",
      "html_url": "https://github.com/the8472",
      "followers_url": "https://api.github.com/users/the8472/followers",
      "following_url": "https://api.github.com/users/the8472/following{/other_user}",
      "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/the8472/subscriptions",
      "organizations_url": "https://api.github.com/users/the8472/orgs",
      "repos_url": "https://api.github.com/users/the8472/repos",
      "events_url": "https://api.github.com/users/the8472/events{/privacy}",
      "received_events_url": "https://api.github.com/users/the8472/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2023-12-23T14:01:47Z",
    "updated_at": "2023-12-23T14:10:40Z",
    "body": "I think the issue hinges on the current threat model. Changing it would have significant consequences, e.g. LLVM miscompilations could become CVEs, might have to be fixed under secrecy and require point releases; LLVM would have to play along with that. Various I-unsound issues would become P-critical. Perhaps more resource would have to be spent on fuzzing rustc at a higher level (ICEs wouldn't be the goal here). Perhaps a hardened rustc mode/build would be necessary. Etc. etc.\r\n\r\nOr you could plead that this a special case, different from all other ways to produce unsoundness. But imo that's not the case because finding novel weaknesses in LLVM or rust's type system may be easier than finding a weakness in siphash.\r\n\r\nThere are other options. Even if we don't consider this a priority that doesn't prevent you or others from working on it (read: patches welcome). Perhaps a more detailed security analysis could be done, digging into [what exactly gets hashed](https://github.com/rust-lang/rust/issues/10389#issuecomment-1867351685), what defenses exist (asserts in the compiler?) and what that implies about the bounds on reliability of any hypothetical exploit. Perhaps there are some cheap mitigations that wouldn't affect performance or reproducibility. Or perhaps someone could run rustc with debug asserts enabled over all crates and that'd do the job. Idk.\r\nAnd as I have said previously, the TypeId implementation is not set in stone. If someone writes an alternative that achieves the same goals but is more robust that could get accepted too. But that's probably insufficient to allay your more general concerns since siphash is relied on in the compiler for other things.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1868300480/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1874446311",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1874446311",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1874446311,
    "node_id": "IC_kwDOAAsO6M5vucfn",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-02T19:22:25Z",
    "updated_at": "2024-01-02T19:23:12Z",
    "body": "> I think the issue hinges on the current threat model. Changing it would have significant consequences, e.g. LLVM miscompilations could become CVEs, might have to be fixed under secrecy and require point releases; [...] Various I-unsound issues would become P-critical.\r\n\r\nIt seems like there's a broader discussion to be had about differing expectations about how security-relevant problems in the compiler/toolchain/libraries are handled. I don't think this issue is the place for that discussion. I think mixing that meta-issue into this specific issue has created most of the conflict here.\r\n\r\n* I think we should be able to agree that the way `TypeId` is implemented and used (both in the standard library, and the analogous use in the compiler) is based on a line of reasoning that starts with a false (or, at least, unproven and very likely to be proven false) premise.\r\n* I think we should be able to agree that the API that promises that `TypeId` is \"globally unique\" is both vague almost to the point of being meaningless, and also promising something that isn't being (and likely can't be) implemented.\r\n* I think we should be able to agree that we don't want our claims (and future proofs) about memory safety of Rust's standard library to be qualified on the collision-resistance of (mis)using SipHash with a fixed key. I don't think any of us want to make Rust's standard library to be \"memory-safe with some probability that we can't specify.\"\r\n* I think we should be able to get to agreement that we don't want to qualify the maximum possible correctness of the Rust compiler similarly.\r\n\r\nI think it is harder to get to agreement on priority, responsibility, security advisory stuff, etc. I suggest we all just defer all thought of those aspects.\r\n\r\nRegarding intentionally-created collisions: A recent blog post was published at https://www.da.vidbuchanan.co.uk/blog/colliding-secure-hashes.html where the author shows that it is not difficult to (intentionally) force collisions even using an actually-believed-secure hash function (SHA-256) truncated to 128 bits. SHA-256 is a much stronger hash function than SipHash-128 misused with a fixed key. I am far from the first one to point this out, you can see others make it at https://news.ycombinator.com/item?id=19405756 and many other places. Similarly, if you Google for preimage resistance of SipHash then you'll find most of the discussions quickly end by noting that SipHash doesn't even try to be a secure hash function, because it is a PRF that requires a secret key.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1874446311/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1874498890",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1874498890",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1874498890,
    "node_id": "IC_kwDOAAsO6M5vupVK",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-02T20:14:48Z",
    "updated_at": "2024-01-02T20:14:48Z",
    "body": "> > To do it like clang, in the most naive way, it would cost at most 1 byte of \"RTTI info\" per type where the type ID is actually used.\r\n> \r\n> How does clang ensure that this value is globally unique for a given type even across dylibs? AFAIU on Windows there is no way to ensure two DLL's defining the same global variable will get a single instance. This is also why statics can't be generic.\r\n\r\nIt is hard to answer that question when posed so abstractly. A lot of times such issues arise when people are violating the One Definition Rule (ODR) in C++, and I'm not sure what such a situation would look like when they aren't violating the ODR. It would be good to see a description of a *Rust* program composed of multiple shared libraries in a way that is supported by the Rust toolchain and where the \"two DLLs defining the same global variable\" issue would arise w.r.t. a Clang-like TypeId implementation strategy.\r\n\r\n> And how is a `Hash` implementation for `TypeId` consistent for multiple executions of the same program possible with this scheme? The only thing you can hash would be the pointer itself, which due to ASLR is non-deterministic between executions.\r\n\r\n1. Luckily the Rust standard library doesn't guarantee that a TypeId is consistent for multiple executions of a program.\r\n2. The TypeId doesn't necessarily have to be the absolute address; it could be the offset from the beginning of the rodata segument, or similar. This would avoid it being affected by ASLR and also, in theory, would allow us to throw away the never-used extra byte that would be allocated for each TypeId in the Clang-like scheme.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1874498890/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1874524282",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1874524282",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1874524282,
    "node_id": "IC_kwDOAAsO6M5vuvh6",
    "user": {
      "login": "the8472",
      "id": 1065730,
      "node_id": "MDQ6VXNlcjEwNjU3MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/the8472",
      "html_url": "https://github.com/the8472",
      "followers_url": "https://api.github.com/users/the8472/followers",
      "following_url": "https://api.github.com/users/the8472/following{/other_user}",
      "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/the8472/subscriptions",
      "organizations_url": "https://api.github.com/users/the8472/orgs",
      "repos_url": "https://api.github.com/users/the8472/repos",
      "events_url": "https://api.github.com/users/the8472/events{/privacy}",
      "received_events_url": "https://api.github.com/users/the8472/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-02T20:41:37Z",
    "updated_at": "2024-01-02T21:10:15Z",
    "body": "> I think we should be able to agree that the way TypeId is implemented and used (both in the standard library, and the analogous use in the compiler) is based on a line of reasoning that starts with a false (or, at least, unproven and very likely to be proven false) premise.\r\n\r\n> [...] where the author shows that it is not difficult to (intentionally) force collisions even using an actually-believed-secure hash function (SHA-256) truncated to 128 bits.\r\n\r\nNo, this loops back to the threat model. \"collision resistance\" always refers to the cryptographic property, not the statistical one. Which means it's only relevant under malicious inputs, which makes the threat model relevant.\r\nIf we only assume natural inputs that do not take advantage of the structure of the hash function or of rustc implementation details then only simpler properties like the avalanche effect should be relevant.\r\n\r\nBy saying \"proven to be false\" you're pulling targeted attacks into your argument. You can't do that and pretend that this isn't about extending the threat model.\r\n\r\n> I think we should be able to agree that the API that promises that TypeId is \"globally unique\" is both vague almost to the point of being meaningless, and also promising something that isn't being (and likely can't be) implemented.\r\n\r\nHrm yeah, perhaps that is a slight overpromise since we currently have no mechanism that can ensure that, especially when dynamic linking is involved. Though for most practical purposes it does fulfill that role.\r\n\r\n> I think we should be able to agree that we don't want our claims (and future proofs) about memory safety of Rust's standard library to be qualified on the collision-resistance of (mis)using SipHash with a fixed key. I don't think any of us want to make Rust's standard library to be \"memory-safe with some probability that we can't specify.\"\r\n\r\nTypeId's contents are not generated by the standard library. It's provided by the compiler and it's an implementation detail. As far as the user is concerned it's a random value assigned once at compile time to each type so they'd get a collision with a specifiable expected probability.\r\nThe real implementation doesn't do that because assigning a value exactly once across multiple rustc invocations independently instantiating a type is difficult. But the goal is to observationally behave as-if it had been generated that way.\r\n\r\n> I think we should be able to get to agreement that we don't want to qualify the maximum possible correctness of the Rust compiler similarly.\r\n\r\nI think that should also be a separate discussion and could maybe solved by a hardend-rustc for those who need it.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1874524282/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1874533808",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1874533808",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1874533808,
    "node_id": "IC_kwDOAAsO6M5vux2w",
    "user": {
      "login": "bjorn3",
      "id": 17426603,
      "node_id": "MDQ6VXNlcjE3NDI2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bjorn3",
      "html_url": "https://github.com/bjorn3",
      "followers_url": "https://api.github.com/users/bjorn3/followers",
      "following_url": "https://api.github.com/users/bjorn3/following{/other_user}",
      "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions",
      "organizations_url": "https://api.github.com/users/bjorn3/orgs",
      "repos_url": "https://api.github.com/users/bjorn3/repos",
      "events_url": "https://api.github.com/users/bjorn3/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bjorn3/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-02T20:50:26Z",
    "updated_at": "2024-01-02T20:50:26Z",
    "body": "> It would be good to see a description of a Rust program composed of multiple shared libraries in a way that is supported by the Rust toolchain and where the \"two DLLs defining the same global variable\" issue would arise w.r.t. a Clang-like TypeId implementation strategy.\r\n\r\nCrate A is a dylib and defines a type `Foo<T>`. Crates B and C depend on this dylib and each try to get the `TypeId` for `Foo<u8>`. Crate D is an executable and links against both crate B and crate C. With the clang-like implementation strategy as I understand it both crate B and C would define a global variable and thus produce a different `TypeId`, which is invalid.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1874533808/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1874552514",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1874552514",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1874552514,
    "node_id": "IC_kwDOAAsO6M5vu2bC",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-02T20:59:16Z",
    "updated_at": "2024-01-02T20:59:16Z",
    "body": "> Crate A is a dylib and defines a type Foo<T>. Crates B and C depend on this dylib and each try to get the TypeId for Foo<u8>. Crate D is an executable and links against both crate B and crate C. With the clang-like implementation strategy as I understand it both crate B and C would define a global variable and thus produce a different TypeId, which is invalid.\r\n\r\nIn the Clang-like strategy, Crate A would define the TypeId symbol for type `A::Foo`, and crates B and C would reference (and not themselves define) the symbol for A::Foo's TypeId, right?",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1874552514/reactions",
      "total_count": 2,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 2,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1874563464",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1874563464",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1874563464,
    "node_id": "IC_kwDOAAsO6M5vu5GI",
    "user": {
      "login": "bjorn3",
      "id": 17426603,
      "node_id": "MDQ6VXNlcjE3NDI2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bjorn3",
      "html_url": "https://github.com/bjorn3",
      "followers_url": "https://api.github.com/users/bjorn3/followers",
      "following_url": "https://api.github.com/users/bjorn3/following{/other_user}",
      "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions",
      "organizations_url": "https://api.github.com/users/bjorn3/orgs",
      "repos_url": "https://api.github.com/users/bjorn3/repos",
      "events_url": "https://api.github.com/users/bjorn3/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bjorn3/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-02T21:03:13Z",
    "updated_at": "2024-01-02T21:03:34Z",
    "body": "`Foo<T>` is generic here, so `Foo<u8>` and `Foo<MyLocalType>` would result in different `TypeId`. It is impossible to know all generic instantiations that will be used in advance when compiling crate A (for example `Foo<Foo<Foo<...1_000_000 levels of recursion...>>>` is a valid type), so we can't define the TypeId symbol when compiling crate A and as such have to define it when compiling crates B and C.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1874563464/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1874583758",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1874583758",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1874583758,
    "node_id": "IC_kwDOAAsO6M5vu-DO",
    "user": {
      "login": "tarcieri",
      "id": 797,
      "node_id": "MDQ6VXNlcjc5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/797?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tarcieri",
      "html_url": "https://github.com/tarcieri",
      "followers_url": "https://api.github.com/users/tarcieri/followers",
      "following_url": "https://api.github.com/users/tarcieri/following{/other_user}",
      "gists_url": "https://api.github.com/users/tarcieri/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tarcieri/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tarcieri/subscriptions",
      "organizations_url": "https://api.github.com/users/tarcieri/orgs",
      "repos_url": "https://api.github.com/users/tarcieri/repos",
      "events_url": "https://api.github.com/users/tarcieri/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tarcieri/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-02T21:22:28Z",
    "updated_at": "2024-01-02T21:22:28Z",
    "body": "> IIRC there were plans to use 64bit of that for a hash and the other 64bit for a pointer where the full type ID is stored. Then we'd have a fast test for != (different hashes), and with sufficient linker magic a fast test for == (compare the pointer; rely on linker deduplication to make the pointers the same cross-crate). That would be fully sound without relying on a hash and hopefully also not be slower than today for the vast majority of cases.\r\n\r\n@RalfJung this seems like a really good solution, but AFAICT it was never clarified if that was implemented in #95845 or what happened with that whole approach.\r\n\r\nAs a bit of a meta comment the current approach seems to be misapplying cryptographic primitives in ways that create problems where they otherwise wouldn't exist, and I think that's the core concern here.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1874583758/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1875121102",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1875121102",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1875121102,
    "node_id": "IC_kwDOAAsO6M5vxBPO",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-03T10:08:57Z",
    "updated_at": "2024-01-03T16:10:43Z",
    "body": "The linker magic part was never implemented I think. I am not even sure if we ever concluded that all our platforms have sufficiently powerful linkers to provide such magic. Personally I'd be happy to see further experimentation in that area. If the linker magic part works out then as far as I can see this has the same performance characteristics as the current implementation, but I can't speak for the teams so I can't say which other concerns there might be. If the linker magic part does not work out then there is the problem that a successful equality test slows down by a lot since it has to compare the strings for equality.\r\n\r\n> As a bit of a meta comment the current approach seems to be misapplying cryptographic primitives in ways that create problems where they otherwise wouldn't exist, and I think that's the core concern here.\r\n\r\nUsing SipHash with a fixed key is certainly odd. (I haven't checked if that's what we do, but it's possible.)\r\n\r\nBut I don't see how it creates new problems compared to the baseline of using something like fx-hash.  Either way, I think the claim that we have a collision probability of around 2^64 for regular (non-malicious) programs is correct. Of course this is not a precise claim since there's no precise probability distribution of \"regular (non-malicious) programs\". What's relevant is whether there is a realistic chance of soundness issues in well-intentioned code here, and I am not aware of evidence for such a soundness issue. And if you worry about malicious code and rustc (presumably with `forbid(unsafe_code)`) is your only line of defense, then we are talking about a completely different world. That's why people keep bringing up the attack model.\r\n\r\nThe theoretician in me would absolutely prefer a TypeId scheme that does not depend on any probabilistic arguments. And I understand that what rustc does makes no sense at all when viewed through the lens of a cyptographer. But pragmatically speaking I don't see what an attack would look like here, and as far as I was able to see nobody has described such an attack above. My understanding is that it would require (1) an attacker finding two Rust types that hash to the same TypeId, and then (2) the attacker must convince me to add their code as a static or dynamic dependency to my program, with me blindly trusting its soundness. Most of the discussion above has been about (1), arguing that this is easier than people thought. (The fact that collisions in 128bit-truncated SHA256 are feasible is new to me, thanks for sharing that!) But that totally misses the point that the soundness argument doesn't just rely on (1) not happening, it relies on (1)+(2) not happening.\r\n\r\nFor the people arguing that this is worse than [\"regular\" soundness issues](https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AI-unsound) (at least I think that is what @briansmith is arguing), I think it'd help to spell out the attack you are imagining. Or maybe we're just discussing how severe of a soundness issue this is? It seems way harder to exploit than some of our others, so I don't see a good reason to give this one particularly high priority.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1875121102/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876176056",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1876176056",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1876176056,
    "node_id": "IC_kwDOAAsO6M5v1Cy4",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-04T01:10:14Z",
    "updated_at": "2024-01-04T01:11:30Z",
    "body": "> The linker magic part was never implemented I think. I am not even sure if we ever concluded that all our platforms have sufficiently powerful linkers to provide such magic. Personally I'd be happy to see further experimentation in that area.\r\n\r\nRather than relying on linker \"magic,\" it may make sense to have an optimized case for types known statically at the time the executable is about to be linked, vs. types that aren't known at that time. (Basically, a pre-link step.) It would maybe not be cheap.\r\n\r\n> If the linker magic part does not work out then there is the problem that a successful equality test slows down by a lot since it has to compare the strings for equality.\r\n\r\nBy \"the strings\" I guess you mean the `Any::type_name`. `Any::type_name` is optimized for human readability, not for size/performance. There are much more compact encodings of the string that are possible. Or, there are other implementation strategies. For example, one could imagine maintaining (at runtime) a globally counter, with each `type_id` implementation lazily allocating the `TypeId(u64)` value on first use. Or see what GCC does to handle the tricker cases in its `std::type_name` implementation. This is not a new problem since C++ has basically the same construct and has dealt with it.\r\n\r\n> > As a bit of a meta comment the current approach seems to be misapplying cryptographic primitives in ways that create problems where they otherwise wouldn't exist, and I think that's the core concern here.\r\n\r\n> Either way, I think the claim that we have a collision probability of around 2^64 for regular (non-malicious) programs is correct. \r\n\r\nWhat is the reasoning that was used to reach that belief? I think it is good to write down the reasoning we are using so we can all agree on it. Just like, if we made a change to the borrow checker, we'd review the reasoning for the change to verify that the reasoning is sound.\r\n\r\n> And I understand that what rustc does makes no sense at all when viewed through the lens of a cyptographer. \r\n\r\nI am not saying this \"makes no sense at all.\" \r\n\r\nAgain, the beginning of my argument was, \"Hey, it looks like you're assuming a certain collision rate; let's see how that collision rate is being calculated, because based on the comment I read, the reasoning isn't sound.\" And then the other part of my argument is that it looks like people have some threshold for what is an acceptable collision rate, but I don't think we have a sound argument in favor of a particular collision rate as being acceptable.\r\n\r\nKeep in mind that these hash comparisons are critical for the correctness and memory-safety of `Any::{is, downcast_*}` and many other memory-safety-critical primitives that are not marked `unsafe`, so the collisions directly affect the memory safety of programs. (Similarly for the way similar comparisons are reportedly done within the compiler.)\r\n\r\nPeople keep using this 1/2^64 number; let's see an argument that starts with \"Here is how TypeId is calculated\" and ends with \"1/2^64.\"\r\n\r\nHere is an example: `x \u21a6 u128::MAX` is a hash function with an output that is 128 bits. The birthday bound of a 128-bit hash function gives us a collision rate of at least 1/2^64. Then this hash function has a collision rate of 1/2^64. (This is not a valid argument because the birthday bound is a lower bound but says nothing about the upper bound.)\r\n\r\n> For the people arguing that this is worse than [\"regular\" soundness issues](https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AI-unsound) (at least I think that is what @briansmith is arguing),\r\n\r\nI think we agreed that the meta-discussion about what responsibility if any the compiler has w.r.t. security should be somewhere else, so I'm not going to debate that further here.\r\n\r\nTo clarify my position: `TypeId` should do what it is documented to do for all inputs that the toolchain translates into executable programs (roughly all valid programs), so that all TypeID-based constructs, including `Any::{downcast_ref, is}` are memory-safe. No exceptions.  We shouldn't accept 1/2^64 rate of failure of memory safety *by design* as acceptable. (If we're operating on the assumption that an intentional 1/2^64 memory safety failure rate is OK, then let's put that in writing in the language reference specification; I believe such a change won't be accepted.)\r\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876176056/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876181173",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1876181173",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1876181173,
    "node_id": "IC_kwDOAAsO6M5v1EC1",
    "user": {
      "login": "digama0",
      "id": 868588,
      "node_id": "MDQ6VXNlcjg2ODU4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/868588?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/digama0",
      "html_url": "https://github.com/digama0",
      "followers_url": "https://api.github.com/users/digama0/followers",
      "following_url": "https://api.github.com/users/digama0/following{/other_user}",
      "gists_url": "https://api.github.com/users/digama0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/digama0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/digama0/subscriptions",
      "organizations_url": "https://api.github.com/users/digama0/orgs",
      "repos_url": "https://api.github.com/users/digama0/repos",
      "events_url": "https://api.github.com/users/digama0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/digama0/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-04T01:18:22Z",
    "updated_at": "2024-01-04T01:19:51Z",
    "body": "> People keep using this 1/2^64 number; let's see an argument that starts with \"Here is how TypeId is calculated\" and ends with \"1/2^64.\"\r\n\r\nYou *do* realize that any such argument is going to have \"and therefore P != NP\" in the middle, right? Rigorous proofs of pretty much anything in the cryptography world (other than relative hardness proofs) is a luxury we cannot afford.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876181173/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876182964",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1876182964",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1876182964,
    "node_id": "IC_kwDOAAsO6M5v1Ee0",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-04T01:21:32Z",
    "updated_at": "2024-01-04T01:21:32Z",
    "body": "> You do realize that any such argument is going to have \"and therefore P != NP\" in the middle, right? Rigorous proofs of pretty much anything in the cryptography world (other than relative hardness proofs) is a luxury we cannot afford.\r\n\r\nI'm just asking people to show how they got the 1^2/64 number. People are \"believing\" the collision rate to be that but why?",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876182964/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876183837",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1876183837",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1876183837,
    "node_id": "IC_kwDOAAsO6M5v1Esd",
    "user": {
      "login": "digama0",
      "id": 868588,
      "node_id": "MDQ6VXNlcjg2ODU4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/868588?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/digama0",
      "html_url": "https://github.com/digama0",
      "followers_url": "https://api.github.com/users/digama0/followers",
      "following_url": "https://api.github.com/users/digama0/following{/other_user}",
      "gists_url": "https://api.github.com/users/digama0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/digama0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/digama0/subscriptions",
      "organizations_url": "https://api.github.com/users/digama0/orgs",
      "repos_url": "https://api.github.com/users/digama0/repos",
      "events_url": "https://api.github.com/users/digama0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/digama0/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-04T01:23:18Z",
    "updated_at": "2024-01-04T01:26:13Z",
    "body": "For no formally justifiable reason. Asking them to produce one is not reasonable under the conditions because we can all see that it is impossible to produce one without solving some really hard mathematical problems first.\r\n\r\n*Of course* I think this sucks. I literally make my trade in proving systems like this correct, and it is disheartening to see cryptography anywhere near this because of the known limitations of that style of proof (if it can even be called that). But unless you have a better proposal I don't think it is useful to be pointing this out at this stage, these are the known facts of the situation and I suspect Any is making impossible promises, at least as long as it has fixed size.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876183837/reactions",
      "total_count": 2,
      "+1": 0,
      "-1": 2,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876185520",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1876185520",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1876185520,
    "node_id": "IC_kwDOAAsO6M5v1FGw",
    "user": {
      "login": "the8472",
      "id": 1065730,
      "node_id": "MDQ6VXNlcjEwNjU3MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/the8472",
      "html_url": "https://github.com/the8472",
      "followers_url": "https://api.github.com/users/the8472/followers",
      "following_url": "https://api.github.com/users/the8472/following{/other_user}",
      "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/the8472/subscriptions",
      "organizations_url": "https://api.github.com/users/the8472/orgs",
      "repos_url": "https://api.github.com/users/the8472/repos",
      "events_url": "https://api.github.com/users/the8472/events{/privacy}",
      "received_events_url": "https://api.github.com/users/the8472/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-04T01:26:09Z",
    "updated_at": "2024-01-04T01:26:28Z",
    "body": "I already linked https://github.com/rust-lang/rust/pull/107925#issuecomment-1427151276 in a previous comment.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876185520/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876227832",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1876227832",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1876227832,
    "node_id": "IC_kwDOAAsO6M5v1Pb4",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-04T02:34:00Z",
    "updated_at": "2024-01-04T02:34:00Z",
    "body": "> I already linked https://github.com/rust-lang/rust/pull/107925#issuecomment-1427151276 in a previous comment.\r\n\r\nI quickly skimmed the 2nd linked paper. I do not pretend to know anything about differential cryptanalysis. The 2nd paper is analyzing SipHash with an unknown key. They note that attacks are much easier when the key is known than their characteristic for internal collisions indicates, because other techniques based on input modification can be used for unkeyed functions. Further, I think whoever did the analysis on our end seemed to extrapolate from their published characteristic for internal collisions to the difficulty of a collision of the final output. I don't see the logic that was used to make that leap.\r\n\r\nFor context, the complexity of intentionally creating a collision for SHA-1 is currently estimated to be about 2^52 to 2^63 as published results of several years ago. Compared to SipHash-128 with an all-zero key, SHA-1 has more complex rounds, an order of magnitude more rounds, double the internal state size (512 bit internal state vs 256 bit), and a larger output (160 bits vs 128 bits). Accordingly, it is hard to believe a conclusion where we find SipHash-128 to be more collision-resistant than SHA-1 and equally collision-resistant to SHA-256 (a much stronger hash function) truncated to 128 bits. ",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876227832/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876232662",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1876232662",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1876232662,
    "node_id": "IC_kwDOAAsO6M5v1QnW",
    "user": {
      "login": "digama0",
      "id": 868588,
      "node_id": "MDQ6VXNlcjg2ODU4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/868588?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/digama0",
      "html_url": "https://github.com/digama0",
      "followers_url": "https://api.github.com/users/digama0/followers",
      "following_url": "https://api.github.com/users/digama0/following{/other_user}",
      "gists_url": "https://api.github.com/users/digama0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/digama0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/digama0/subscriptions",
      "organizations_url": "https://api.github.com/users/digama0/orgs",
      "repos_url": "https://api.github.com/users/digama0/repos",
      "events_url": "https://api.github.com/users/digama0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/digama0/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-04T02:41:27Z",
    "updated_at": "2024-01-04T02:41:27Z",
    "body": "> the complexity of intentionally creating a collision\r\n\r\nAs Ralf said above, the goal is not to be robust against intentional collisions, it is robustness against *unintentional* collisions. Here it is much more reasonable to assume an even spread of values, because they are not being adversarially chosen so as long as the hash has enough mixing behavior this gives values spread throughout the whole range. This is where the \"attacker model\" makes the difference, because to intentionally cause a collision means to have a nefarious piece of code in your code or in a dependency and such code can already do much worse than attempt to break rustc.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876232662/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876290231",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1876290231",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1876290231,
    "node_id": "IC_kwDOAAsO6M5v1eq3",
    "user": {
      "login": "the8472",
      "id": 1065730,
      "node_id": "MDQ6VXNlcjEwNjU3MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/the8472",
      "html_url": "https://github.com/the8472",
      "followers_url": "https://api.github.com/users/the8472/followers",
      "following_url": "https://api.github.com/users/the8472/following{/other_user}",
      "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/the8472/subscriptions",
      "organizations_url": "https://api.github.com/users/the8472/orgs",
      "repos_url": "https://api.github.com/users/the8472/repos",
      "events_url": "https://api.github.com/users/the8472/events{/privacy}",
      "received_events_url": "https://api.github.com/users/the8472/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-04T04:20:52Z",
    "updated_at": "2024-01-04T04:20:52Z",
    "body": "To phrase it differently. In our model we pretend that the inputs are generated by an actor that does neither know nor bother to optimize its input-generation process over the hash function or its key.\r\n\r\nWhich means we can treat the situation as-if a random key was chosen. It also excludes adaptive black-box attacks.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876290231/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876871416",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1876871416",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1876871416,
    "node_id": "IC_kwDOAAsO6M5v3sj4",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-04T10:36:44Z",
    "updated_at": "2024-01-04T10:36:44Z",
    "body": "And from that it then follows that the properties of the hash function don't really matter, and we can use the birthday bound with good approximation. So the reasoning for the 2^64 bound is: if we feed random inputs to a ~decent hash function with 128bit output, we'll get collisions at a rate of approximately 2^-64. Real inputs aren't random but the programs people write are extremely unlikely to align with the structure of the hash function in any meaningful way, except if programs are specifically designed to exploit the hash function, which we assume does not happen. (Pragmatically speaking: there are much easier-to-exploit soundness bugs, why would an attacker bother finding a hash collision.)\r\n\r\nIf I had to model this for a formal soundness argument I'd use some sort of random oracle model.\r\n\r\n---\r\n\r\n> Rather than relying on linker \"magic,\" it may make sense to have an optimized case for types known statically at the time the executable is about to be linked, vs. types that aren't known at that time. (Basically, a pre-link step.) It would maybe not be cheap.\r\n\r\n> By \"the strings\" I guess you mean the Any::type_name. Any::type_name is optimized for human readability, not for size/performance. There are much more compact encodings of the string that are possible. Or, there are other implementation strategies. For example, one could imagine maintaining (at runtime) a globally counter, with each type_id implementation lazily allocating the TypeId(u64) value on first use. Or see what GCC does to handle the tricker cases in its std::type_name implementation. This is not a new problem since C++ has basically the same construct and has dealt with it.\r\n\r\nI don't think anyone is objecting to experimenting with approaches to avoid relying on a hash here.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1876871416/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1881838223",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1881838223",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1881838223,
    "node_id": "IC_kwDOAAsO6M5wKpKP",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-08T21:19:15Z",
    "updated_at": "2024-01-08T21:19:15Z",
    "body": "@RalfJung wrote:\r\n> Real inputs aren't random but the programs people write are extremely unlikely to align with the structure of the hash function in any meaningful way\r\n\r\nI am not sure how why we should think so. I do not think we have strong evidence of it.\r\n\r\n@RalfJung wrote:\r\n> except if programs are specifically designed to exploit the hash function, which we assume does not happen. \r\n> (Pragmatically speaking: there are much easier-to-exploit soundness bugs, why would an attacker bother finding a hash collision.)\r\n\r\nWhere is the evidence for this claim? There are 83 open I-unsound issues total. Only 14 open I-unsound issues are in the T-lang component. I couldn't find 7 that look easier to exploit than this; almost all of them would be easily mitigated by code review. So I don't think we have evidence that this is hard to exploit compared to other I-unsound issues.\r\n\r\nIf we think like an attacker, one of the reasons this would be appealing to exploit is that it is unlikely to be fixed. (This issue is a decade old), and a PoC that would be convincing enough to change that would be extremely expensive to produce. This is exactly what happened with MD5 to enable FLAME; MD5 collisions were both too expensive to be considered a worthwhile attack vector in real life, but also MD5 was already theoretically broken so nobody could be funded to produce a PoC until it was too late.\r\n\r\n> If I had to model this for a formal soundness argument I'd use some sort of random oracle model.\r\n\r\nYou could prove that the current scheme is correct when instantiated with a random oracle model, predicating the proof on \"assume we use a hash function that operates like a random oracle,\" i.e. predicating the proof on the collision-resistance and preimage resistance of whatever hash function is used. In the case of instantiating the scheme with SipHash128-with-an-all-zeros key, you wouldn't be able to use that proof since the hash function doesn't meet the proof's precondition of acting like a random oracle.\r\n\r\nIn one of the other discussions, it was suggested that somebody trying to force a collision would need to use large inputs that would not be practical as type names, as typically collision attacks on secure hash functions are easier when a certain multi-block structure is used. That is true for secure hash functions, but it is not true for non-secure hash functions. We should be able to find single-block collisions in the SipHash128-with-an-all-zero-key hash function easily. Consider that MD5 single-block collisions were found; see https://marc-stevens.nl/research/md5-1block-collision/md5-1block-collision.pdf. Note that the two colliding 64-byte messages only differed by two bits total. SipHash128-with-an-all-zeros-key should be easier to force collisions.\r\n\r\ni just stumbled across https://github.com/rust-lang/rust/pull/95845#issuecomment-1201208390, where Ralf wrote:\r\n> A small TypeId is simply unsound, as we do have real-world examples of collisions. So that is not an option.\r\n\r\nSo I think we are in agreement in overall. He wrote that when TypeId was 64 bits but the situation isn't too different when it is 128 bits. Before we had evidence of a real probilem. Now we have an absence of evidence, but not evidence of absence. The evidence that we'd likely need, for or against, is unreasonably expensive to acquire. We could pay a student $100,000 to acquire it if somebody were willing to fund it. But, implementing a non-hash-based solution would likely cost much less than that, and we'd have a certain fix.\r\n\r\nI think the approach in https://github.com/rust-lang/rust/pull/95845 looks very good. If performance is an issue then it could be improved by using a more compact encoding of the name instead of the normal v0 mangled form of the name, since the name mangle scheme is still optimized too much for human readability. It looked like the performance measurement results of that approach was also OK.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1881838223/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1881858482",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1881858482",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1881858482,
    "node_id": "IC_kwDOAAsO6M5wKuGy",
    "user": {
      "login": "bjorn3",
      "id": 17426603,
      "node_id": "MDQ6VXNlcjE3NDI2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bjorn3",
      "html_url": "https://github.com/bjorn3",
      "followers_url": "https://api.github.com/users/bjorn3/followers",
      "following_url": "https://api.github.com/users/bjorn3/following{/other_user}",
      "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions",
      "organizations_url": "https://api.github.com/users/bjorn3/orgs",
      "repos_url": "https://api.github.com/users/bjorn3/repos",
      "events_url": "https://api.github.com/users/bjorn3/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bjorn3/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-08T21:35:35Z",
    "updated_at": "2024-01-08T21:35:35Z",
    "body": "The v0 symbol mangling is not optimized for human readability at all. It is a compact encoding of the full function/type name. For example it has backreferences and encodes hashes as base-62 (the stable crate id/disambiguator, this is checked by rustc for collisions and will result in an error if a collision occurs). It also encodes primitive types using single letters. Frankly I find v0 symbols to be pretty much unreadable, while I can read legacy symbols with very little effort. That may say something about the fact that I have had to read legacy symbols a lot though while working on cg_clif.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1881858482/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1881939821",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1881939821",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1881939821,
    "node_id": "IC_kwDOAAsO6M5wLB9t",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-08T22:45:04Z",
    "updated_at": "2024-01-08T22:53:46Z",
    "body": "@briansmith From what you say, we do not even have an example of this unsoundness being demonstrated for a recent version of rustc (any version since the switch to 128bit type IDs). That makes this I-unsound issue the only one without a reproducing example. I would say that is fairly clear evidence that it is harder to exploit (and by a significant margin) than all the other I-unsound issues. The others did not require 100k or more in compute cost, this one does.\r\n\r\nAbsent such an example, what you are saying about detecting this in reviews is pure speculation. I find it hard to believe that the absurd types one has to construct to create a hash collision would not be caught in review.   In contrast, some of the other I-unsound issues could be hidden behind fairly benign-looking function signatures or trait constructions.\r\n\r\n> This is exactly what happened with MD5 to enable FLAME\r\n\r\nThe analogy with MD5 misses the fact that we are already assuming the authors of all Rust code that you include in your binary to not be adversarial.\r\n\r\n>  You could prove that the current scheme is correct when instantiated with a random oracle model, predicating the proof on \"assume we use a hash function that operates like a random oracle,\" i.e. predicating the proof on the collision-resistance and preimage resistance of whatever hash function is used. In the case of instantiating the scheme with SipHash128-with-an-all-zeros key, you wouldn't be able to use that proof since the hash function doesn't meet the proof's precondition of acting like a random oracle.\r\n\r\nNo real hash function acts like a random oracle. So any proof based on the random oracle model fails when instantiated with an actual hash function. At least that is my understanding of the random oracle model. (Though of course SipHash is way further away from that than a cryptographic hash.)\r\n\r\n> But, implementing a non-hash-based solution would likely cost much less than that, and we'd have a certain fix.\r\n\r\nWe agree that this is the most desirable outcome. We just disagree on the prioritization. But this is open-source, prioritization means fairly little -- nothing we discuss here is likely to change whether some contributor will make this their next passion project, so the entire discussion is probably rather futile.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1881939821/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1887239511",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1887239511",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1887239511,
    "node_id": "IC_kwDOAAsO6M5wfP1X",
    "user": {
      "login": "veorq",
      "id": 3204810,
      "node_id": "MDQ6VXNlcjMyMDQ4MTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3204810?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/veorq",
      "html_url": "https://github.com/veorq",
      "followers_url": "https://api.github.com/users/veorq/followers",
      "following_url": "https://api.github.com/users/veorq/following{/other_user}",
      "gists_url": "https://api.github.com/users/veorq/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/veorq/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/veorq/subscriptions",
      "organizations_url": "https://api.github.com/users/veorq/orgs",
      "repos_url": "https://api.github.com/users/veorq/repos",
      "events_url": "https://api.github.com/users/veorq/events{/privacy}",
      "received_events_url": "https://api.github.com/users/veorq/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-01-11T14:09:20Z",
    "updated_at": "2024-01-11T14:11:45Z",
    "body": "(Thanks @tarcieri for contacting me about this.)\r\n\r\nOne of my life's regrets is naming SipHash \"SipHash\" when it's a PRF/MAC rather than a general-purpose, unkeyed hash function :)\r\n\r\nWhen the key is fixed/known, the original 64-bit SipHash is *not* collision-resistance, in an adversarial setting, as the cost of finding a collision is only that of about 2<sup>32</sup> function evaluations (birthday attack etc.). This is a few minutes on a laptop.\r\n\r\nIt [looks like](https://github.com/rust-lang/rust/blob/b79f0261f87ff38de6fee6a6f6ce9915a8f0e6b4/compiler/rustc_data_structures/src/stable_hasher.rs#L36) here you'd use SipHash128, the version producting 128-bit output, with 2+4 rounds. The cost of collisions would then be 2<sup>64</sup>. This would be days with a bunch of GPUs, so *not secure* either, cryptographically speaking.\r\n\r\nAre faster ways to find collisions than the birthday attack? I'm not aware of such cryptanalysis results. There's a \"distinguisher\" [for 3 rounds](https://eprint.iacr.org/2021/189), but that's a long way to getting a collision attack faster than the generic attack.\r\n\r\nThat said, [quoting](https://github.com/rust-lang/rust/issues/10389#issuecomment-1876232662) @digama0:\r\n\r\n> the goal is not to be robust against intentional collisions, it is robustness against unintentional collisions\r\n\r\nIn such a case it would be fine. (Theoretically speaking, what you'd then need is called a *universal hash function*, which in principle requires a key.) But idk if that \"unintentional\" assumption is and will remain reasonable, as you've discussed.\r\n\r\n\r\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1887239511/reactions",
      "total_count": 4,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 4
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1937392826",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-1937392826",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 1937392826,
    "node_id": "IC_kwDOAAsO6M5zekS6",
    "user": {
      "login": "shelerr",
      "id": 78213268,
      "node_id": "MDQ6VXNlcjc4MjEzMjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/78213268?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shelerr",
      "html_url": "https://github.com/shelerr",
      "followers_url": "https://api.github.com/users/shelerr/followers",
      "following_url": "https://api.github.com/users/shelerr/following{/other_user}",
      "gists_url": "https://api.github.com/users/shelerr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shelerr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shelerr/subscriptions",
      "organizations_url": "https://api.github.com/users/shelerr/orgs",
      "repos_url": "https://api.github.com/users/shelerr/repos",
      "events_url": "https://api.github.com/users/shelerr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shelerr/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-02-11T02:02:38Z",
    "updated_at": "2024-02-11T02:02:38Z",
    "body": "I would like to note, that there seems to be a misunderstanding in this discussion about what exactly the birthday paradox implies. Having 128-bit hashes doesn't mean that there is a probability of 1/2^64 of a collision (what would that even mean?). It actually means that if you had 2^64 different types, that the probability of a collision between at least two of them would be roughly 50% (~39.34%).\r\n\r\nIn general, the probability of a collision can be estimated as d^2/2n, where d is the amount of types, and n - amount of possible hashes (if d is much smaller than n). For example, if you had 2^32 different types, the probability would be 1/2^65. Or, as another example, 1/2^81 for 2^24 types. And even that seems like too many types to be handled by any piece of code.",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/1937392826/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2178933876",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2178933876",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2178933876,
    "node_id": "IC_kwDOAAsO6M6B3-R0",
    "user": {
      "login": "bstrie",
      "id": 865233,
      "node_id": "MDQ6VXNlcjg2NTIzMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bstrie",
      "html_url": "https://github.com/bstrie",
      "followers_url": "https://api.github.com/users/bstrie/followers",
      "following_url": "https://api.github.com/users/bstrie/following{/other_user}",
      "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions",
      "organizations_url": "https://api.github.com/users/bstrie/orgs",
      "repos_url": "https://api.github.com/users/bstrie/repos",
      "events_url": "https://api.github.com/users/bstrie/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bstrie/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-19T15:06:11Z",
    "updated_at": "2024-06-19T15:06:11Z",
    "body": "I think we need to ask the lang team for explicit guidance here, in order to answer the following question: \"Is it acceptable for soundness to rely on the nonzero probability of a hash collision?\"\r\n\r\nIf the answer is \"yes\", then we also need the lang team to determine the exact threshold of probability that is acceptable, and it needs to be documented. Then, if the current chance of a TypeId collision is less than that probability, this issue can be closed.\r\n\r\nBut if the answer is \"no\", then we can completely disregard all prior discussion here regarding hashing functions and pivot this issue away from cryptographic arguments and towards discussing practical ways of implementing TypeId equality that don't rely on probability.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2178933876/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2179224371",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2179224371",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2179224371,
    "node_id": "IC_kwDOAAsO6M6B5FMz",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-19T17:36:40Z",
    "updated_at": "2024-06-19T17:36:40Z",
    "body": "It would probably be good to have a summary of the problem statement and the various positions. Then we can nominate this for t-lang discussion, or propose a design meeting.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2179224371/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2179648066",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2179648066",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2179648066,
    "node_id": "IC_kwDOAAsO6M6B6spC",
    "user": {
      "login": "bstrie",
      "id": 865233,
      "node_id": "MDQ6VXNlcjg2NTIzMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bstrie",
      "html_url": "https://github.com/bstrie",
      "followers_url": "https://api.github.com/users/bstrie/followers",
      "following_url": "https://api.github.com/users/bstrie/following{/other_user}",
      "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions",
      "organizations_url": "https://api.github.com/users/bstrie/orgs",
      "repos_url": "https://api.github.com/users/bstrie/repos",
      "events_url": "https://api.github.com/users/bstrie/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bstrie/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T01:19:30Z",
    "updated_at": "2024-06-20T01:19:30Z",
    "body": "Sure, but I think it's worth emphasizing the following:\r\n\r\n1. Some of the discussion here has evoked the cryptographic notion of an adversary, which I believe to be irrelevant when it comes to unsoundness. In historic cases, the notion of \"how likely is this to be exploited in the wild\" has been used to *prioritize* soundness bugs; it has never been used to *disregard* soundness bugs. In other words, even if the only way to exercise a soundness bug is via someone who has complete control over the source code, this has never stopped a soundness bug from being classified as a soundness bug.\r\n\r\n    Therefore, we should not get bogged down in a discussion of how practically exploitable this issue is; this is not a cryptographic flaw, it is a soundness flaw (unless the lang team decides otherwise, which is the whole point here).\r\n\r\n2. We can acknowledge that the only way to prevent hash collisions is to use a universal hash function, and also that it is impossible to use a universal hash function if the compiler doesn't have full foreknowledge of all types that will be used in the program, which is impossible in the case of shared libraries. This means that every hash function up for consideration features potential collisions.\r\n\r\n    Therefore, until we decide whether or not *any* nonzero chance of a collision is acceptable, any debate over *which* hash function to use is premature, and can be disregarded.\r\n\r\nThis is why I recommend that the lang team consider answering the yes/no question \"Is it acceptable for soundness to rely on the nonzero probability of a hash collision?\"\r\n\r\nAs far as the lang team is concerned, it should suffice to know that there exist potential solutions which could be used instead of a hash, which will probably look like this: https://github.com/rust-lang/rust/pull/95845",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2179648066/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2179774972",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2179774972",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2179774972,
    "node_id": "IC_kwDOAAsO6M6B7Ln8",
    "user": {
      "login": "dlight",
      "id": 179028,
      "node_id": "MDQ6VXNlcjE3OTAyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/179028?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dlight",
      "html_url": "https://github.com/dlight",
      "followers_url": "https://api.github.com/users/dlight/followers",
      "following_url": "https://api.github.com/users/dlight/following{/other_user}",
      "gists_url": "https://api.github.com/users/dlight/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dlight/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dlight/subscriptions",
      "organizations_url": "https://api.github.com/users/dlight/orgs",
      "repos_url": "https://api.github.com/users/dlight/repos",
      "events_url": "https://api.github.com/users/dlight/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dlight/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T04:17:39Z",
    "updated_at": "2024-06-20T04:17:39Z",
    "body": "> But if the answer is \"no\", then we can completely disregard all prior discussion here regarding hashing functions and pivot this issue away from cryptographic arguments and towards discussing practical ways of implementing TypeId equality that don't rely on probability.\r\n\r\nThere's some ways to do this, but one approach is to change absolutely nothing about how TypeId works but *fail compilation* if we ever find a type id collision anywhere in the program. That's enough to achieve soundness, and could in practice be a very quick check.\r\n\r\nAnd if collisions are truly unlikely, then perhaps this compiler error will never trigger in practice. But if it triggered only once, at least it avoided a very hard to debug unsoundness in that specific case. (Something else that could happen is that some day some compiler bug might make those collisions more likely, which could trip this check and cause random compilation failures)",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2179774972/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2179778355",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2179778355",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2179778355,
    "node_id": "IC_kwDOAAsO6M6B7Mcz",
    "user": {
      "login": "bstrie",
      "id": 865233,
      "node_id": "MDQ6VXNlcjg2NTIzMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bstrie",
      "html_url": "https://github.com/bstrie",
      "followers_url": "https://api.github.com/users/bstrie/followers",
      "following_url": "https://api.github.com/users/bstrie/following{/other_user}",
      "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions",
      "organizations_url": "https://api.github.com/users/bstrie/orgs",
      "repos_url": "https://api.github.com/users/bstrie/repos",
      "events_url": "https://api.github.com/users/bstrie/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bstrie/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T04:22:36Z",
    "updated_at": "2024-06-20T04:22:36Z",
    "body": "> fail compilation if we ever find a type id collision anywhere in the program\r\n\r\nThis sounds like a good thing to implement on a best-effort basis if people decide to stick with the hash approach, but in order to solve the problem in the case of shared libraries we'd need the dynamic linker to play along, and then we'd have a situation where we're asterisk-qualifying Rust's safety story with \"you must link your program with a Sufficiently Smart Linker\".",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2179778355/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2179873833",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2179873833",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2179873833,
    "node_id": "IC_kwDOAAsO6M6B7jwp",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T05:54:37Z",
    "updated_at": "2024-06-20T05:54:56Z",
    "body": "Shared library loading already has some asterisks to the soundness story, like not composing libraries that were built with different versions of rustc or with incompatible flags. Is this qualitatively different?\r\n\r\n> Some of the discussion here has evoked the cryptographic notion of an adversary, which I believe to be irrelevant when it comes to unsoundness. In historic cases, the notion of \"how likely is this to be exploited in the wild\" has been used to prioritize soundness bugs; it has never been used to disregard soundness bugs. In other words, even if the only way to exercise a soundness bug is via someone who has complete control over the source code, this has never stopped a soundness bug from being classified as a soundness bug.\r\n\r\nWe never before had a soundness bug where \"can you write a program that exploits the bug\" is a computationally hard question, and the answer might be \"only if you give me a supercomputer the size of a planet\". So the fact that we never disregarded a soundness bug on these grounds may not mean much. So far, \"how likely is the bug to be exploited\" meant \"how likely is it that someone puts this short snippet of code into their crate\", which is very different from \"how likely is it that someone is even able to obtain a snippet of code that hits the bug\".\r\n\r\nThere was also some discussion on whether it even makes sense to talk about probabilities, since the hash function is deterministic.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2179873833/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2180086913",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2180086913",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2180086913,
    "node_id": "IC_kwDOAAsO6M6B8XyB",
    "user": {
      "login": "bjorn3",
      "id": 17426603,
      "node_id": "MDQ6VXNlcjE3NDI2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bjorn3",
      "html_url": "https://github.com/bjorn3",
      "followers_url": "https://api.github.com/users/bjorn3/followers",
      "following_url": "https://api.github.com/users/bjorn3/following{/other_user}",
      "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions",
      "organizations_url": "https://api.github.com/users/bjorn3/orgs",
      "repos_url": "https://api.github.com/users/bjorn3/repos",
      "events_url": "https://api.github.com/users/bjorn3/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bjorn3/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T08:14:59Z",
    "updated_at": "2024-06-20T08:14:59Z",
    "body": "> like not composing libraries that were built with different versions of rustc\r\n\r\nI made the symbol mangling be affected by the rustc version a couple lf years ago already, so without a hash collision that isn't possible already due to the symbol names mismatching.\r\n\r\n> or with incompatible flags\r\n\r\nWe should probably add those to the StableCrateId, which then ensures different symbol names.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2180086913/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181169783",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181169783",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181169783,
    "node_id": "IC_kwDOAAsO6M6CAgJ3",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T17:13:15Z",
    "updated_at": "2024-06-20T17:36:07Z",
    "body": ">  \"only if you give me a supercomputer the size of a planet\"\r\n\r\nOn [11:54 AM \u00b7 Mar 19, 2024], Marc Stevens ([@realhashbreaker](https://x.com/realhashbreaker)) wrote:\r\n> ```\r\n> Here is a 72-byte alphanum MD5 collision with 1-byte difference for fun:\r\n> md5(\"TEXTCOLLBYfGiJUETHQ4hAcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak\")\r\n> =\r\n> md5(\"TEXTCOLLBYfGiJUETHQ4hEcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak\")\r\n> ```\r\n\r\n- https://x.com/realhashbreaker/status/1770161965006008570\r\n\r\n(The difference is \"hEcK\" vs \"hAcK\", i.e. one byte differs by a single bit; `assert!(b'E' == (b'A' | (1 << 2)))`.)\r\n\r\nI was following him on twitter when he was doing this and it took less than a day for him.\r\n\r\nSiphash128 with a fixed key is a weaker hash function than MD5.\r\n\r\nSo, I think we can stop fantasizing about such things needing extraordinary effort.\r\n\r\nEdit: In that twitter thread, he said it took half a day on a single 2x20 core machine.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181169783/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181200227",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181200227",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181200227,
    "node_id": "IC_kwDOAAsO6M6CAnlj",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T17:32:48Z",
    "updated_at": "2024-06-20T17:32:48Z",
    "body": "> \"how likely is it that someone is even able to obtain a snippet of code that hits the bug\".\r\n\r\nMark's script is at https://github.com/cr-marcstevens/hashclash/blob/master/scripts/textcoll.sh and I asked him about adapting hashclash for SipHash128-with-an-all-zero-key in https://github.com/cr-marcstevens/hashclash/issues/40. So hopefully it will be very easy soon.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181200227/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181253503",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181253503",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181253503,
    "node_id": "IC_kwDOAAsO6M6CA0l_",
    "user": {
      "login": "cr-marcstevens",
      "id": 20039241,
      "node_id": "MDQ6VXNlcjIwMDM5MjQx",
      "avatar_url": "https://avatars.githubusercontent.com/u/20039241?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cr-marcstevens",
      "html_url": "https://github.com/cr-marcstevens",
      "followers_url": "https://api.github.com/users/cr-marcstevens/followers",
      "following_url": "https://api.github.com/users/cr-marcstevens/following{/other_user}",
      "gists_url": "https://api.github.com/users/cr-marcstevens/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cr-marcstevens/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cr-marcstevens/subscriptions",
      "organizations_url": "https://api.github.com/users/cr-marcstevens/orgs",
      "repos_url": "https://api.github.com/users/cr-marcstevens/repos",
      "events_url": "https://api.github.com/users/cr-marcstevens/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cr-marcstevens/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T18:06:11Z",
    "updated_at": "2024-06-20T18:06:11Z",
    "body": "I think it's very funny that so much human time has been spend discussing this possible change to a cryptographically secure hash function.\r\nA code change that itself could have been done in time much less than the time spend by all here thinking and argueing on it.\r\n\r\nSipHash was designed to be a very good, even secure, PRF as long as it was used with a random key.\r\nBut that's not the case here.\r\nI guess the main concern here is speed, and while cryptographic security might not be needed but would avoid further discussions, so why not use Blake3 or so.",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181253503/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181291971",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181291971",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181291971,
    "node_id": "IC_kwDOAAsO6M6CA9_D",
    "user": {
      "login": "the8472",
      "id": 1065730,
      "node_id": "MDQ6VXNlcjEwNjU3MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/the8472",
      "html_url": "https://github.com/the8472",
      "followers_url": "https://api.github.com/users/the8472/followers",
      "following_url": "https://api.github.com/users/the8472/following{/other_user}",
      "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/the8472/subscriptions",
      "organizations_url": "https://api.github.com/users/the8472/orgs",
      "repos_url": "https://api.github.com/users/the8472/repos",
      "events_url": "https://api.github.com/users/the8472/events{/privacy}",
      "received_events_url": "https://api.github.com/users/the8472/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T18:28:33Z",
    "updated_at": "2024-06-20T18:28:33Z",
    "body": "Yes, speed is _the_ concern. See #107925 for an example about the impact of the chosen hash function.\r\nYou can still try if you want, but the overhead is likely prohibitive and an alternative solution would be required if a decision is made to require collision-freedom or at least cryptographic strength.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181291971/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181302284",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181302284",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181302284,
    "node_id": "IC_kwDOAAsO6M6CBAgM",
    "user": {
      "login": "bjorn3",
      "id": 17426603,
      "node_id": "MDQ6VXNlcjE3NDI2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bjorn3",
      "html_url": "https://github.com/bjorn3",
      "followers_url": "https://api.github.com/users/bjorn3/followers",
      "following_url": "https://api.github.com/users/bjorn3/following{/other_user}",
      "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions",
      "organizations_url": "https://api.github.com/users/bjorn3/orgs",
      "repos_url": "https://api.github.com/users/bjorn3/repos",
      "events_url": "https://api.github.com/users/bjorn3/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bjorn3/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T18:35:38Z",
    "updated_at": "2024-06-20T18:35:57Z",
    "body": "For `TypeId` specifically speed shouldn't matter a lot due to the relative rarity of `TypeId` compared to other uses of hashing in the compiler. There are other places where we also depend on collision freedom for soundness, where speed is very much important. For the cases where collision freedom is not depended on we already use [rustc-hash](https://github.com/rust-lang/rustc-hash) (this is a polynomial hash currently) rather than SipHash.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181302284/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181379004",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181379004",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181379004,
    "node_id": "IC_kwDOAAsO6M6CBTO8",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T19:25:00Z",
    "updated_at": "2024-06-20T19:25:00Z",
    "body": "The question as I understood is whether even a cryptographic hash is sufficient. After all, the probability that there exists a sha3 collision is 1. So there is a fundamental decision to be made whether we are okay with that: assuming a perfect hash function (random oracle style), is that good enough? And then if yes, how close to perfect does the actual hash function have to be?\n\nI was not referring to the current hash function specifically when I talked about computational hardness. I trust you in your judgments about how hard it is to find a collision in hash functions.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181379004/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181382845",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181382845",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181382845,
    "node_id": "IC_kwDOAAsO6M6CBUK9",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T19:26:36Z",
    "updated_at": "2024-06-20T19:26:36Z",
    "body": "Also, cool work on finding those collisions :)",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181382845/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181398545",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181398545",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181398545,
    "node_id": "IC_kwDOAAsO6M6CBYAR",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T19:38:03Z",
    "updated_at": "2024-06-20T19:41:33Z",
    "body": "Ralf, thanks for clarifying that. I had misread what you wrote.\r\n\r\n> And then if yes, how close to perfect does the actual hash function have to be?\r\n\r\nI cannot find it right now, but if it is useful I can find a discussion that made a pretty convincing argument that no practical hash function with 128-bit output can never be collision-free enough to approximate such a \"perfect\" hash that we could make a \"good enough\" argument for. And my understanding from the discussion above (or elsewhere?) is that increasing the hash size to 256 bits (which would probably be the minimum to be considered \"good enough\" for theoretical soundness arguments) is considered prohibitive, such that [edit] relying *solely* on hash comparison would be disqualified as a solution.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181398545/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181400407",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181400407",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181400407,
    "node_id": "IC_kwDOAAsO6M6CBYdX",
    "user": {
      "login": "cr-marcstevens",
      "id": 20039241,
      "node_id": "MDQ6VXNlcjIwMDM5MjQx",
      "avatar_url": "https://avatars.githubusercontent.com/u/20039241?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cr-marcstevens",
      "html_url": "https://github.com/cr-marcstevens",
      "followers_url": "https://api.github.com/users/cr-marcstevens/followers",
      "following_url": "https://api.github.com/users/cr-marcstevens/following{/other_user}",
      "gists_url": "https://api.github.com/users/cr-marcstevens/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cr-marcstevens/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cr-marcstevens/subscriptions",
      "organizations_url": "https://api.github.com/users/cr-marcstevens/orgs",
      "repos_url": "https://api.github.com/users/cr-marcstevens/repos",
      "events_url": "https://api.github.com/users/cr-marcstevens/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cr-marcstevens/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T19:39:24Z",
    "updated_at": "2024-06-20T19:39:24Z",
    "body": "It is one thing knowing there exist collisions in theory.\r\nIt is another having them show up in practice and screw things up.\r\nFor a 128-bit hash there would need to be about 2^64 different types in all rust code before you would *expect* to see a collision, they then also would need to coexist in 1 total compilation.\r\nThat seems unlikely enough to cause problems in practice.\r\n\r\nBut that is discounting conscious effort to cause bad stuff.\r\nFrom first glance SipHash-1-3 seems to have little enough mixing that I would certainly not surprised if there could be attacks.\r\nIt seemingly really relies on a secret random key for its security level.\r\nBut further cryptanalysis would be necessary to tell how secure it really is with a zero key.",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181400407/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181415425",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181415425",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181415425,
    "node_id": "IC_kwDOAAsO6M6CBcIB",
    "user": {
      "login": "the8472",
      "id": 1065730,
      "node_id": "MDQ6VXNlcjEwNjU3MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/the8472",
      "html_url": "https://github.com/the8472",
      "followers_url": "https://api.github.com/users/the8472/followers",
      "following_url": "https://api.github.com/users/the8472/following{/other_user}",
      "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/the8472/subscriptions",
      "organizations_url": "https://api.github.com/users/the8472/orgs",
      "repos_url": "https://api.github.com/users/the8472/repos",
      "events_url": "https://api.github.com/users/the8472/events{/privacy}",
      "received_events_url": "https://api.github.com/users/the8472/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T19:50:12Z",
    "updated_at": "2024-06-20T19:50:12Z",
    "body": "> But that is discounting conscious effort to cause bad stuff.\r\n\r\nYes, threat models have been discussed upthread.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181415425/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181420663",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181420663",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181420663,
    "node_id": "IC_kwDOAAsO6M6CBdZ3",
    "user": {
      "login": "cr-marcstevens",
      "id": 20039241,
      "node_id": "MDQ6VXNlcjIwMDM5MjQx",
      "avatar_url": "https://avatars.githubusercontent.com/u/20039241?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cr-marcstevens",
      "html_url": "https://github.com/cr-marcstevens",
      "followers_url": "https://api.github.com/users/cr-marcstevens/followers",
      "following_url": "https://api.github.com/users/cr-marcstevens/following{/other_user}",
      "gists_url": "https://api.github.com/users/cr-marcstevens/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cr-marcstevens/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cr-marcstevens/subscriptions",
      "organizations_url": "https://api.github.com/users/cr-marcstevens/orgs",
      "repos_url": "https://api.github.com/users/cr-marcstevens/repos",
      "events_url": "https://api.github.com/users/cr-marcstevens/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cr-marcstevens/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T19:53:28Z",
    "updated_at": "2024-06-20T19:53:28Z",
    "body": "I read some parts, it looks like such threats are not taken really in design. \r\n(Otherwise a cryptographic hash would already be used)\r\nYet, when a collision was demonstrated for the 64-bit hash, it was enough motivation to immediately switch to a 128-bit version?",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181420663/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181435627",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181435627",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181435627,
    "node_id": "IC_kwDOAAsO6M6CBhDr",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T19:57:36Z",
    "updated_at": "2024-06-20T19:57:36Z",
    "body": "Not \"immediately\", it took quite a while.^^\r\n\r\n> Yes, threat models have been discussed upthread.\r\n\r\nIndeed, a lot of stuff was discussed there.^^ I think we need a decent summary collecting all major positions before we can ask t-lang to take a look.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181435627/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181476113",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181476113",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181476113,
    "node_id": "IC_kwDOAAsO6M6CBq8R",
    "user": {
      "login": "the8472",
      "id": 1065730,
      "node_id": "MDQ6VXNlcjEwNjU3MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/the8472",
      "html_url": "https://github.com/the8472",
      "followers_url": "https://api.github.com/users/the8472/followers",
      "following_url": "https://api.github.com/users/the8472/following{/other_user}",
      "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/the8472/subscriptions",
      "organizations_url": "https://api.github.com/users/the8472/orgs",
      "repos_url": "https://api.github.com/users/the8472/repos",
      "events_url": "https://api.github.com/users/the8472/events{/privacy}",
      "received_events_url": "https://api.github.com/users/the8472/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T20:07:39Z",
    "updated_at": "2024-06-20T20:07:39Z",
    "body": "10 years from the report to the fix. And 32bit resistance is not enough even for non-malicious uses. Even if it's very rare it'd still happen eventually to someone over the course of normal rust use.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181476113/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181490669",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181490669",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181490669,
    "node_id": "IC_kwDOAAsO6M6CBuft",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T20:18:23Z",
    "updated_at": "2024-06-20T20:18:23Z",
    "body": "> I think we need a decent summary collecting all major positions before we can ask t-lang to take a look.\r\n\r\nThe bigger problem here is that now other parts of the Rust project, and other projects, are using rustc's use of SipHash 1-3 with an all-zero key and 128-bit output as an indication that it is good enough for their uses. See:\r\n* https://github.com/rust-lang/cargo/issues/6529#issuecomment-2181473376\r\n* https://github.com/rust-lang/cargo/issues/13171\r\n* https://github.com/typst/comemo/issues/3\r\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181490669/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181555714",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181555714",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181555714,
    "node_id": "IC_kwDOAAsO6M6CB-YC",
    "user": {
      "login": "saethlin",
      "id": 12105168,
      "node_id": "MDQ6VXNlcjEyMTA1MTY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saethlin",
      "html_url": "https://github.com/saethlin",
      "followers_url": "https://api.github.com/users/saethlin/followers",
      "following_url": "https://api.github.com/users/saethlin/following{/other_user}",
      "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions",
      "organizations_url": "https://api.github.com/users/saethlin/orgs",
      "repos_url": "https://api.github.com/users/saethlin/repos",
      "events_url": "https://api.github.com/users/saethlin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saethlin/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T21:00:50Z",
    "updated_at": "2024-06-20T21:00:50Z",
    "body": "I should think that simply directing people to read the discussion here would be sufficient to dissuade them. Or, even better, directing them to a summary.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181555714/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181708504",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2181708504",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2181708504,
    "node_id": "IC_kwDOAAsO6M6CCjrY",
    "user": {
      "login": "tarcieri",
      "id": 797,
      "node_id": "MDQ6VXNlcjc5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/797?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tarcieri",
      "html_url": "https://github.com/tarcieri",
      "followers_url": "https://api.github.com/users/tarcieri/followers",
      "following_url": "https://api.github.com/users/tarcieri/following{/other_user}",
      "gists_url": "https://api.github.com/users/tarcieri/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tarcieri/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tarcieri/subscriptions",
      "organizations_url": "https://api.github.com/users/tarcieri/orgs",
      "repos_url": "https://api.github.com/users/tarcieri/repos",
      "events_url": "https://api.github.com/users/tarcieri/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tarcieri/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-20T23:24:30Z",
    "updated_at": "2024-06-20T23:24:30Z",
    "body": "One important comment in this thread that I hope doesn't get lost is [per SipHash's author (and as others have noted), it's designed to be a keyed PRF, not an unkeyed hash function, and `StableHasher` is attempting to use it as the latter](https://github.com/rust-lang/rust/issues/10389#issuecomment-1887239511), which can be considered a misuse by some (as @cr-marcstevens noted, \"It seemingly really relies on a secret random key for its security level\").\r\n\r\nFrom what I can tell the selection of SipHash for `StableHasher` is motivated primarily by the amount of work has gone into performance optimizing SipHash within rustc and no one has yet done the work to get a proper unkeyed hash function (SHA2/SHA3/BLAKE2/BLAKE3/Ascon-Hash) to a similar level of performance.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2181708504/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2182205916",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2182205916",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2182205916,
    "node_id": "IC_kwDOAAsO6M6CEdHc",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-21T07:52:53Z",
    "updated_at": "2024-06-21T07:52:53Z",
    "body": "There's no intrinsic reason why `StableHasher` could not support different hash functions for different use cases. For incremental compilation fingerprinting we need something very fast, for anything else performance is not so much a concern. ",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2182205916/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2182214607",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2182214607",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2182214607,
    "node_id": "IC_kwDOAAsO6M6CEfPP",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-21T07:58:36Z",
    "updated_at": "2024-06-21T07:58:36Z",
    "body": "Incremental compilation hash collisions can also lead to unsoundness though, can't they?\n\nThough there at least users have a work-around -- build the final artifact for distribution without incremental.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2182214607/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2182226713",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2182226713",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2182226713,
    "node_id": "IC_kwDOAAsO6M6CEiMZ",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-21T08:05:37Z",
    "updated_at": "2024-06-21T08:05:37Z",
    "body": "Yes, incremental compilation is a best-effort developer-quality-of-life feature. No incrementally built code should ever be shipped.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2182226713/reactions",
      "total_count": 2,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 2,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2182296952",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2182296952",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2182296952,
    "node_id": "IC_kwDOAAsO6M6CEzV4",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-21T08:43:58Z",
    "updated_at": "2024-06-21T08:43:58Z",
    "body": "I've opened [an issue](https://github.com/rust-lang/rustc-stable-hash/issues/5) in the rustc-stable-hasher repo about supporting different hash algorithms. It's clear that SipHash13 is not a good choice for most use cases.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2182296952/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2182320819",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2182320819",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2182320819,
    "node_id": "IC_kwDOAAsO6M6CE5Kz",
    "user": {
      "login": "cr-marcstevens",
      "id": 20039241,
      "node_id": "MDQ6VXNlcjIwMDM5MjQx",
      "avatar_url": "https://avatars.githubusercontent.com/u/20039241?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cr-marcstevens",
      "html_url": "https://github.com/cr-marcstevens",
      "followers_url": "https://api.github.com/users/cr-marcstevens/followers",
      "following_url": "https://api.github.com/users/cr-marcstevens/following{/other_user}",
      "gists_url": "https://api.github.com/users/cr-marcstevens/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cr-marcstevens/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cr-marcstevens/subscriptions",
      "organizations_url": "https://api.github.com/users/cr-marcstevens/orgs",
      "repos_url": "https://api.github.com/users/cr-marcstevens/repos",
      "events_url": "https://api.github.com/users/cr-marcstevens/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cr-marcstevens/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-21T08:57:09Z",
    "updated_at": "2024-06-21T08:57:09Z",
    "body": "Just to confirm, the SipHash128 that rustc is using is identical to this code:\r\nhttps://github.com/veorq/SipHash/blob/master/siphash.c\r\nUsing 128-bit output (`outlen=16`), and instead using `#define cROUNDS 1` and `#define dROUNDS 3`?",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2182320819/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2182354306",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2182354306",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2182354306,
    "node_id": "IC_kwDOAAsO6M6CFBWC",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-21T09:15:05Z",
    "updated_at": "2024-06-21T09:15:05Z",
    "body": "I don't think there is any deliberate deviation from the reference impl, so probably yes. Here are the compiler's test vectors for the algorithm: https://github.com/rust-lang/rust/blob/4e6de37349c7838df095b085a2640cb6a007c96a/compiler/rustc_data_structures/src/sip128/tests.rs#L26-L124",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2182354306/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2183221431",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2183221431",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2183221431,
    "node_id": "IC_kwDOAAsO6M6CIVC3",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-06-21T18:16:02Z",
    "updated_at": "2024-06-21T18:16:02Z",
    "body": "> Yes, incremental compilation is a best-effort developer-quality-of-life feature. No incrementally built code should ever be shipped.\r\n\r\nIMO, developers shouldn't be put more at risk using incremental compilation than with a full rebuild. We should be aiming for trustworthy incremental builds.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2183221431/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2199286097",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2199286097",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2199286097,
    "node_id": "IC_kwDOAAsO6M6DFnFR",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-01T05:45:28Z",
    "updated_at": "2024-07-01T05:59:03Z",
    "body": "https://github.com/rust-lang/compiler-team/issues/765 proposes another use of hashing in the build process.\r\n\r\nEDIT: Ah, this was already [brought up](https://github.com/rust-lang/cargo/issues/6529#issuecomment-2181473376).",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2199286097/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2199293989",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2199293989",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2199293989,
    "node_id": "IC_kwDOAAsO6M6DFpAl",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-01T05:52:35Z",
    "updated_at": "2024-07-01T05:52:35Z",
    "body": "> Yes, incremental compilation is a best-effort developer-quality-of-life feature. No incrementally built code should ever be shipped.\r\n\r\nIf that is the position of the team, it seems like that should be communicated more clearly? I wasn't aware of this, and I think it is safe to assume that the vast majority of our users are not aware of this, either.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2199293989/reactions",
      "total_count": 10,
      "+1": 10,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2199565496",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2199565496",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2199565496,
    "node_id": "IC_kwDOAAsO6M6DGrS4",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-01T08:37:38Z",
    "updated_at": "2024-07-01T08:37:38Z",
    "body": "> If that is the position of the team, it seems like that should be communicated more clearly?\r\n\r\nYes, that's definitely something that should be done. It's not like incrementally compiled code is likely to be wrong (especially with an empty cache there should be no difference other than CGU partitioning). But even without hash collisions taken into account, doing things incrementally is intrinsically more difficult and much harder to test. The likelihood of additional compiler bugs is just greater. ",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2199565496/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2203418160",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2203418160",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2203418160,
    "node_id": "IC_kwDOAAsO6M6DVX4w",
    "user": {
      "login": "SimonSapin",
      "id": 291359,
      "node_id": "MDQ6VXNlcjI5MTM1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SimonSapin",
      "html_url": "https://github.com/SimonSapin",
      "followers_url": "https://api.github.com/users/SimonSapin/followers",
      "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}",
      "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions",
      "organizations_url": "https://api.github.com/users/SimonSapin/orgs",
      "repos_url": "https://api.github.com/users/SimonSapin/repos",
      "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SimonSapin/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-02T14:48:28Z",
    "updated_at": "2024-07-02T14:48:28Z",
    "body": "Anecdotally, the small number of ICEs I hit in recent years _all_ went away with `cargo clean` which suggests they were incremental compilation bugs. So I\u2019m aware it\u2019s somewhat buggy but \u201cNo incrementally built code should ever be shipped\u201d sounds much more dire.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2203418160/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2203780471",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2203780471",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2203780471,
    "node_id": "IC_kwDOAAsO6M6DWwV3",
    "user": {
      "login": "CAD97",
      "id": 5992217,
      "node_id": "MDQ6VXNlcjU5OTIyMTc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5992217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CAD97",
      "html_url": "https://github.com/CAD97",
      "followers_url": "https://api.github.com/users/CAD97/followers",
      "following_url": "https://api.github.com/users/CAD97/following{/other_user}",
      "gists_url": "https://api.github.com/users/CAD97/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/CAD97/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/CAD97/subscriptions",
      "organizations_url": "https://api.github.com/users/CAD97/orgs",
      "repos_url": "https://api.github.com/users/CAD97/repos",
      "events_url": "https://api.github.com/users/CAD97/events{/privacy}",
      "received_events_url": "https://api.github.com/users/CAD97/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-02T16:31:00Z",
    "updated_at": "2024-07-02T16:31:00Z",
    "body": "For further context, I recall seeing someone knowledgeable (sorry, don't recall who) say much the same \u2014 that incremental is likely to have an unknown number of issues, solely due to the massively expanded surface area. (IIRC, this was fairly close to when incremental was made default for the dev profile.) *However*, this is mitigated by the fact that they also expected that these issues would manifest as ICE rather than incorrect compilation. \n\nAnecdotally, my experience has also been that every issue I've hit since then (without unstable features) has been incremental ICEs, never a successful compilation generating incoherent behavior. Even when I've done UB that would justify two compilation modes having divergent behavior. Additionally, AIUI, the compiler has only gotten better at spotting any issues with incremental compilation over time.\n\nI'd actually concur that incrementally built code shouldn't be shipped, but not due to any risk of miscompilation, just because that's needlessly leaving performance on the table compared to a non-incremental optimized build. Not every piece of shipped software is distributed enough to justify full fat LTO and PGO, but a clean build is generally worth it. It was also my impression that this was the compiler team position, and the best-effort falls out of that, in the same way `cargo check` skipping potentially fallible mono work does.\n\nAn available-by-default \"`dist`\" profile that tunes optimization knobs more aggressively than just `release` and isn't compatible with incremental might be interesting, and a release of such a decent place to attach an announcement that incremental shouldn't be used for distribution builds, but I don't think it's in any way needed. However, deciding on an official policy for probabilistic correctness in the compiler and stdlib (potentially with an accompanying insiders blog post) does seem like a good idea.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2203780471/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2204261691",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2204261691",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2204261691,
    "node_id": "IC_kwDOAAsO6M6DYl07",
    "user": {
      "login": "saethlin",
      "id": 12105168,
      "node_id": "MDQ6VXNlcjEyMTA1MTY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/saethlin",
      "html_url": "https://github.com/saethlin",
      "followers_url": "https://api.github.com/users/saethlin/followers",
      "following_url": "https://api.github.com/users/saethlin/following{/other_user}",
      "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions",
      "organizations_url": "https://api.github.com/users/saethlin/orgs",
      "repos_url": "https://api.github.com/users/saethlin/repos",
      "events_url": "https://api.github.com/users/saethlin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/saethlin/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-02T19:50:54Z",
    "updated_at": "2024-07-02T19:50:54Z",
    "body": "I think it would be best to have this discussion elsewhere, this seems like a tangent. Maybe important, but still a tangent.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2204261691/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2205356058",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2205356058",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2205356058,
    "node_id": "IC_kwDOAAsO6M6DcxAa",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-03T08:02:57Z",
    "updated_at": "2024-07-03T08:02:57Z",
    "body": "Yes, sorry for derailing the discussion here. \"No incrementally built code should ever be shipped\" does make it sound too extreme. Let's put it this way: there is no upside to building code incrementally unless your rebuilds need to be quick. The initial build will be slower, code quality might be lower due to more object files being generated, the resulting binary will be larger, and there is a chance of running into incr. comp. only compiler bugs which otherwise are just not an issue. But: any incr. comp. miscompilation bug will certainly be treated as critical and we have only had one such bug (in 2021), as far as I know.\r\n\r\nI'll take an action item of adding information about incremental builds wrt release builds to the relevant docs for rustc and cargo.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2205356058/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2219641918",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2219641918",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2219641918,
    "node_id": "IC_kwDOAAsO6M6ETQw-",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-10T06:12:06Z",
    "updated_at": "2024-07-10T06:12:52Z",
    "body": "To get back to the request for some lang team input on `type_id` (ignoring other hashes for a moment) -- as I said above, the lang team is not going to read a 130-comment thread, so someone will have to write a summary of what was discussed here, why some people want a cryptographic hash, why others think it is not necessary, what possibilities and reasons exist to avoid relying on a hash altogether, what attacker models have been discussed, the estimated cost of constructing a collision with the current scheme, the estimated likelihood of that happening *accidentally* -- all that. Most of the points have been made, so I think we can say that the evidence gathering phase of this has concluded -- we can go in circles a few more times but that's not going to help anyone.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2219641918/reactions",
      "total_count": 3,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 3,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2242627868",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2242627868",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2242627868,
    "node_id": "IC_kwDOAAsO6M6Fq8kc",
    "user": {
      "login": "SichangHe",
      "id": 84777573,
      "node_id": "MDQ6VXNlcjg0Nzc3NTcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/84777573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SichangHe",
      "html_url": "https://github.com/SichangHe",
      "followers_url": "https://api.github.com/users/SichangHe/followers",
      "following_url": "https://api.github.com/users/SichangHe/following{/other_user}",
      "gists_url": "https://api.github.com/users/SichangHe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SichangHe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SichangHe/subscriptions",
      "organizations_url": "https://api.github.com/users/SichangHe/orgs",
      "repos_url": "https://api.github.com/users/SichangHe/repos",
      "events_url": "https://api.github.com/users/SichangHe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SichangHe/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T10:30:20Z",
    "updated_at": "2024-07-22T10:30:20Z",
    "body": "If I understand correctly, \"the team\" decided that https://github.com/rust-lang/rust/pull/109953 \"fixes\" the original Issue by enlarging `TypeId` to 128 bits (https://github.com/rust-lang/compiler-team/issues/608). Then, this Issue could be closed.\r\n\r\nThe new solution has the same problem as the old one, just with much less probability, but it is what it is\u2026\r\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2242627868/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2242717502",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2242717502",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2242717502,
    "node_id": "IC_kwDOAAsO6M6FrSc-",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T11:21:07Z",
    "updated_at": "2024-07-22T11:21:07Z",
    "body": "That's linking to a compiler team discussion. I don't know that the lang team would have made a decision here yet.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2242717502/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2242829094",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2242829094",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2242829094,
    "node_id": "IC_kwDOAAsO6M6Frtsm",
    "user": {
      "login": "SichangHe",
      "id": 84777573,
      "node_id": "MDQ6VXNlcjg0Nzc3NTcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/84777573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SichangHe",
      "html_url": "https://github.com/SichangHe",
      "followers_url": "https://api.github.com/users/SichangHe/followers",
      "following_url": "https://api.github.com/users/SichangHe/following{/other_user}",
      "gists_url": "https://api.github.com/users/SichangHe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SichangHe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SichangHe/subscriptions",
      "organizations_url": "https://api.github.com/users/SichangHe/orgs",
      "repos_url": "https://api.github.com/users/SichangHe/repos",
      "events_url": "https://api.github.com/users/SichangHe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SichangHe/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T12:23:54Z",
    "updated_at": "2024-07-22T12:23:54Z",
    "body": "Should these be considered \"a decision\"? https://github.com/rust-lang/rust/pull/95845#issuecomment-1169051679 https://github.com/rust-lang/rust/pull/95845#issuecomment-1175324596",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2242829094/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2242949586",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2242949586",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2242949586,
    "node_id": "IC_kwDOAAsO6M6FsLHS",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T13:21:55Z",
    "updated_at": "2024-07-22T13:21:55Z",
    "body": "Good point, the second one is indeed a decision:\r\n\r\n> I think the lang question here has been addressed: we're happy with a full (non-truncated) cryptographic hash. The compiler already has other things that depend on non-colliding hashes.\r\n\r\nIt has never been implemented, though.\r\n\r\nI guess I lost track a bit of what the various objections and positions in this thread are -- @briansmith would you be concerned about Rust using a \"full (non-truncated) cryptographic hash\" for type IDs, and relying on their collisions resistance for soundness? IOW, is the debate over the use of the hash function at all, or about the quality of the hash function?",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2242949586/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243114649",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243114649",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243114649,
    "node_id": "IC_kwDOAAsO6M6FszaZ",
    "user": {
      "login": "tarcieri",
      "id": 797,
      "node_id": "MDQ6VXNlcjc5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/797?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tarcieri",
      "html_url": "https://github.com/tarcieri",
      "followers_url": "https://api.github.com/users/tarcieri/followers",
      "following_url": "https://api.github.com/users/tarcieri/following{/other_user}",
      "gists_url": "https://api.github.com/users/tarcieri/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tarcieri/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tarcieri/subscriptions",
      "organizations_url": "https://api.github.com/users/tarcieri/orgs",
      "repos_url": "https://api.github.com/users/tarcieri/repos",
      "events_url": "https://api.github.com/users/tarcieri/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tarcieri/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T14:33:23Z",
    "updated_at": "2024-07-22T14:33:23Z",
    "body": "@RalfJung that sounds fine to me keeping in mind:\r\n\r\n1. [Per SipHash's creator, it is *NOT* a general-purpose unkeyed hash function but a PRF](https://github.com/rust-lang/rust/issues/10389#issuecomment-1887239511), and `StableHasher` should be using an unkeyed hash rather than a PRF with a key of all zeros\r\n2. The modern bar for the size of an unkeyed hash function's output is 256-bits",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243114649/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243179377",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243179377",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243179377,
    "node_id": "IC_kwDOAAsO6M6FtDNx",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T15:01:26Z",
    "updated_at": "2024-07-22T15:01:26Z",
    "body": "Yes, so that's a discussion about \"what is a *full (non-truncated) cryptographic hash*\", and arguing that SipHash, in particular in the way Rust is using it, is not.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243179377/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243241352",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243241352",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243241352,
    "node_id": "IC_kwDOAAsO6M6FtSWI",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T15:29:11Z",
    "updated_at": "2024-07-23T06:12:40Z",
    "body": "Given that this issue has had *way* too many comments, I think what I'd propose to do is open a new issue that summarizes the current state of the discussion. Here's a proposed issue description; please speak up if there's something that you think is not properly represented.\r\n\r\n# type_id is not sufficiently collision-resistant\r\n\r\nThe soundness of functions like [`downcast`](https://doc.rust-lang.org/nightly/std/boxed/struct.Box.html#method.downcast-2) relies on the type_id of two different types never being equal. Currently, the type_id is a 128-bit hash of the full type identity, computed specifically via SipHash-1-3 with an all-zero key. This is not a strong enough hash function for this purpose.\r\n\r\nThe lang team [decided](https://github.com/rust-lang/rust/pull/95845#issuecomment-1175324596) that relying on a full (non-truncated) cryptographic hash is fine -- we don't have to guarantee soundness against an infinite-resource attacker that can generate collisions in cryptographic hash functions.\r\nHowever, SipHash even in its default configuration (SipHash-2-4) is *not* a cryptographic hash, as clarified [by its author](https://github.com/rust-lang/rust/issues/10389#issuecomment-1887239511)[^siphash] -- it is a pseudo-random function (PRF); that means it assumes a secret key, but Rust hard-codes an all-zero key and in fact has no way to keep a key secret. By standards for cryptographic hash functions, SipHash-2-4 with an all-zero-key is [weaker than MD5](https://github.com/rust-lang/rust/issues/10389#issuecomment-2181169783), and generating a collision for that [is pretty easy](https://x.com/realhashbreaker/status/1770161965006008570) these days. SipHash-1-3 is even weaker, we should thus expect it to be a matter of hours to create a collision, if someone really tried.\r\n\r\n[^siphash]: In the [original paper](https://cr.yp.to/siphash/siphash-20120918.pdf), they even write: \"We comment that SipHash is not meant to be, and (obviously) is not, collision-resistant.\"\r\n\r\nGenerating a concrete example of an unsoundness from that is a bit more tricky since one would have to find a Rust type generating the collision, but it seems fairly clear that the bar of \"full (non-truncated) cryptographic hash\" is *not* met by the current type_id implementation. The point of this issue is to determine how the compiler implementation can best satisfy the soundness expectation set by the lang team.\r\n\r\nIf you instead want to argue that the lang team should change its mind, please open a new issue and gather arguments in favor of that position, so that a summary of all the arguments for either option can be brought to the lang team for discussion. Also, this issue is only about type_id; if you are concerned about soundness issues caused by other hash collisions, please file a separate issue.\r\n\r\n### Possible solutions\r\n\r\nWe should do one of the following:\r\n- switch to a stronger hash function, or\r\n- switch to a different scheme that doesn't rely on collision-resistance of the hash function.\r\n\r\nWorth noting is that a cryptographic hash function these days must output [at least 256 bits](https://github.com/rust-lang/rust/issues/10389#issuecomment-2243114649) to be considered worth its salt, so the first option would require further increasing the size of `TypeId` (or embedding a pointer to the actual hash, similar to one of the schemes involving a pointer to the mangled type name below). The lang team has not spelled out their exact definition of \"cryptographic hash function\", but the [standard definition](https://en.wikipedia.org/wiki/Cryptographic_hash_function) includes collision resistance, and in fact collisions are exactly what we are most worried about here, so it seems reasonable to assume that this is part of the lang team intent. A lang team member [mentioned](https://github.com/rust-lang/rust/pull/95845#issuecomment-1169054470) BLAKE3 as a candidate, further corroborating this claim. So we'd have to switch to BLAKE3 or SHA2 or something like that.\r\n\r\nFor the second option, ideas explored/suggested in the past include:\r\n- making the `TypeId` a [pointer to a string](https://github.com/rust-lang/rust/pull/95845) with the fully mangled type name. By comparing the pointers, we can quickly tell when two types are equal (even better if the linker deduplicated the string), but being sure that two `TypeId` are inequal would require comparing the full string.\r\n- making the `TypeId` a pointer to some block of data that is reliably made globally unique via linker magic -- then comparing the pointers is enough to be sure that they are fully equal. However, not all platforms support such schemes (notably, Windows does not).\r\n- a mixed hash-and-type-name scheme: a 128bit type ID with a 64bit hash and 64bit pointer (both half the size on 32bit targets), so that we can often quickly tell that two IDs are different (hashes differ) and that they are equal (name pointers are equal, deduplicated by linker), and only have to use the slow path when they are actually equal (or there is a hash collision) and the linker wasn't able to deduplicate the type name.\r\n\r\nWe don't have to use the same scheme on all targets, so e.g. targets with a more capable linker could benefit from a more efficient equality check. C++ has a similar problem to solve and, at least on Windows, [seems to](https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/Const.20.60TypeId.3A.3Aof.60.2C.20.60TypeId.3A.3Amatches.60.2C.20.60type_name.60/near/450558553) do something like the first of these options: compare pointers, and fall back to comparing strings.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243241352/reactions",
      "total_count": 2,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 2,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243312639",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243312639",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243312639,
    "node_id": "IC_kwDOAAsO6M6Ftjv_",
    "user": {
      "login": "SichangHe",
      "id": 84777573,
      "node_id": "MDQ6VXNlcjg0Nzc3NTcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/84777573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SichangHe",
      "html_url": "https://github.com/SichangHe",
      "followers_url": "https://api.github.com/users/SichangHe/followers",
      "following_url": "https://api.github.com/users/SichangHe/following{/other_user}",
      "gists_url": "https://api.github.com/users/SichangHe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SichangHe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SichangHe/subscriptions",
      "organizations_url": "https://api.github.com/users/SichangHe/orgs",
      "repos_url": "https://api.github.com/users/SichangHe/repos",
      "events_url": "https://api.github.com/users/SichangHe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SichangHe/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T16:03:27Z",
    "updated_at": "2024-07-22T16:03:27Z",
    "body": "<details><summary>Collision probability priori, assuming 10 million types.</summary>\r\n\r\nMy thoughtless implementation (Julia for the BigFloat).\r\n\r\n```julia\r\njulia> function p_collision(n_possibility, n_trial)\r\n           p = 1.0 # Probability the first element has a certain value\r\n           n_possibility_left = BigFloat(n_possibility)\r\n           for _ = 1:n_trial\r\n               n_possibility_left -= 1\r\n               p_different_than_any_of_prev = n_possibility_left / n_possibility\r\n               p *= p_different_than_any_of_prev\r\n           end\r\n           return 1 - p\r\n       end\r\n\r\njulia> p_collision(2.0^32, 1e7)\r\n1.0\r\n\r\njulia> p_collision(2.0^48, 1e7)\r\n0.1627526260300042013531821392328493925065046736329522793680035007601414108357426\r\n\r\njulia> p_collision(2.0^64, 1e7)\r\n2.710502028847531931027222578170711860859279849510102483631014233237841291033592e-06\r\n\r\njulia> p_collision(2.0^128, 1e7)\r\n1.469368085464653237746859059667760114567434131739739434969293181353407355803138e-25\r\n```\r\n\r\n</details>\r\n\r\nLooks like if the hash has 64 \"actual-uniform\" bits, it would only have a collision probability of 3e-6 in this case\u2014which is probably fine. SipHash is not providing that?\r\n\r\nPreviously, the hash was 64 bits in total, so it was probable that it only had fewer than 48 actual-uniform bits, perhaps explaining why people got \"lucky\" easily.\r\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243312639/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243331959",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243331959",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243331959,
    "node_id": "IC_kwDOAAsO6M6Ftod3",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T16:13:30Z",
    "updated_at": "2024-07-22T16:16:00Z",
    "body": "I have no idea what that Julia code does.^^ Is this some collision probability that is different from the birthday bound? Powers of two would be much easier to deal with here than powers of 10.\r\n\r\nFurther upthread there are arguments for why using a non-cryptographic hash should be considered sufficient. (I used to argue in favor of that, and I still think it is a position one can hold.) However, given the lang team verdict of using a cryptographic hash function, I think it is pretty clear that the current implementation falls short of the established decision.\r\n\r\nPeople could also try to assemble a document gathering arguments for why a weaker hash function ought to be sufficient, and bring that to the lang team for discussion. That would largely be a separate discussion from \"how can we ensure the implementation matches the existing decision\".\r\n\r\nI added this to the description for the new issue:\r\n\r\n> The point of this issue is to determine how the compiler implementation can best satisfy the soundness expectation set by the lang team. (If you instead want to argue that the lang team should change its mind, please open a new issue and gather arguments in favor of that position, so that a summary of why the decision should be changed can be brought to the lang team for discussion.)\r\n\r\nWhatever your Julia code does, I think it falls squarely in the category of \"ask the lang team to change its mind\". I won't be writing the summary for that.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243331959/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243375139",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243375139",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243375139,
    "node_id": "IC_kwDOAAsO6M6FtzAj",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T16:36:24Z",
    "updated_at": "2024-07-22T16:36:24Z",
    "body": "Is there a reason not to just use a cryptographic 256 bit hash for this case? ",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243375139/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243381972",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243381972",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243381972,
    "node_id": "IC_kwDOAAsO6M6Ft0rU",
    "user": {
      "login": "Skgland",
      "id": 3877590,
      "node_id": "MDQ6VXNlcjM4Nzc1OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3877590?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Skgland",
      "html_url": "https://github.com/Skgland",
      "followers_url": "https://api.github.com/users/Skgland/followers",
      "following_url": "https://api.github.com/users/Skgland/following{/other_user}",
      "gists_url": "https://api.github.com/users/Skgland/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Skgland/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Skgland/subscriptions",
      "organizations_url": "https://api.github.com/users/Skgland/orgs",
      "repos_url": "https://api.github.com/users/Skgland/repos",
      "events_url": "https://api.github.com/users/Skgland/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Skgland/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T16:39:56Z",
    "updated_at": "2024-07-22T16:39:56Z",
    "body": "> Is there a reason not to just use a cryptographic 256 bit hash for this case?\r\n\r\nThere was a concern about the size of TypeId in https://github.com/rust-lang/rust/pull/95845#issuecomment-1207332499 and then there was the response in https://github.com/rust-lang/rust/pull/95845#issuecomment-1207348101 ",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243381972/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243392637",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243392637",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243392637,
    "node_id": "IC_kwDOAAsO6M6Ft3R9",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T16:46:12Z",
    "updated_at": "2024-07-22T16:46:12Z",
    "body": "I'd expect `TypeId` to be a pointer to the hash, and the hash values being deduplicated (as much as possible) by the linker as described above. ",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243392637/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243404138",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243404138",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243404138,
    "node_id": "IC_kwDOAAsO6M6Ft6Fq",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T16:53:03Z",
    "updated_at": "2024-07-22T16:53:03Z",
    "body": "You'd probably want a scheme where a part of the hash is stored in-line, to avoid having to always read from the pointer. But yes that's one of a bunch of possibilities.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243404138/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243408773",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243408773",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243408773,
    "node_id": "IC_kwDOAAsO6M6Ft7OF",
    "user": {
      "login": "Skgland",
      "id": 3877590,
      "node_id": "MDQ6VXNlcjM4Nzc1OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3877590?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Skgland",
      "html_url": "https://github.com/Skgland",
      "followers_url": "https://api.github.com/users/Skgland/followers",
      "following_url": "https://api.github.com/users/Skgland/following{/other_user}",
      "gists_url": "https://api.github.com/users/Skgland/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Skgland/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Skgland/subscriptions",
      "organizations_url": "https://api.github.com/users/Skgland/orgs",
      "repos_url": "https://api.github.com/users/Skgland/repos",
      "events_url": "https://api.github.com/users/Skgland/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Skgland/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T16:55:52Z",
    "updated_at": "2024-07-22T16:56:48Z",
    "body": "For variant with TypeId being a `&'static str`, we have the fast-equality path of reference equality, wouldn't we also have a fast-inequality path when the strings are of unequal length?\r\nOne would only need a full string comparison when the pointers differ and the length is the same, as strings of unequal length can't be equal.\r\nThough that still leaves a concern over binary size when including the string for all type ids and non-deduped strings.\r\nCould/Would the type id only included for types for which the TypeId requested similar to how vTables aren't generated for all types x traits?\r\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243408773/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243412856",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243412856",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243412856,
    "node_id": "IC_kwDOAAsO6M6Ft8N4",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T16:58:13Z",
    "updated_at": "2024-07-22T16:58:13Z",
    "body": "It's my understanding that TypeIds are allocated lazily but I could be wrong.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243412856/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243438023",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243438023",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243438023,
    "node_id": "IC_kwDOAAsO6M6FuCXH",
    "user": {
      "login": "the8472",
      "id": 1065730,
      "node_id": "MDQ6VXNlcjEwNjU3MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/the8472",
      "html_url": "https://github.com/the8472",
      "followers_url": "https://api.github.com/users/the8472/followers",
      "following_url": "https://api.github.com/users/the8472/following{/other_user}",
      "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/the8472/subscriptions",
      "organizations_url": "https://api.github.com/users/the8472/orgs",
      "repos_url": "https://api.github.com/users/the8472/repos",
      "events_url": "https://api.github.com/users/the8472/events{/privacy}",
      "received_events_url": "https://api.github.com/users/the8472/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T17:13:01Z",
    "updated_at": "2024-07-22T17:14:16Z",
    "body": "> The lang team https://github.com/rust-lang/rust/pull/95845#issuecomment-1175324596 that relying on a full (non-truncated) cryptographic hash is fine -- we don't have to guarantee soundness against an infinite-resource attacker that can generate collisions in cryptographic hash functions.\r\n\r\nFrom the linked comment it's not clear whether that was a necessary or sufficient condition. So weaker functions might not have been rejected.\r\n\r\nAlso, my understanding is that siphash claims to be suitable for cryptographic use when the key is secret. In other words it is a cryptographic hash under the assumption that any process generating collisions is oblivious to the key. Which depending on the threat model could be interpreted as \"it's behaves as a cryptographic hash, for our threat model\".\r\n\r\nSo, as I have argued previously, it would be great if we could get a statement what the threat model is, not just on a particular solution.\r\n\r\nAdditional aspects that should be considered:\r\n\r\n* security-compile time tradeoff - blake2s was tried, and it [has a huge overhead](https://github.com/rust-lang/rust/pull/127809#issuecomment-2233743267)\r\n   Do we need tunable security levels?\r\n* security-binary size tradeoff - embedding the type name for every TypeID'd type would bloat the data section.\r\n* would the decision be consistent with the security promises the rest of the compiler can give.\r\n   I.e. if collisons were not acceptable and the type-name approach gets chosen, then do we also need to get of `StableHasher` since that also relies on collisions being negligible?",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243438023/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243438171",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243438171",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243438171,
    "node_id": "IC_kwDOAAsO6M6FuCZb",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T17:13:06Z",
    "updated_at": "2024-07-22T17:13:06Z",
    "body": "> For variant with TypeId being a\u00a0&'static str, we have the fast-equality path of reference equality, wouldn't we also have a fast-inequality path when the strings are of unequal length?\r\n\r\nSure, if we include the length in-line. I didn't say it was an &str though, it could use a null terminated string and a hash instead of the length to make it more likely that we detect inequality.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243438171/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243484655",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243484655",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243484655,
    "node_id": "IC_kwDOAAsO6M6FuNvv",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T17:41:21Z",
    "updated_at": "2024-07-23T05:59:53Z",
    "body": "> From the linked comment it's not clear whether that was a necessary or sufficient condition. So weaker functions might not have been rejected.\r\n\r\nIt is obviously not necessary to use a hash function at all, since one could do a perfect comparison based on type_name. So I think \"this is the lower bound for the guarantees provided\" is the only reasonable interpretation. (The alternative is to believe that the lang team intended to *rule out* anything that provides stronger guarantees than a cryptographic hash function, which does not seem reasonable.)\r\n\r\nThe context there was considering various weaker options like a truncated hash function, which were rejected by that decision.\r\n\r\n> Also, my understanding is that siphash claims to be suitable for cryptographic use when the key is secret. In other words it is a cryptographic hash under the assumption that any process generating collisions is oblivious to the key.\r\n\r\nI have not seen such a notion of \"cryptographic hash function under assumptions about the process generating the inputs\" before; is there literature defining and analyzing this idea in more detail?\r\n\r\n> Additional aspects that should be considered:\r\n\r\nThose seem like a good starting point for assembling a summary for a lang team design meeting asking whether they want to revise their previous decision.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243484655/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243516961",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243516961",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243516961,
    "node_id": "IC_kwDOAAsO6M6FuVoh",
    "user": {
      "login": "the8472",
      "id": 1065730,
      "node_id": "MDQ6VXNlcjEwNjU3MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/the8472",
      "html_url": "https://github.com/the8472",
      "followers_url": "https://api.github.com/users/the8472/followers",
      "following_url": "https://api.github.com/users/the8472/following{/other_user}",
      "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/the8472/subscriptions",
      "organizations_url": "https://api.github.com/users/the8472/orgs",
      "repos_url": "https://api.github.com/users/the8472/repos",
      "events_url": "https://api.github.com/users/the8472/events{/privacy}",
      "received_events_url": "https://api.github.com/users/the8472/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T18:00:51Z",
    "updated_at": "2024-07-22T18:01:18Z",
    "body": "> I have not seen such a notion of \"cryptographic hash function under assumptions about the process generating the inputs\" before\r\n\r\nI believe I am simply restating what a keyed PRF is when viewed from a different angle.\r\n\r\nIf it's collision-resistant when the key is not known to the attacker (e.g. like chosen plaintext attacks against a remote hasher) then that's no different from the process generating the inputs being oblivious to the key.\r\n\r\nWhich is another way of saying that it has cryptographic strength if your threat model only includes natural threats (people generting lots of rust code). Which, yes, is a fairly weak threat model.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243516961/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243604286",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243604286",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243604286,
    "node_id": "IC_kwDOAAsO6M6Fuq8-",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T18:49:21Z",
    "updated_at": "2024-07-22T18:49:21Z",
    "body": "Has there been any analysis how good of a PRF SipHash-1-3 is?",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243604286/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243667340",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2243667340",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2243667340,
    "node_id": "IC_kwDOAAsO6M6Fu6WM",
    "user": {
      "login": "the8472",
      "id": 1065730,
      "node_id": "MDQ6VXNlcjEwNjU3MzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/the8472",
      "html_url": "https://github.com/the8472",
      "followers_url": "https://api.github.com/users/the8472/followers",
      "following_url": "https://api.github.com/users/the8472/following{/other_user}",
      "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/the8472/subscriptions",
      "organizations_url": "https://api.github.com/users/the8472/orgs",
      "repos_url": "https://api.github.com/users/the8472/repos",
      "events_url": "https://api.github.com/users/the8472/events{/privacy}",
      "received_events_url": "https://api.github.com/users/the8472/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-22T19:29:39Z",
    "updated_at": "2024-07-22T19:29:39Z",
    "body": "https://eprint.iacr.org/2019/865.pdf is from 2019 that gives an overview. For the 1-x variants they cite internal collisions that have been found in https://eprint.iacr.org/2014/722.pdf (also cited in https://github.com/rust-lang/rust/issues/29754#issuecomment-156073946), which says\r\n\r\n> At first, we start with characteristics, which\r\nlead to internal collisions. This type of characteristic can be used to create forg-\r\neries as described in [9, 10]. To improve this attack, characteristics are needed,\r\nwhich have a probability higher than 2<sup>\u2212128</sup> (in the case of SipHash). Other-\r\nwise, a birthday attack should be preferred to find collisions. We are able to\r\npresent characteristics that lead to an internal collision for SipHash-1-x (2<sup>\u2212167</sup>)\r\nand SipHash-2-x (2<sup>\u2212236.3</sup>). \r\n\r\nSo AIUI even for those reduced-round versions they haven't found attacks that would be better than the birthday bound.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2243667340/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2244106896",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2244106896",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2244106896,
    "node_id": "IC_kwDOAAsO6M6FwlqQ",
    "user": {
      "login": "SichangHe",
      "id": 84777573,
      "node_id": "MDQ6VXNlcjg0Nzc3NTcz",
      "avatar_url": "https://avatars.githubusercontent.com/u/84777573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SichangHe",
      "html_url": "https://github.com/SichangHe",
      "followers_url": "https://api.github.com/users/SichangHe/followers",
      "following_url": "https://api.github.com/users/SichangHe/following{/other_user}",
      "gists_url": "https://api.github.com/users/SichangHe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SichangHe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SichangHe/subscriptions",
      "organizations_url": "https://api.github.com/users/SichangHe/orgs",
      "repos_url": "https://api.github.com/users/SichangHe/repos",
      "events_url": "https://api.github.com/users/SichangHe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SichangHe/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-23T01:58:43Z",
    "updated_at": "2024-07-23T01:58:43Z",
    "body": "My dumb take: the current implementation is fine\u2014collision probability is low in theory, and there are no reports of one.\r\n\r\nThe take that would satisfy lang team and probably most people: just use SHA256\u2026",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2244106896/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2244325079",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2244325079",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2244325079,
    "node_id": "IC_kwDOAAsO6M6Fxa7X",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-23T06:06:53Z",
    "updated_at": "2024-07-23T06:13:24Z",
    "body": "> security-compile time tradeoff - blake2s was tried, and it has a huge overhead\r\n\r\nNote that here we're talking just about TypeId, and making incremental compilation more secure against collisions is another, separate question. The perf impact of changing the hash for TypeId only should be negligible.\r\n\r\nIf someone could assemble a summary of the wider use of hashes in Rust where collisions could have soundness impact. that would be a great basis for future discussion. Otherwise we'll just keep going in circles. From statements made above, my current understanding is that for non-incremental builds, type_id is the only \"soundness-critical\" hash.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2244325079/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2245924622",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2245924622",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2245924622,
    "node_id": "IC_kwDOAAsO6M6F3hcO",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-23T18:09:33Z",
    "updated_at": "2024-07-23T18:09:49Z",
    "body": "> @briansmith would you be concerned about Rust using a \"full (non-truncated) cryptographic hash\" for type IDs, and relying on their collisions resistance for soundness? IOW, is the debate over the use of the hash function at all, or about the quality of the hash function?\r\n\r\nI think there are these three main issues, and some additional minor ones:\r\n1. To the extent we want Rust to have a formal semantics, and for the compiler and/or Rust code it compiles to have well-defined and/or formally-verifiable meaning, any use of a hash function has the negative consequence of introducing cryptography and probabilistic arguments into the formal semantics of the Rust language, i.e. we want to avoid having a conclusion being \"Rust is a memory-safe language iff SHA-256 is a secure hash function, where 'secure' means...\" One way to address this problem even if the compiler uses hashing is to specify the semantics without reference to any hashing (e.g. specify that TypeId is unique, without specifying how it is calculated), and then move the use of hashing to an implementation detail; \"rustc 1.94 is a valid Rust compiler assuming SHA-256 is a secure hash function, where 'secure' means...\".\r\n2. We know that regardless of algorithm, a 128-bit hash (truncated from a larger one, or otherwise) cannot be collision-resistant in the face of somebody actively trying to create a collision, and this is especially true for SipHash128 with a fixed key, which isn't even close to the level of MD5 in terms of collision resistance. From the cryptanalysis perspective, this fact is so obvious that it's uninteresting academically but also requires non-trivial effort, basically like proving water is wet. So, you may never get a PoC even though I think quite a few people are confident that collisions can be generated with current public knowledge (and IMO without even much expertise, i.e. I think even I could do it, though it would take way too much time for me). I absolutely do think that switching to a hash function that is considered secure addresses this concern.\r\n3. This in turn lead to the discussion about whether we should distinguish between intentional attacks and accidental collisions, because then we could say that intentional attacks are outside the threat model as the rust compiler doesn't defend against intentionally malicious code. I think this requires a more nuanced definition of the Rust compiler's role in the security of the Rust ecosystem, a shared understanding that we don't live in a binary world where code is either clearly fully trusted or fully untrusted. The most likely \"attack\" that we'd actually see publicly is somebody pulling a prank in submitting a PR to an extremely-widely-used crate that causes it to be affected by this issue, or to affect another totally unrelated widely-used crate such that when they are used together they are affected by this issue. If they devise their prank in a way where the collision happens in types that are part of the public API(s) of the affected crate(s) then those crates would potentially require SemVer-incompatible API changes to address it. If/when it happens it would be highly disruptive at virtually no cost (just free time, which pranksters generally seem to have much of) to the \"attacker.\" For this reason, though the compiler can \"declare\" that this is outside its threat model, at the end of the day it will need to be addressed by the compiler, AFAICT. [michael-scott-i-declare-bankruptcy.jpg]\r\n4. One issue we will run into if you do decide to use a \"secure\" hash algorithm is getting people to agree on a hash function to use. This is a hugely political issue and I'd rather not kick the hornet's nest here. I would say that even if you chose my least preferred 256-bit hash function that is in wide use, I wouldn't argue against it. My one suggestion is to specify and implement things in such a way that you could replace the hash algorithm in a subsequent rustc and/or libstd release in a way that only requires all the code to be recompiled with the newer compiler. \r\n5. Keep in mind that a hash function is a lossy compression algorithm. The lossiness is the source of the concerns. Another avenue to explore is a variable-length lossless compression algorithm that maps type names to type IDs, where in the (vastly) common case we are comparing less than 256-bits when comparing compressed type names. For example, you could imagine having TypeId being a 64-bit hash, where you compare the hashes and then if they match, you compare the (compressed) type names. I do think it makes sense to explore this as it has the potential to completely avoid the other issues.\r\n6. Right now the same algorithm is used for internal hashing within the compiler and for TypeId, IIUC. I think some of the concerns regarding performance are based on the assumption that the compiler internals and TypeId comparison will always be \"the same\" but I don't think this has to be the case necessarily. My hunch, which might be wrong, is that the performance of the compiler internals matters a lot, but the performance of TypeId comparison matters much less.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2245924622/reactions",
      "total_count": 7,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 4,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2245998853",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2245998853",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2245998853,
    "node_id": "IC_kwDOAAsO6M6F3zkF",
    "user": {
      "login": "bjorn3",
      "id": 17426603,
      "node_id": "MDQ6VXNlcjE3NDI2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bjorn3",
      "html_url": "https://github.com/bjorn3",
      "followers_url": "https://api.github.com/users/bjorn3/followers",
      "following_url": "https://api.github.com/users/bjorn3/following{/other_user}",
      "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions",
      "organizations_url": "https://api.github.com/users/bjorn3/orgs",
      "repos_url": "https://api.github.com/users/bjorn3/repos",
      "events_url": "https://api.github.com/users/bjorn3/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bjorn3/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-23T18:49:53Z",
    "updated_at": "2024-07-23T18:49:53Z",
    "body": "> If they devise their prank in a way where the collision happens in types that are part of the public API(s) of the affected crate(s) then those crates would potentially require SemVer-incompatible API changes to address it.\r\n\r\nDoing an empty patch release and yanking the old version should be enough to stop the collision. The crate version is hashed into the value cargo passes to `-Cmetadata`, which in turn affects the `TypeId` hashes.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2245998853/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2247673160",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2247673160",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2247673160,
    "node_id": "IC_kwDOAAsO6M6F-MVI",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-24T11:30:32Z",
    "updated_at": "2024-07-24T11:30:32Z",
    "body": "> Another avenue to explore is a variable-length lossless compression algorithm that maps type names to type IDs\r\n\r\nv0 symbol mangling losslessly encodes types and has some compression built into it already. https://github.com/rust-lang/rust/pull/95845 had a working implementation of this, afaict.\r\n\r\n> My hunch, which might be wrong, is that the performance of the compiler internals matters a lot, but the performance of TypeId comparison matters much less.\r\n\r\nThis is my intuition too: I don't think performance is a real concern for the TypeId case. Binary size might be more of a concern.\r\n\r\nCould also be made configurable via a `-Ctype-id-impl` compiler flag, with values like `full`, `encrypted`, `hash128`, `hash256`?\r\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2247673160/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2250526366",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2250526366",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2250526366,
    "node_id": "IC_kwDOAAsO6M6GJE6e",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-25T14:46:47Z",
    "updated_at": "2024-07-25T14:46:47Z",
    "body": "> Given that this issue has had _way_ too many comments, I think what I'd propose to do is open a new issue that summarizes the current state of the discussion. Here's a proposed issue description; please speak up if there's something that you think is not properly represented.\r\n\r\nStrong \ud83d\udc4d for this -- I found the issue summary very helpful. I'd like to encourage others to avoid directly commenting and instead limit yourselves (for the moment) to comment on what is not represented in this summary (ideally with a suggested edit), so that we can close this issue and restart afresh from a better starting point.",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2250526366/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2250692018",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2250692018",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2250692018,
    "node_id": "IC_kwDOAAsO6M6GJtWy",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-07-25T15:30:58Z",
    "updated_at": "2024-07-25T15:34:00Z",
    "body": "From the comments so far since my summary, there's multiple discussions that should likely go into separate issues:\r\n1. How can we make TypeId use a strong hash (or not depend on a hash at all) -- what's the best practical way to achieve that? That's the issue for which I wrote a summary above.\r\n2. Should we really require a cryptographic hash function, or is it enough to be resistant against code that wasn't deliberately written to attack the hash? @the8472 has been suggesting a model along the lines of: yes, we have a fixed key hard-coded in the compiler, but if we assume code isn't written to attack the hash, then we can assume code is written without making use of this knowledge of the key, and therefore for this weak threat model we can act as-if the key is actually random. @briansmith has been arguing that this is not strong enough. I won't be doing the summary for this one, I hope someone else can.\r\n    One question I find interesting here is whether we can make any such collision \"unstable\" in the sense of making it not work across compiler versions, e.g. by putting the compiler version into the initial state of the hasher (or into the key, or so). I have no idea what the hardness would be of finding a collision that works for multiple different keys / prefixes, but if that *is* genuinely hard for a PRF, then this seems somewhat more secure than the status quo.\r\n\r\nI think we're fairly sure that (1) can be done without significant perf impact, given that TypeId hashing is not a super common operation, and there are various proposals for how to make most TypeId comparisons fast. Binary size impact has yet to be determined, this requires someone to actually implement a prototype. (There's an old PR at https://github.com/rust-lang/rust/pull/95845 for one of the variants that doesn't rely on a hash at all, which is the least size-efficient option. As far as I can see, perf looked completely fine, though there were some complaints about having type names in the final binary. But there's also people that want a TypeId -> TypeName function. But anyway this is all t-compiler territory.)\r\n\r\nHowever, the compiler uses hashes in many places, so one question that is still unclear to me is whether just making TypeId use a stronger hash would actually fix anything, or whether it just shifts the problem to a different hash. It would be good to get input from people familiar with how our query system works on whether, for *non-incremental* builds, collisions in the stable hasher can lead to problems. Because if the answer is \"yes\", then (1) on its own seems a bit pointless, and we should evaluate the cost of making all the critical hashes more secure to really get the proper data for discussion (2). If the answer is \"no\", then I honestly see no good reason to not do (1); it seems like we can get protection against a stronger threat model without significant cost. At this point (2) would be about the threat model for incremental builds. The lang team has not decided on this, and existing data indicates that using a stronger hash here has a massive performance cost, but I don't know what possibilities exist to reduce that cost.\r\n\r\nSo -- @michaelwoerister and anyone else who knows the query system, can you help us answer this question? :)\r\n@michaelwoerister you wrote in https://github.com/rust-lang/rust/pull/127809\r\n> To elaborate on that: there might cases like that but at least for DepNode, DefPathHash, StableCrateId, legacy-symbol-name hashes, and incr. comp. query result hashing we need there to be no collisions. For the first three of these we check for collisions and have never found one.\r\n\r\nbut it's not clear to me whether this applies to all builds or just incremental builds.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2250692018/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2282342593",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2282342593",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2282342593,
    "node_id": "IC_kwDOAAsO6M6ICcjB",
    "user": {
      "login": "Pr0methean",
      "id": 4961925,
      "node_id": "MDQ6VXNlcjQ5NjE5MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4961925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Pr0methean",
      "html_url": "https://github.com/Pr0methean",
      "followers_url": "https://api.github.com/users/Pr0methean/followers",
      "following_url": "https://api.github.com/users/Pr0methean/following{/other_user}",
      "gists_url": "https://api.github.com/users/Pr0methean/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Pr0methean/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Pr0methean/subscriptions",
      "organizations_url": "https://api.github.com/users/Pr0methean/orgs",
      "repos_url": "https://api.github.com/users/Pr0methean/repos",
      "events_url": "https://api.github.com/users/Pr0methean/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Pr0methean/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-08-11T01:32:31Z",
    "updated_at": "2024-08-11T01:33:41Z",
    "body": "Is a linkage capable of bringing in more types than it has bytes of machine code, or (if dynamic) types that will survive when it's unloaded? If not, we can use sequential IDs starting with the linkage address.",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2282342593/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2284095948",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2284095948",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2284095948,
    "node_id": "IC_kwDOAAsO6M6IJInM",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-08-12T14:10:42Z",
    "updated_at": "2024-08-12T14:10:42Z",
    "body": "> 1. How can we make TypeId use a strong hash (or not depend on a hash at all) -- what's the best practical way to achieve that? That's the issue for which I wrote a summary above.\r\n\r\nPersonally, I think eddyb chose a good approach in https://github.com/rust-lang/rust/pull/95845 by reusing the symbol mangling scheme, as that has the same requirements of strong collision freedom. If we decide to use a strong, wide hash then I would still go \r\n```\r\ntype ==(v0_mangle)==> type-as-string ==(hash)==> type-id\r\n```\r\nThat way the implementation does not need to rely on `StableHasher` and, more importantly, `HashStable` implementations. Making `HashStable` impls generic over the hash algorithm would lead to binary bloat and some `HashStable` impls do some non-trivial internal caching which makes it harder to reason about their correctness. In contrast, if we just have to hash a symbol name, we can, for example, simply use the sha256 implementation we already have in the compiler for MSVC debuginfo. \r\n\r\n> > To elaborate on that: there might cases like that but at least for DepNode, DefPathHash, StableCrateId, legacy-symbol-name hashes, and incr. comp. query result hashing we need there to be no collisions. For the first three of these we check for collisions and have never found one.\r\n> \r\n> but it's not clear to me whether this applies to all builds or just incremental builds.\r\n\r\n- We unconditionally check for collisions of `DefPathHash`es for every kind of build and every kind of compiler version (e.g. no compiler built with debug assertions is needed):\r\n  https://github.com/rust-lang/rust/blob/e08b80c0fb7667bdcd040761891701e576c42ec8/compiler/rustc_hir/src/definitions.rs#L58-L76\r\n- We also unconditionally check for collisions of `StableCrateId` for all crates the compiler sees at once:\r\n  https://github.com/rust-lang/rust/blob/e08b80c0fb7667bdcd040761891701e576c42ec8/compiler/rustc_metadata/src/creader.rs#L177-L181\r\n- `DepNode` values are only created during incremental builds. \r\n\r\n> However, the compiler uses hashes in many places, so one question that is still unclear to me is whether just making TypeId use a stronger hash would actually fix anything, or whether it just shifts the problem to a different hash.\r\n\r\nAs said above, going through v0 mangling would basically fix this issue. The only hash that occurs in v0 is the `StableCrateId`. Any problem with collisions in that scheme would also be a problem with symbol names, so it is unlikely to go undetected. \r\n\r\n> One question I find interesting here is whether we can make any such collision \"unstable\" in the sense of making it not work across compiler versions, e.g. by putting the compiler version into the initial state of the hasher (or into the key, or so).\r\n\r\nWe already *mostly* do that by [mixing the compiler version](https://github.com/rust-lang/rust/blob/e08b80c0fb7667bdcd040761891701e576c42ec8/compiler/rustc_span/src/def_id.rs#L180-L190) into `StableCrateId`. So types containing any kind of path already have a compiler-version-dependent stable hash. Also initializing the hashers with the compiler version seems like a good thing to do and should have a negligible performance impact.\r\n\r\n> (2) would be about the threat model for incremental builds.\r\n\r\nUnless I'm overlooking something all incr. comp. specific hashes only need to be stable between successive incremental builds. So we can easily harden our use of SipHash there by generating random keys and then caching these in the incr. comp. cache.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2284095948/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2284562874",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2284562874",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2284562874,
    "node_id": "IC_kwDOAAsO6M6IK6m6",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-08-12T17:31:04Z",
    "updated_at": "2024-08-12T17:31:04Z",
    "body": "Great, thanks @michaelwoerister!\r\nI have opened https://github.com/rust-lang/rust/issues/129014 for changing type_id to be at least as good as a cryptographic hash function, aligning them with the t-lang decision.\r\n\r\nI have opened https://github.com/rust-lang/rust/issues/129016 for the questions around incremental compilation. If I missed an aspect if this, please bring it up in that issue.\r\n\r\nFor the people arguing that for type_id, we should consider a PRF (or even a weakened one like SipHash-1-3) to be good enough since we don't expect Rust programmers to try to exploit the compiler, I would suggest you file a new issue with the arguments for that and nominate it for t-lang discussion. Personally, since it seems like https://github.com/rust-lang/rust/issues/129014 can be fixed without major downsides, I don't see a good case for weakening the requirement here.\r\n\r\n> initializing the hashers with the compiler version seems like a good thing to do and should have a negligible performance impact.\r\n\r\n@michaelwoerister would it make sense to file this as a possible-improvement issue? Maybe it'd be better if you did this since you could point at where in the compiler that would even happen.\r\n\r\nI will then close this issue, as further discussion should happen in the existing or to-be-created successor issues. Thanks all for the discussion!",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2284562874/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2284580438",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2284580438",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2284580438,
    "node_id": "IC_kwDOAAsO6M6IK-5W",
    "user": {
      "login": "michaelwoerister",
      "id": 1825894,
      "node_id": "MDQ6VXNlcjE4MjU4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelwoerister",
      "html_url": "https://github.com/michaelwoerister",
      "followers_url": "https://api.github.com/users/michaelwoerister/followers",
      "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelwoerister/orgs",
      "repos_url": "https://api.github.com/users/michaelwoerister/repos",
      "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelwoerister/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-08-12T17:41:05Z",
    "updated_at": "2024-08-12T17:41:05Z",
    "body": "> @michaelwoerister would it make sense to file this as a possible-improvement issue? Maybe it'd be better if you did this since you could point at where in the compiler that would even happen.\r\n\r\nI'll look into opening an issue.",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2284580438/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2285918691",
    "html_url": "https://github.com/rust-lang/rust/issues/10389#issuecomment-2285918691",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10389",
    "id": 2285918691,
    "node_id": "IC_kwDOAAsO6M6IQFnj",
    "user": {
      "login": "RalfJung",
      "id": 330628,
      "node_id": "MDQ6VXNlcjMzMDYyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RalfJung",
      "html_url": "https://github.com/RalfJung",
      "followers_url": "https://api.github.com/users/RalfJung/followers",
      "following_url": "https://api.github.com/users/RalfJung/following{/other_user}",
      "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions",
      "organizations_url": "https://api.github.com/users/RalfJung/orgs",
      "repos_url": "https://api.github.com/users/RalfJung/repos",
      "events_url": "https://api.github.com/users/RalfJung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RalfJung/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2024-08-13T10:31:35Z",
    "updated_at": "2024-08-13T11:36:44Z",
    "body": "I opened https://github.com/rust-lang/unsafe-code-guidelines/issues/525 for potential hashing concerns related to `dlopen` (where the uniqueness checks @michaelwoerister mentioned can't be run).",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/2285918691/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
