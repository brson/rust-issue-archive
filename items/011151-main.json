{
  "url": "https://api.github.com/repos/rust-lang/rust/issues/11151",
  "repository_url": "https://api.github.com/repos/rust-lang/rust",
  "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/11151/labels{/name}",
  "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/11151/comments",
  "events_url": "https://api.github.com/repos/rust-lang/rust/issues/11151/events",
  "html_url": "https://github.com/rust-lang/rust/pull/11151",
  "id": 24792670,
  "node_id": "MDExOlB1bGxSZXF1ZXN0MTEwOTg0MTk=",
  "number": 11151,
  "title": "RFC: Externally loadable syntax extensions",
  "user": {
    "login": "sfackler",
    "id": 1455697,
    "node_id": "MDQ6VXNlcjE0NTU2OTc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/sfackler",
    "html_url": "https://github.com/sfackler",
    "followers_url": "https://api.github.com/users/sfackler/followers",
    "following_url": "https://api.github.com/users/sfackler/following{/other_user}",
    "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions",
    "organizations_url": "https://api.github.com/users/sfackler/orgs",
    "repos_url": "https://api.github.com/users/sfackler/repos",
    "events_url": "https://api.github.com/users/sfackler/events{/privacy}",
    "received_events_url": "https://api.github.com/users/sfackler/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 24,
  "created_at": "2013-12-26T16:32:09Z",
  "updated_at": "2014-06-12T15:03:24Z",
  "closed_at": "2014-01-17T01:51:46Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/rust-lang/rust/pulls/11151",
    "html_url": "https://github.com/rust-lang/rust/pull/11151",
    "diff_url": "https://github.com/rust-lang/rust/pull/11151.diff",
    "patch_url": "https://github.com/rust-lang/rust/pull/11151.patch",
    "merged_at": "2014-01-17T01:51:46Z"
  },
  "body": "# Example\n\nHere's a silly example showing off the basics:\n\nmy_synext.rs\n\n``` rust\n#[feature(managed_boxes, globs, macro_registrar, macro_rules)];\n\nextern mod syntax;\n\nuse syntax::ast::{Name, token_tree};\nuse syntax::codemap::Span;\nuse syntax::ext::base::*;\nuse syntax::parse::token;\n\n#[macro_export]\nmacro_rules! exported_macro (() => (2))\n\n#[macro_registrar]\npub fn macro_registrar(register: |Name, SyntaxExtension|) {\n    register(token::intern(&\"make_a_1\"),\n        NormalTT(@SyntaxExpanderTT {\n            expander: SyntaxExpanderTTExpanderWithoutContext(expand_make_a_1),\n            span: None,\n        } as @SyntaxExpanderTTTrait,\n        None));\n}\n\npub fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[token_tree]) -> MacResult {\n    if !tts.is_empty() {\n        cx.span_fatal(sp, \"make_a_1 takes no arguments\");\n    }\n    MRExpr(quote_expr!(cx, 1i))\n}\n```\n\nmain.rs:\n\n``` rust\n#[feature(phase)];\n\n#[phase(syntax)]\nextern mod my_synext;\n\nfn main() {\n    assert_eq!(1, make_a_1!());\n    assert_eq!(2, exported_macro!());\n}\n```\n# Overview\n\nCrates that contain syntax extensions need to define a function with the following signature and annotation:\n\n``` rust\n#[macro_registrar]\npub fn registrar(register: |ast::Name, ext::base::SyntaxExtension|) { ... }\n```\n\nthat should call the `register` closure with each extension it defines. `macro_rules!` style macros can be tagged with `#[macro_export]` to be exported from the crate as well.\n\nCrates that wish to use externally loadable syntax extensions load them by adding the `#[phase(syntax)]` attribute to an `extern mod`. All extensions registered by the specified crate are loaded with the same scoping rules as `macro_rules!` macros. If you want to use a crate both for syntax extensions and normal linkage, you can use `#[phase(syntax, link)]`.\n# Open questions\n- ~~Does the `macro_crate` syntax make sense? It wraps an entire `extern mod` declaration which looks a bit weird but is nice in the sense that the crate lookup logic can be identical between normal external crates and external macro crates. If the `extern mod` syntax, changes, this will get it for free, etc.~~ Changed to a `phase` attribute.\n- ~~Is the magic name `macro_crate_registration` the right way to handle extension registration? It could alternatively be handled by a function annotated with `#[macro_registration]` I guess.~~ Switched to an attribute.\n- The crate loading logic lives inside of librustc, which means that the syntax extension infrastructure can't directly access it. I've worked around this by passing a `CrateLoader` trait object from the driver to libsyntax that can call back into the crate loading logic. It should be possible to pull things apart enough that this isn't necessary anymore, but it will be an enormous refactoring project. I think we'll need to create a couple of new libraries: libsynext libmetadata/ty and libmiddle.\n- Item decorator extensions can be loaded but the `deriving` decorator itself can't be extended so you'd need to do e.g. `#[deriving_MyTrait] #[deriving(Clone)]` instead of `#[deriving(MyTrait, Clone)]`. Is this something worth bothering with for now?\n# Remaining work\n- [x] ~~There is not yet support for rustdoc downloading and compiling referenced macro crates as it does for other referenced crates. This shouldn't be too hard I think.~~\n- [x] ~~This is not testable at stage1 and sketchily testable at stages above that. The stage _n_ rustc links against the stage _n-1_ libsyntax and librustc. Unfortunately, crates in the test/auxiliary directory link against the stage _n_ libstd, libextra, libsyntax, etc. This causes macro crates to fail to properly dynamically link into rustc since names end up being mangled slightly differently. In addition, when rustc is actually installed onto a system, there are actually do copies of libsyntax, libstd, etc: the ones that user code links against and a separate set from the previous stage that rustc itself uses. By this point in the bootstrap process, the two library versions _should probably_ be binary compatible, but it doesn't seem like a sure thing. Fixing this is apparently hard, but necessary to properly cross compile as well and is being tracked in #11145.~~ The offending tests are ignored during `check-stage1-rpass` and `check-stage1-cfail`. When we get a snapshot that has this commit, I'll look into how feasible it'll be to get them working on stage1.\n- [x] ~~`macro_rules!` style macros aren't being exported. Now that the crate loading infrastructure is there, this should just require serializing the AST of the macros into the crate metadata and yanking them out again, but I'm not very familiar with that part of the compiler.~~\n- [x] ~~The `macro_crate_registration` function isn't type-checked when it's loaded. I poked around in the `csearch` infrastructure a bit but didn't find any super obvious ways of checking the type of an item with a certain name. Fixing this may also eliminate the need to `#[no_mangle]` the registration function.~~ Now that the registration function is identified by an attribute, typechecking this will be like typechecking other annotated functions.\n- [x] ~~The dynamic libraries that are loaded are never unloaded. It shouldn't require too much work to tie the lifetime of the `DynamicLibrary` object to the `MapChain` that its extensions are loaded into.~~\n- [x] ~~The compiler segfaults sometimes when loading external crates. The `DynamicLibrary` reference and code objects from that library are both put into the same hash table. When the table drops, due to the random ordering the library sometimes drops before the objects do. Once #11228 lands it'll be easy to fix this.~~\n",
  "closed_by": {
    "login": "bors",
    "id": 3372342,
    "node_id": "MDQ6VXNlcjMzNzIzNDI=",
    "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bors",
    "html_url": "https://github.com/bors",
    "followers_url": "https://api.github.com/users/bors/followers",
    "following_url": "https://api.github.com/users/bors/following{/other_user}",
    "gists_url": "https://api.github.com/users/bors/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bors/subscriptions",
    "organizations_url": "https://api.github.com/users/bors/orgs",
    "repos_url": "https://api.github.com/users/bors/repos",
    "events_url": "https://api.github.com/users/bors/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bors/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/11151/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/11151/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "_meta": {
    "type": "pr"
  }
}
