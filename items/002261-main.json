{
  "url": "https://api.github.com/repos/rust-lang/rust/issues/2261",
  "repository_url": "https://api.github.com/repos/rust-lang/rust",
  "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/2261/labels{/name}",
  "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/2261/comments",
  "events_url": "https://api.github.com/repos/rust-lang/rust/issues/2261/events",
  "html_url": "https://github.com/rust-lang/rust/pull/2261",
  "id": 4215554,
  "node_id": "MDExOlB1bGxSZXF1ZXN0MTIwNDk4NA==",
  "number": 2261,
  "title": "std::uv::global_loop and std::timer",
  "user": {
    "login": "olsonjeffery",
    "id": 10408,
    "node_id": "MDQ6VXNlcjEwNDA4",
    "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/olsonjeffery",
    "html_url": "https://github.com/olsonjeffery",
    "followers_url": "https://api.github.com/users/olsonjeffery/followers",
    "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}",
    "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions",
    "organizations_url": "https://api.github.com/users/olsonjeffery/orgs",
    "repos_url": "https://api.github.com/users/olsonjeffery/repos",
    "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}",
    "received_events_url": "https://api.github.com/users/olsonjeffery/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 2,
  "created_at": "2012-04-20T18:19:44Z",
  "updated_at": "2014-06-25T22:28:30Z",
  "closed_at": "2012-04-20T22:24:49Z",
  "author_association": "CONTRIBUTOR",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/rust-lang/rust/pulls/2261",
    "html_url": "https://github.com/rust-lang/rust/pull/2261",
    "diff_url": "https://github.com/rust-lang/rust/pull/2261.diff",
    "patch_url": "https://github.com/rust-lang/rust/pull/2261.patch",
    "merged_at": null
  },
  "body": "At a high-level, this pull request contains:\n- fleshing out the `std::uv::hl` module (provides stuff needed to run a \"high-level\", rust-managed loop with hooks for user-supplied logic/environment\n- adding the `std::uv::global_loop` module, which provides a single, process-wide event loop leverage the types and functions built out in `std::uv::hl`\n- adding the `std::timer` module, which uses `std::uv::global_loop` to provide a high-level interface to the libuv `uv_timer_*` API.\n### std::uv::hl\n\nA set of functions and types to interact safely with a libuv, primarily from rust code. The test and functions in the test module provide a pretty good overview of how to do work it (including the bare minimum to roll-your-own `high_level_loop`)\n### std::uv::global_loop\n\nAs mentioned above, this is the process-wide event loop that (presumably) stdlib developers can use to expose high-level functionality to libuv.\n\nThere are two, full implementations that are present at this time: \n- The `get_single_task_gl` function (exported but hidden in docs) provides a libuv loop that consumes a single task/single-threaded-scheduler. This was my original implementation and, while (ostensibly) lighter-weighter in message/task traffic, it most likely has some race conditions.\n- The `get_monitor_task_gl` function (also exported but hidden in docs) gives access to a libuv loop that's implemented over two tasks (each running in their own single-threaded scheduler). This is the implementation that is wired up to `uv::global_loop::get()`, which is the only fn from this module that appears in the docs\n\nI want to work on the single-task global loop a bit more and, eventually, set up some profiling between the two versions (to test under load). But for now we're shipping what (should) be a race-free version.\n\nNOTE: Do _not_ use both of the above functions within the scope of a single-process lifetime (always use one or the other, but not both). Using just `std::uv::global_loop::get` should (obviously) be your first choice 99.999999% of the time.\n\nIf we're satisfied, relatively speaking, with the perf of the `get_monitor_task_gl()` impl I'll just drop the `get_single_task_loop` impl.\n### std::timer\n\nProvides a few useful functions that use libuv's timer API. Currently only three exported functions:\n- `timer::delayed_send` - send a msg after the provided timeout\n- `timer::sleep` - block the task this is called in for the specified time period\n- `timer::recv_timeout` - block on recv for up to the specified timeout. If a msg is recv'd on the provided port before the timeout expires, we return `some(T)`, otherwise if the timeout period passes without a msg on the provided port, we return `none`.\n\nInterestingly, it seems like `timer::delayed_send` is the primitive upon which you can build everything else in the module, AFAIK.\n\nI also wanted to add a more tradition timer interface that just takes a cb and calls it repeatedly in a new task until it returns false, but didn't get around to it. \n\nThe implementation, here, is the first non-infrastructure/proof-of-concept use of `std::uv::*`. hooray!\n### still unresolved\n- The management of libuv structs' lifetime, stored on the rust stack, is ackward and does not map cleanly to the C/C++ memery (of course!). So I've been trying to work on abstractions to provide some sort of safety net around this. We also have to integrate the `high_level_loop`'s internal reference counting scheme (that sits atop the libuv refcount scheme). I think I have something in mind (a resource, stored in a shared box, that will tie the struct value to a given task.. with some automated setup/teardown), but it's not quite ironed out yet (and places its own burden on the user). For now, we have the `uv::hl::ref`, `uv::hl::unref` and `uv::hl::unref_and_close` fns. Any code that uses libuv structs, on the stack should make sure to:\n  - `ref` at or before the time you make a `uv_init_*` call with the ptr to the struct value.\n  - `unref` and `uv_close` before the task containing the struct exits. This is not always straightforward and requires some thoughtful synchronization via ports/msgs that I'm still working. The tests in `hl`, `global_loop` and the impl in `std::timer` should different examples/approaches for doing this safely. It's an ongoing thing.\n- Should this move into `core`? Probably want to let it prove itself, first.\n### up next\n- Iron-out remaining rough edges in the API and implementation\n- work on getting profiling set up for the loop in general, as well as specific parts of the API.\n- The low-level plumbing is in place for IPv4 TCP/IP, so I'll move towards flushing that out in a high-level API build around port/chan data passing (this work is blocked, on 32bit linux at least, pending #2064)\n- Work towards high-level HTTP client and server scenarios leveraging a high-level TCP/IP API.\n- Bind more of the libuv API's surface, in general, to rust (in `std::uv::ll`) and write tests\n- More tests, better docs\n",
  "closed_by": {
    "login": "brson",
    "id": 147214,
    "node_id": "MDQ6VXNlcjE0NzIxNA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/brson",
    "html_url": "https://github.com/brson",
    "followers_url": "https://api.github.com/users/brson/followers",
    "following_url": "https://api.github.com/users/brson/following{/other_user}",
    "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
    "organizations_url": "https://api.github.com/users/brson/orgs",
    "repos_url": "https://api.github.com/users/brson/repos",
    "events_url": "https://api.github.com/users/brson/events{/privacy}",
    "received_events_url": "https://api.github.com/users/brson/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/2261/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/2261/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "_meta": {
    "type": "pr"
  }
}
