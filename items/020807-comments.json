[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69360141",
    "html_url": "https://github.com/rust-lang/rust/issues/20807#issuecomment-69360141",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/20807",
    "id": 69360141,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MzYwMTQx",
    "user": {
      "login": "sfackler",
      "id": 1455697,
      "node_id": "MDQ6VXNlcjE0NTU2OTc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sfackler",
      "html_url": "https://github.com/sfackler",
      "followers_url": "https://api.github.com/users/sfackler/followers",
      "following_url": "https://api.github.com/users/sfackler/following{/other_user}",
      "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions",
      "organizations_url": "https://api.github.com/users/sfackler/orgs",
      "repos_url": "https://api.github.com/users/sfackler/repos",
      "events_url": "https://api.github.com/users/sfackler/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sfackler/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-09T16:39:34Z",
    "updated_at": "2015-01-09T16:39:34Z",
    "body": "This is already something you have to worry about, since destructors would be able to look at foo during unwinding in the thread as well.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69360141/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69373434",
    "html_url": "https://github.com/rust-lang/rust/issues/20807#issuecomment-69373434",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/20807",
    "id": 69373434,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MzczNDM0",
    "user": {
      "login": "jfager",
      "id": 23755,
      "node_id": "MDQ6VXNlcjIzNzU1",
      "avatar_url": "https://avatars.githubusercontent.com/u/23755?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jfager",
      "html_url": "https://github.com/jfager",
      "followers_url": "https://api.github.com/users/jfager/followers",
      "following_url": "https://api.github.com/users/jfager/following{/other_user}",
      "gists_url": "https://api.github.com/users/jfager/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jfager/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jfager/subscriptions",
      "organizations_url": "https://api.github.com/users/jfager/orgs",
      "repos_url": "https://api.github.com/users/jfager/repos",
      "events_url": "https://api.github.com/users/jfager/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jfager/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-09T18:08:02Z",
    "updated_at": "2015-01-09T18:08:02Z",
    "body": "These examples are different classes of bugs:  the C++ code shows a critical memory safety issue, while the Rust code shows a logic error that doesn't fall within the realm of 'safety' in the sense that Rust means.    \n\nHow is the rust example so different from the obviously \"just a bug\" behavior of:\n\n``` Rust\nfn update_calculation(&mut self) {\n    if self.val1 == 127 { return; };\n    self.calculation_result = self.val1 + self.val2 + self.val3;\n}\n```\n\n?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69373434/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69375916",
    "html_url": "https://github.com/rust-lang/rust/issues/20807#issuecomment-69375916",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/20807",
    "id": 69375916,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5Mzc1OTE2",
    "user": {
      "login": "pythonesque",
      "id": 923144,
      "node_id": "MDQ6VXNlcjkyMzE0NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/923144?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pythonesque",
      "html_url": "https://github.com/pythonesque",
      "followers_url": "https://api.github.com/users/pythonesque/followers",
      "following_url": "https://api.github.com/users/pythonesque/following{/other_user}",
      "gists_url": "https://api.github.com/users/pythonesque/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pythonesque/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pythonesque/subscriptions",
      "organizations_url": "https://api.github.com/users/pythonesque/orgs",
      "repos_url": "https://api.github.com/users/pythonesque/repos",
      "events_url": "https://api.github.com/users/pythonesque/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pythonesque/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-09T18:25:14Z",
    "updated_at": "2015-01-09T18:25:14Z",
    "body": "This is a really good point that I overlooked in the API.  I agree with you, tomaka.  \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69375916/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69379517",
    "html_url": "https://github.com/rust-lang/rust/issues/20807#issuecomment-69379517",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/20807",
    "id": 69379517,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5Mzc5NTE3",
    "user": {
      "login": "tomaka",
      "id": 1412254,
      "node_id": "MDQ6VXNlcjE0MTIyNTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1412254?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tomaka",
      "html_url": "https://github.com/tomaka",
      "followers_url": "https://api.github.com/users/tomaka/followers",
      "following_url": "https://api.github.com/users/tomaka/following{/other_user}",
      "gists_url": "https://api.github.com/users/tomaka/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tomaka/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tomaka/subscriptions",
      "organizations_url": "https://api.github.com/users/tomaka/orgs",
      "repos_url": "https://api.github.com/users/tomaka/repos",
      "events_url": "https://api.github.com/users/tomaka/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tomaka/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-09T18:49:19Z",
    "updated_at": "2015-01-09T18:55:53Z",
    "body": "> How is the rust example so different from the obviously \"just a bug\" behavior of:\n\nIn my example I wrote `if self.val1 == 127 { panic!() }`, but in real code things that can panic look like `unwrap()`, `my_vec[i]`, etc., which you use when you know that you can't recover from them. That's why bringing the possibility to recover from a panic is a bad idea.\n\nHere is a better example. This code below looks reasonable but has exception-safety related issues:\n\n``` rust\nfn update_calculation(&mut self) {\n    self.calculation_result = self.val1.checked_add(self.val2).unwrap().checked_add(self.val3).unwrap();\n}\n\npub fn set_val1(&mut self, value: int) {\n    self.val1 = value;\n    self.update_calculation();\n}\n```\n\nIf you want to \"fix\" this code, you would have to write:\n\n``` rust\nfn update_calculation(&mut self) -> Result<(), ()> {\n    let tmp1 = match self.val1.checked_add(self.val2) {\n        Some(v) => v,\n        None => return Err(())\n    };\n\n    let tmp2 = match tmp1.checked_add(self.val3) {\n        Some(v) => v,\n        None => return Err(())\n    };\n\n    self.calculation_result = tmp2;\n    Ok(())\n}\n\npub fn set_val1(&mut self, value: int) {\n    let previous_value = self.val1;\n    self.val1 = value;\n    if let Err(_) = self.update_calculation() {\n        self.val1 = previous_value;\n        panic!();\n    }\n}\n```\n\nThis is why exception safety is hard. And I'd like to emphasize that this is just a trivial case.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69379517/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69381378",
    "html_url": "https://github.com/rust-lang/rust/issues/20807#issuecomment-69381378",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/20807",
    "id": 69381378,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MzgxMzc4",
    "user": {
      "login": "pythonesque",
      "id": 923144,
      "node_id": "MDQ6VXNlcjkyMzE0NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/923144?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pythonesque",
      "html_url": "https://github.com/pythonesque",
      "followers_url": "https://api.github.com/users/pythonesque/followers",
      "following_url": "https://api.github.com/users/pythonesque/following{/other_user}",
      "gists_url": "https://api.github.com/users/pythonesque/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pythonesque/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pythonesque/subscriptions",
      "organizations_url": "https://api.github.com/users/pythonesque/orgs",
      "repos_url": "https://api.github.com/users/pythonesque/repos",
      "events_url": "https://api.github.com/users/pythonesque/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pythonesque/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-09T19:01:19Z",
    "updated_at": "2015-01-09T19:07:10Z",
    "body": "@sfackler Sure, it's easy to replicate in a single thread:\n\n``` rust\n#![feature(unsafe_destructor)]\n\n#[derive(Show)] struct Foo { foo: u8 }\n\n#[unsafe_destructor]\nimpl<'a, 'b> Drop for Foo {\n    fn drop(&mut self) {\n        println!(\"Foo: {:?}\", self.foo);\n    }\n}\n\n/// Invariant: *x = 2 after this is called.\nfn foo<'a>(x: &'a mut u8) {\n    if *x == 0 {\n        panic!(\"oops\");\n    }\n    *x = 2;\n}\n\nfn main() {\n    let mut x = Foo {foo: 0 };\n    {\n        foo(&mut x.foo);\n    }\n}\n```\n\nThe difference is that you only have to worry about the exception safety violations in destructors.  Destructors _already_ have to do this if you don't abort on panic.  That's fundamental to unwinding.  The problem here that tomaka is pointing out is that this change causes _non-destructors_ to have to worry about it.\n\nThe other key difference with destructors is that destructors can make no guarantees about where they are called (for the most part) so they can't really rely on functions being run after the type is instantiated.  In this case, the guarantee `foo` made is not one the destructor could assume anyway.  However, straightforward regular code does need to be able to assume that function calls fulfill their promises (often encoded in the type signature).  If it can't, that's where you get exception safety violations.\n\nPersonally I think making .join() panic unless you use `'static` is a great idea.  It is more consistent with how I view bounded lifetime threads--they should for the most part work like function calls that just happen to be synchronous.  When a regular function call panics, you know for sure that all code is going to get unwound.  This would encourage people to use `Result`s for bounded lifetime thread return values, just like normal functions that can fail.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69381378/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69382836",
    "html_url": "https://github.com/rust-lang/rust/issues/20807#issuecomment-69382836",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/20807",
    "id": 69382836,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MzgyODM2",
    "user": {
      "login": "tomaka",
      "id": 1412254,
      "node_id": "MDQ6VXNlcjE0MTIyNTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1412254?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tomaka",
      "html_url": "https://github.com/tomaka",
      "followers_url": "https://api.github.com/users/tomaka/followers",
      "following_url": "https://api.github.com/users/tomaka/following{/other_user}",
      "gists_url": "https://api.github.com/users/tomaka/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tomaka/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tomaka/subscriptions",
      "organizations_url": "https://api.github.com/users/tomaka/orgs",
      "repos_url": "https://api.github.com/users/tomaka/repos",
      "events_url": "https://api.github.com/users/tomaka/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tomaka/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-09T19:10:59Z",
    "updated_at": "2015-01-09T19:11:17Z",
    "body": "Destructors are usually either really low-level or don't require the object to be in a valid state, so it's a far smaller problem.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69382836/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69382983",
    "html_url": "https://github.com/rust-lang/rust/issues/20807#issuecomment-69382983",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/20807",
    "id": 69382983,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MzgyOTgz",
    "user": {
      "login": "pythonesque",
      "id": 923144,
      "node_id": "MDQ6VXNlcjkyMzE0NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/923144?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pythonesque",
      "html_url": "https://github.com/pythonesque",
      "followers_url": "https://api.github.com/users/pythonesque/followers",
      "following_url": "https://api.github.com/users/pythonesque/following{/other_user}",
      "gists_url": "https://api.github.com/users/pythonesque/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pythonesque/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pythonesque/subscriptions",
      "organizations_url": "https://api.github.com/users/pythonesque/orgs",
      "repos_url": "https://api.github.com/users/pythonesque/repos",
      "events_url": "https://api.github.com/users/pythonesque/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pythonesque/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-09T19:11:58Z",
    "updated_at": "2015-01-09T19:17:41Z",
    "body": "By the way, this is really sometimes a problem even for existing threads in non-destructors, unless we abort on panic.  If you use atomics, for example, which have no poison value, it's very easy to get exception safety violations by not coding transactionally.  So this is also an argument for abort on panic being the default (among other things) but this is a larger discussion.  I think at least for now, making non-destructors worry about exception safety in cases like this is not a good idea.\n\nOn another note, if people use tricks like this to make sure their or third party code can't panic, rather than because they don't want to deal with it, that is a good sign that we need a `noexcept`.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69382983/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/74345879",
    "html_url": "https://github.com/rust-lang/rust/issues/20807#issuecomment-74345879",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/20807",
    "id": 74345879,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc0MzQ1ODc5",
    "user": {
      "login": "aturon",
      "id": 709807,
      "node_id": "MDQ6VXNlcjcwOTgwNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aturon",
      "html_url": "https://github.com/aturon",
      "followers_url": "https://api.github.com/users/aturon/followers",
      "following_url": "https://api.github.com/users/aturon/following{/other_user}",
      "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aturon/subscriptions",
      "organizations_url": "https://api.github.com/users/aturon/orgs",
      "repos_url": "https://api.github.com/users/aturon/repos",
      "events_url": "https://api.github.com/users/aturon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aturon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-02-13T23:31:29Z",
    "updated_at": "2015-02-13T23:34:01Z",
    "body": "Sorry for taking so long to write in explicitly on this thread, though I've been mulling over the API issue for a while.\n\nI think that @tomaka and @pythonesque are right in that in general, we make it somewhat difficult (though by no means impossible) to run into exception safety problems in \"normal\" (especially safe) code. You have to use `RefCell`, or dig out a value from `PoisonError` in a `Mutex`, in order to observe problems outside of destructors.\n\nThe current `scoped` API, however, risks changing this equation a bit in that \"all\" you have to do is throw away a `Result` to start observing potentially bad data:\n\n``` rust\nlet _ = Thread::scoped(f).join();\n// read some data that f had &mut access to\n```\n\nThe question is, is the `#[must_use]` attribute on `Result` (together with the fact that you have to at least explicitly throw it out as above) enough of a warning here? Note, we _do_ allow you to make similar observations with mutexes, but [you have to dig it out](http://static.rust-lang.org/doc/master/std/sync/struct.PoisonError.html).\n\nI'm not really sure. I feel like the `Result` is _probably_ enough, personally, but we could also consider splitting up `join` into a panicking version and a `join_static` version that has today's signature, for example. I'd appreciate other API sketches if people have more ideas.\n\nI also played with a [much crazier](https://gist.github.com/aturon/d4e42c4955fae2a59b4a) version, but I think it's far too \"clever\" to be of use.\n\n# \n\n@pythonesque  \n\n> If you use atomics, for example, which have no poison value, it's very easy to get exception safety violations by not coding transactionally.\n\nThis I disagree with: if you're using atomics, you're coding transactionally almost by definition: since concurrent threads can observe the state after every atomic update, each update must uphold all needed invariants. This is why lock-free data structures are so fun to write :)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/74345879/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/74366723",
    "html_url": "https://github.com/rust-lang/rust/issues/20807#issuecomment-74366723",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/20807",
    "id": 74366723,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc0MzY2NzIz",
    "user": {
      "login": "tomaka",
      "id": 1412254,
      "node_id": "MDQ6VXNlcjE0MTIyNTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1412254?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tomaka",
      "html_url": "https://github.com/tomaka",
      "followers_url": "https://api.github.com/users/tomaka/followers",
      "following_url": "https://api.github.com/users/tomaka/following{/other_user}",
      "gists_url": "https://api.github.com/users/tomaka/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tomaka/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tomaka/subscriptions",
      "organizations_url": "https://api.github.com/users/tomaka/orgs",
      "repos_url": "https://api.github.com/users/tomaka/repos",
      "events_url": "https://api.github.com/users/tomaka/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tomaka/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-02-14T08:17:55Z",
    "updated_at": "2015-02-14T08:24:10Z",
    "body": "I have never thought of `#[must_use]` as a \"must handle\". There are several situations where you don't care whether the function call succeeded and where you can legitimately throw away the `Result`. For example writing a \"goodbye\" message just before closing a socket, or sending the result of a calculation from a background thread on a channel.\n\nAfter some thoughts, for me the API should ideally look like this:\n- `Thread::scoped` returns a `ScopedJoinGuard` whose `join` method panics.\n- `Thread::spawn` returns a `JoinGuard` (or another name) whose `join` method returns a `Result`.\n\nAfter all, I can see three use cases:\n- You want to spawn a background thread, in which case you'd call `Thread::spawn()` then `detach` (instead of just `Thread::spawn()` today). For me this is the rarest case.\n- You want to spawn a thread but have some kind of ownership over it, in which case you'd call `Thread::spawn()` (today you'd call `Thread::scoped()`).\n- You want to spawn a thread that manipulates your local variables, in which case you'd call `Thread::scoped()`.\n\nI don't know if that will pass, since I think the API used to look kind of like this and since it's a bigger change than a simple modification to a safety problem.\n\n**Other important problem**: the destructor of `JoinGuard` simply joins the thread and ignores the result. This should be fixed too. I don't know what the state of linear types is, but that would be a good situation to use them. Alternatively, in my opinion panic in the destructor unless the current thread is unwinding.\n\n> or dig out a value from PoisonError in a Mutex\n\nOuch, I didn't know about this one.\n\nI'd be in favor or making `into_guard` unsafe. I don't see what would be a legitimate use-case of this outside of unsafe code.\n\nI guess that this whole discussion is supposed to be in the \"threads RFC\" instead of an issue. Unfortunately like many people (I think) I don't have the time to read RFCs, and I spot problems once things are implemented.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/74366723/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/74437834",
    "html_url": "https://github.com/rust-lang/rust/issues/20807#issuecomment-74437834",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/20807",
    "id": 74437834,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc0NDM3ODM0",
    "user": {
      "login": "pythonesque",
      "id": 923144,
      "node_id": "MDQ6VXNlcjkyMzE0NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/923144?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pythonesque",
      "html_url": "https://github.com/pythonesque",
      "followers_url": "https://api.github.com/users/pythonesque/followers",
      "following_url": "https://api.github.com/users/pythonesque/following{/other_user}",
      "gists_url": "https://api.github.com/users/pythonesque/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pythonesque/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pythonesque/subscriptions",
      "organizations_url": "https://api.github.com/users/pythonesque/orgs",
      "repos_url": "https://api.github.com/users/pythonesque/repos",
      "events_url": "https://api.github.com/users/pythonesque/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pythonesque/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-02-15T21:23:54Z",
    "updated_at": "2015-02-15T21:28:00Z",
    "body": "@tomaka I'm okay with the poison stuff because you really have to explicitly abandon exception safety in order to use the `Mutex` that way.  My concern is that there is nothing stopping you from just ignoring the value of the returned `Thread` except for `#[must_use]`, so the path of least resistance may be giving up exception safety (especially since in most cases, Rust programmers are being correctly trained to use `try!` rather than `unwrap()`).  Unfortunately I don't really see a way to make it much easier to do the right thing without real linear types (so you could actually _force_ the `Result` of joining a thread to be handled explicitly) or just panicking (the bomb idea is _really_ interesting though... I could actually be persuaded to like that, but it might be hard to get through an RFC).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/74437834/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/74484707",
    "html_url": "https://github.com/rust-lang/rust/issues/20807#issuecomment-74484707",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/20807",
    "id": 74484707,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc0NDg0NzA3",
    "user": {
      "login": "bluss",
      "id": 3209739,
      "node_id": "MDQ6VXNlcjMyMDk3Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bluss",
      "html_url": "https://github.com/bluss",
      "followers_url": "https://api.github.com/users/bluss/followers",
      "following_url": "https://api.github.com/users/bluss/following{/other_user}",
      "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bluss/subscriptions",
      "organizations_url": "https://api.github.com/users/bluss/orgs",
      "repos_url": "https://api.github.com/users/bluss/repos",
      "events_url": "https://api.github.com/users/bluss/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bluss/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-02-16T10:05:11Z",
    "updated_at": "2015-02-16T11:39:40Z",
    "body": "I thought you will get better traction if you demonstrate real memory unsafety in safe Rust code. The following is a paper construction, but it should work:\n\n``` rust\nstruct Panicker<T>(T);\n// Implement PartialOrd, Ord on Panicker so that it panics when compared with `<=`.\n\nlet mut heap = BinaryHeap::new();\nlet guard = Thread::scoped(|| {\n    heap.push(Panicker(Vec::new()));\n    heap.push(Panicker(Vec::new()));\n});\nguard.join().ok();\n\n// Access heaps' first element here.\nlet zeroed_struct = heap.into_iter().next();\n\n// BinaryHeap's sift_up will now panic on the first comparison, but not until after having replaced\n// its first element with `zeroed()`.\n// So we can create a zeroed-out version of any struct we want.\n// This breaks many invariants:\n// 1) A zeroed Vec means that Some(v) is the same as None, because the vec's ptr is marked NonZero.\n// 2) We can zero a BTreeMap which will result in a btreemap with 0 for `b` and null for the\n// root node, which will lead to an immediate violation since the insert/lookup\n// methods assume root is not null.\n```\n\nI've come back to the [zeroing code](https://github.com/rust-lang/rust/blob/master/src/libcollections/binary_heap.rs#L500-L515) in BinaryHeap before, and it's an easy target (that will eventually go away), but I'm sure there are other exploitable locations (in the sense of this bug) in libstd if we look for them.\n\nEdit: It's actually the second element of the BinaryHeap that's zeroed.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/74484707/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/74492292",
    "html_url": "https://github.com/rust-lang/rust/issues/20807#issuecomment-74492292",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/20807",
    "id": 74492292,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc0NDkyMjky",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-02-16T11:08:00Z",
    "updated_at": "2015-02-16T11:08:00Z",
    "body": "I've been thinking about this over the weekend.\n\nMy feeling is roughly that exception safety is a fact of life, but we should do what we can to minimize it. I've always been a fan of \"unwind the whole thread\" for this reason, and when I envisioned \"data-parallel\" helpers in the past -- basically a more-efficient and convenient version of Thread::scoped -- I always assumed that they would propagate panics unconditionally, just as would occur in sequential code.\n\nThat said, even if we did unconditionally propagate a panic, it doesn't obviate the need for exception safety! The need for exception safety is inherent to error recovery -- the more flexible your error recovery, the more fine-grained your problem. For example, even if we did NO unwinding at all, we'd still have to worry about shared memory between processes. The problem that @bluss highlights, for example, can also occur if you have a destructor that owns the `BinaryHeap` and which tries to use it during unwinding:\n\n``` rust\n...\nstruct Something {\n    heap: BinaryHeap<Panicker>\n}\n\nimpl Drop for Something {\n    fn drop(&mut self) {\n        ... self.heap.iter().next() ...\n    }\n}\n\nlet mut heap = Something { heap: BinaryHeap::new() };\nheap.push(Panicker { ... });\n```\n\nI guess that the main difference is that using `Thread::scoped` one can fairly easily encounter such bugs outside of a destructor. That is, `Thread::scoped` is a lot like a more expensive \"try/catch\", and by allowing the task boundary to be permeated, it tends to expose some of the problems that \"try/catch\" implies.\n\nI am sympathetic towards @aturon's suggestion (modulo naming) that we have a version of `join` which works for any thread, but which unconditionally propagates panics, and a version of `join` that works only for `'static` threads, but which permits recovery (and perhaps an `unsafe` version of `join` that permits recovery in all situations?). But this starts to be quite the zoo of `join` functions! And given that all of the bugs we're talking about are bugs that have to be fixed anyway, I am not sure it's worth it.\n\nI guess that the main advantages I see to having all of these functions is that they would avoid the footgun of ignoring the result and thus _help_ mitigate problems due to exception safety in end-user code (no guarantees are provided). Certainly libstd will still need careful vetting and fuzzing and so forth to catch these sorts of bugs, because (as I described above) the problems with exception safety still exist, even if the range of code that can expose them is less. Those advantages may be worth the price of having many distinct `join` functions (or perhaps there's another more ergonomic way to present this?).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/74492292/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/74574828",
    "html_url": "https://github.com/rust-lang/rust/issues/20807#issuecomment-74574828",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/20807",
    "id": 74574828,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc0NTc0ODI4",
    "user": {
      "login": "aturon",
      "id": 709807,
      "node_id": "MDQ6VXNlcjcwOTgwNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aturon",
      "html_url": "https://github.com/aturon",
      "followers_url": "https://api.github.com/users/aturon/followers",
      "following_url": "https://api.github.com/users/aturon/following{/other_user}",
      "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aturon/subscriptions",
      "organizations_url": "https://api.github.com/users/aturon/orgs",
      "repos_url": "https://api.github.com/users/aturon/repos",
      "events_url": "https://api.github.com/users/aturon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aturon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-02-16T21:26:46Z",
    "updated_at": "2015-02-16T21:26:46Z",
    "body": "Thanks everyone for the additional comments!\n\nThe basic point, which has been articulated variously in the above comments, is that exception safety is fundamentally a concern when programming in Rust. _However_, with careful design of things like mutex poisoning, it's a concern that can _largely_ be relegated to unsafe implementations (like `BinaryHeap`) and destructor code, making it a relatively narrow concern.\n\n@nikomatsakis's last comment made clear to me, moreover, that the current `scoped` API is basically tantamount to adding a general `catch` facility, which we've long stayed away from for exactly the reasons above: we want exception safety to be a thing that _most_ Rust code doesn't have to worry much about.\n\nI will mull over the cleanest/most ergonomic way of tightening up the API -- probably something along the lines of @tomaka's suggestion.\n\n# \n\n@tomaka \n\n> **Other important problem**: the destructor of `JoinGuard` simply joins the thread and ignores the result. This should be fixed too. I don't know what the state of linear types is, but that would be a good situation to use them. Alternatively, in my opinion panic in the destructor unless the current thread is unwinding.\n\nThe problem is that we fundamentally _cannot_ allow the thread to continue past that point in the stack, whether through unwinding or otherwise, because the child thread could continue accessing the data! That has clear memory safety problems. So the only other option would be to abort the process.\n\nWe thought pretty hard about this join-on-drop semantics, since it is surprising, and carefully chose the name \"scoped\" to try to clearly communicate the lifetime concerns.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/74574828/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/74638040",
    "html_url": "https://github.com/rust-lang/rust/issues/20807#issuecomment-74638040",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/20807",
    "id": 74638040,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc0NjM4MDQw",
    "user": {
      "login": "aturon",
      "id": 709807,
      "node_id": "MDQ6VXNlcjcwOTgwNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aturon",
      "html_url": "https://github.com/aturon",
      "followers_url": "https://api.github.com/users/aturon/followers",
      "following_url": "https://api.github.com/users/aturon/following{/other_user}",
      "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aturon/subscriptions",
      "organizations_url": "https://api.github.com/users/aturon/orgs",
      "repos_url": "https://api.github.com/users/aturon/repos",
      "events_url": "https://api.github.com/users/aturon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aturon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-02-17T09:17:42Z",
    "updated_at": "2015-02-17T09:17:42Z",
    "body": "WIP PR has [been posted](https://github.com/rust-lang/rust/pull/22435), addressing the above concerns together with some other API requests that have accumulated. I'd appreciate any comments on the PR.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/74638040/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
