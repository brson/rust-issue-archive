[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21809217",
    "html_url": "https://github.com/rust-lang/rust/issues/8132#issuecomment-21809217",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8132",
    "id": 21809217,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxODA5MjE3",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-30T17:50:43Z",
    "updated_at": "2013-07-30T17:50:43Z",
    "body": "nominating well-covered\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/21809217/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22205659",
    "html_url": "https://github.com/rust-lang/rust/issues/8132#issuecomment-22205659",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8132",
    "id": 22205659,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMjA1NjU5",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-06T19:46:08Z",
    "updated_at": "2013-08-06T19:51:47Z",
    "body": "Here's another idea, much less type-systemsy. Since we know the task will resume on a different core, we could just have it spin-wait until the cleanup-job is finished running. It would be the equivalent of this:\n\n```\nlet mut environment = ...;\nlet ok_to_run_task = AtomicBool::new(false);\ndo sched.deschedule_running_task_and_then |sched, task| {\n    sched.schedule_blocked_task(task);\n    ... use environment ... // A\n    ok_to_run_task.store(true, Release); // always the last thing that runs in the closure\n}\nwhile !ok_to_run_task.load(Acquire) { } // always the first thing to run when task resumes\n... use environment ... // B\n\n// victory, a happens-before relationship established between A and B\n```\n\nWe can make it so this synchronization dance always automatically happens by putting it inside `change_task_context`. This is tricky because a pointer to the AtomicBool will need to be stored in the CleanupJob alongside the closure, so run_cleanup_job will be the place the release-store is done, and after the context-swap in change_task_context will be where the acquire-load loop is done.\n\nThere is good news and bad news about this approach. The pro is that this enables users of this interface to access the environment even after giving the task away, such as in select (#8347) where it's necessary. The con is that a careless user that gives a cleanup job that takes \"a long time\" to execute after giving away the task handle can cause the other CPU to spin-wait for \"just as long\". (It is not, however, vulnerable to deadlock.) \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22205659/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22206029",
    "html_url": "https://github.com/rust-lang/rust/issues/8132#issuecomment-22206029",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8132",
    "id": 22206029,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMjA2MDI5",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-06T19:51:37Z",
    "updated_at": "2013-08-06T19:57:56Z",
    "body": "Ah, actually, I think we can just use a oneshot in that context, and everybody wins. It is also no harder on cacheline contention than the atomicbool plan, but both are still worse (best case: one extra xchg in the context switch path) than the type systemsy solution.\n\nPerhaps we can have one of each version. Select can use the slower-by-one-xchg version; other places can use the environment-token solution.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22206029/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22210170",
    "html_url": "https://github.com/rust-lang/rust/issues/8132#issuecomment-22210170",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8132",
    "id": 22210170,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMjEwMTcw",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-06T20:49:44Z",
    "updated_at": "2013-08-06T20:49:44Z",
    "body": "It's certainly less invasive than the type-based approach. Although it seems unlikely to contend often, spinning sucks for valgrind, and valgrind's serialization may mean that it does contend under valgrind more than under normal execution. Spending two atomic ops to maintain this invariant seems extravagant.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22210170/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22538134",
    "html_url": "https://github.com/rust-lang/rust/issues/8132#issuecomment-22538134",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8132",
    "id": 22538134,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNTM4MTM0",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-13T01:34:17Z",
    "updated_at": "2013-08-13T01:34:17Z",
    "body": "Actually , re-nominating 0.8 milestone. As long as this goes unsolved, the task-killing race in `switch_running_tasks_and_then` can't be fixed, and any program that mixes failure and message-passing will go through this buggy path and will be at risk for crashing (or worse!).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22538134/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/23055438",
    "html_url": "https://github.com/rust-lang/rust/issues/8132#issuecomment-23055438",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8132",
    "id": 23055438,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzMDU1NDM4",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-21T22:27:15Z",
    "updated_at": "2013-08-21T22:27:15Z",
    "body": "I have thought a bit more about this, and basically think that using a LittleLock is the best way.\n\nMy most recent idea was to use an atomic flag that's shared between the cleanup job and someone trying to kill the task (very similar to the state flag used in ports/chans), such that whichever of the two runs later is responsible for reenqueueing the task. But the problem with this is that you also need to do a swap on the flag if you're waking up the task normally (or else a reawoken task going to do a second cleanup job could race with its own first cleanup job), and that would cause contention on the flag even in the most common context switches.\n\nThe idea with the LittleLock would involve having one such lock per task struct, and in `switch_running_tasks_and_then`, if the task is not unkillable, taking the lock around the `BlockedTask::try_block(task)`/`f(sched, blocked_task)` sequence. Dropping the lock here would be through an unsafe pointer, since we give the task away to try to block it (or perhaps have it live in an unsafearc, but that would require its own refcounting). To protect that pointer, the lock would also have to be bounced off of (i.e., `do task.cleanup_job_lock.lock { }`) in task death. The guarantee would be provided through a similar lock-bounce when a task is about to fail from being killed.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/23055438/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/24339719",
    "html_url": "https://github.com/rust-lang/rust/issues/8132#issuecomment-24339719",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8132",
    "id": 24339719,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MzM5NzE5",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-09-12T17:27:54Z",
    "updated_at": "2013-09-12T17:27:54Z",
    "body": "Just a bug, de-nominating\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/24339719/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/24347330",
    "html_url": "https://github.com/rust-lang/rust/issues/8132#issuecomment-24347330",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/8132",
    "id": 24347330,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MzQ3MzMw",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-09-12T19:07:59Z",
    "updated_at": "2013-09-12T19:07:59Z",
    "body": "IMO this is more than a bug, or at least, one that needs to be addressed before the next release. Because of this problem, all the test cases for linked failure are currently ignored, and although user programs can still use linked failure, they will segfault randomly. Since the test cases are ignored, the implementation is at risk of rotting until this is fixed.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/24347330/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
