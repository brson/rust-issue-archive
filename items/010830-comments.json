[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/29959199",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-29959199",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 29959199,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI5OTU5MTk5",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T02:39:21Z",
    "updated_at": "2013-12-06T02:39:21Z",
    "body": "This is very exciting.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/29959199/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/29960227",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-29960227",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 29960227,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI5OTYwMjI3",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T03:04:54Z",
    "updated_at": "2013-12-06T03:04:54Z",
    "body": "I want to read this all carefully, but I've only gotten through the doc comments tonight.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/29960227/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/29968253",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-29968253",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 29968253,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI5OTY4MjUz",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T07:15:52Z",
    "updated_at": "2013-12-06T07:15:52Z",
    "body": "do you have a sense for why oneshot performance is 3x slower despite stream being faster?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/29968253/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/29970005",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-29970005",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 29970005,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI5OTcwMDA1",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T07:54:50Z",
    "updated_at": "2013-12-06T07:54:50Z",
    "body": "I do indeed. Right now oneshots are actually super-optimized for their use case. An allocation of a oneshot channel is one tiny allocation of a box to share between the two ends. An allocation of a stream in this pull request, however, is three allocations (hence the ~3x slowdown).\n\nIn profiling, the creation of the channel completely dominated the oneshot benchmark.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/29970005/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/29999628",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-29999628",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 29999628,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI5OTk5NjI4",
    "user": {
      "login": "brendanzab",
      "id": 695077,
      "node_id": "MDQ6VXNlcjY5NTA3Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brendanzab",
      "html_url": "https://github.com/brendanzab",
      "followers_url": "https://api.github.com/users/brendanzab/followers",
      "following_url": "https://api.github.com/users/brendanzab/following{/other_user}",
      "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions",
      "organizations_url": "https://api.github.com/users/brendanzab/orgs",
      "repos_url": "https://api.github.com/users/brendanzab/repos",
      "events_url": "https://api.github.com/users/brendanzab/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brendanzab/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T14:53:21Z",
    "updated_at": "2013-12-06T14:53:21Z",
    "body": "@alexcrichton Are oneshots going to be added again in the future if folks want better performance for that use case?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/29999628/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30012351",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30012351",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30012351,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDEyMzUx",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T17:26:36Z",
    "updated_at": "2013-12-06T17:26:36Z",
    "body": "I would rather try out not adding oneshots back to begin with. The use case in which they are more efficient is when the creation of the channel is far more common than the usage of the channel. We currently don't have much code that has its bottleneck in that area.\n\nAnother snag would be implementing `select` over oneshot ports as well. In theory I should be able to select over a oneshot port as well as a port-port, and I don't think that the trait-bound of selection we have today cuts it. This could in theory be possible, but it's not as elegant as I would like, so I'd like to try running around without oneshots first.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30012351/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30012567",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30012567",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30012567,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDEyNTY3",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T17:29:20Z",
    "updated_at": "2013-12-06T17:29:20Z",
    "body": "@alexcrichton There's an issue that is still unsolved: SharedChan can be used to create cycles\n\nIt has always existed, but it might be the right time to consider it since we are rewriting it and changing the API anyway.\n\nI filed it as issue #10835 so the discussion can be done there instead of on this pull request since it's somewhat orthogonal to implementation issues.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30012567/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30013791",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30013791",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30013791,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDEzNzkx",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T17:45:14Z",
    "updated_at": "2013-12-06T17:45:14Z",
    "body": "@alexcrichton Is access to the to_wake field properly synchronized?\n\nIt doesn't seem to be protected by any locks, and doesn't seem to be accessed with atomics, but it's very possible I misunderstand something since I only glanced at the code.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30013791/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30016273",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30016273",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30016273,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDE2Mjcz",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T18:17:39Z",
    "updated_at": "2013-12-06T18:17:39Z",
    "body": "@alexcrichton The SPSC web pages adds padding to put the consumer and producer side of the queue on different cachelines, but this pull request forgets to do so\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30016273/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30017333",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30017333",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30017333,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDE3MzMz",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T18:31:35Z",
    "updated_at": "2013-12-06T18:31:35Z",
    "body": "@alexcrichton The SPSC code uses Relaxed which seems wrong: it should use Release on most stores and Consume on most loads like the code in the linked web page does.\n\nIn general, it seems that all the synchronization-related parts need careful expert review, although the high-level design might be correct.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30017333/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30018679",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30018679",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30018679,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDE4Njc5",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T18:49:11Z",
    "updated_at": "2013-12-06T18:49:11Z",
    "body": "> Is access to the to_wake field properly synchronized?\n\nTo the best of my knowledge, yes.\n\n> The SPSC web pages adds padding to put the consumer and producer side of the queue\n\nYes, I wasn't able to measure any difference and I wanted to make the struct smaller (while I was optimizing the oneshot case)\n\n> The SPSC code uses Relaxed which seems wrong\n\nWhoops, I reverted everything away from `SeqCst` while benchmarking b/c I was seeing some weird codegen, and I forgot to go back and change them.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30018679/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30018682",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30018682",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30018682,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDE4Njgy",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T18:49:13Z",
    "updated_at": "2013-12-06T18:49:13Z",
    "body": "@alexcrichton It seems that the handling of Packet::cnt is wrong.\n\nSpecifically Packet::increment can do a fetch_add on a channel with cnt == DISCONNECT, and the code then resets it to DISCONNECT, but this means that in the race window _any_ negative value can represent a disconnected channel.\n\nHence Packet.decrement should consider any negative cnt as disconnected instead of asserting that if cnt != DISCONNECT then cnt >= 0, which is false; likewise all other checks for DISCONNECTED need to be fixed.\n\nBTW, this assumes that the code never makes cnt negative for reason other than disconnection, which seems true but isn't totally clear.\n\nAlternatively, you can use a cmpxchg in Packet.increment so that if cnt == DISCONNECTED, then cnt is never changed, and you can then use negative cnt for other things.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30018682/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30018905",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30018905",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30018905,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDE4OTA1",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T18:51:36Z",
    "updated_at": "2013-12-06T19:06:16Z",
    "body": "> > Is access to the to_wake field properly synchronized?\n> \n> To the best of my knowledge, yes.\n\nEDIT: ok, it seems that the cnt field is used to represent whether to_wake is valid.\n\nHowever, what if a producer thread stops indefinitely while in the middle of reading the to_wake?\n\nProducers don't seem to block consumers writing to_wake, so it seems it could be overwritten while a producer reads it.\n\nIn other words, I think you need to make to_wake a 1-word structure and manage it with atomics, or put a mutex around it.\n\nAlso, anything that to_wake points to must live infinitely if you don't use a mutex (since a producer might stall forever while waking up).\n\nThis seems to be the case already on 1:1, since the wakeup mutex is either in an Arc, or in the channel, but I'm not sure whether the M:N case is correct.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30018905/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30019133",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30019133",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30019133,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDE5MTMz",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T18:54:31Z",
    "updated_at": "2013-12-06T18:54:31Z",
    "body": "BTW, if you use Acquire and Consume there should be no code generation difference on x86 compared to Relaxed, because the x86 hardware provides those guarantees for all code (all stores are ordered, and dependent loads are too)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30019133/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30021490",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30021490",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30021490,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDIxNDkw",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T19:23:44Z",
    "updated_at": "2013-12-06T19:23:44Z",
    "body": "@alexcrichton What if the user specifies the same port multiple times in the select() array?\n\nIt seems this will break all sorts of invariants in the current code, for instance by decrementing cnt multiple times.\n\nThere should be a check for it, or maybe select should take &muts.\n\nBTW, select is inefficient because it is O(n^2) since reading from each of n pipes requires selecting on all n: it should be replaced by some sort of Select struct where ports can be added and removed and the actual select() call has no arguments\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30021490/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30022349",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30022349",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30022349,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDIyMzQ5",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T19:35:02Z",
    "updated_at": "2013-12-06T19:35:25Z",
    "body": "% RESCHED_FREQ should be & RESCHED_FREQ_MASK since division is extremely slow, and power-of-two resched frequencies should be enough, assuming that this thing is needed at all.\n\nAs the code stands, try() might well spend the majority of the execution time dividing unnecessarily on some architectures...\n\nHOWEVER, this algorithm is probably completely broken anyway because with SharedChan a single unlucky producer might never resched because other producers might hit all the cnt values multiple of RESCHED_FREQ...\n\nLikewise, if one sends on several different channels, it may also never reschede.\n\nIt probably should just call maybe_yield which should do the & RESCHED_FREQ internally on a #[thread_local] variable that it also increments (#[thread_local] is very fast to access, certainly far faster than dividing...)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30022349/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30022720",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30022720",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30022720,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDIyNzIw",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T19:39:11Z",
    "updated_at": "2013-12-06T19:39:11Z",
    "body": "`#[thread_local]` is a pointer offset in a static binary but in a dynamically linked one it's going to take hundreds of instructions\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30022720/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30022964",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30022964",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30022964,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDIyOTY0",
    "user": {
      "login": "basic-calculus",
      "id": 4070335,
      "node_id": "MDQ6VXNlcjQwNzAzMzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4070335?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/basic-calculus",
      "html_url": "https://github.com/basic-calculus",
      "followers_url": "https://api.github.com/users/basic-calculus/followers",
      "following_url": "https://api.github.com/users/basic-calculus/following{/other_user}",
      "gists_url": "https://api.github.com/users/basic-calculus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/basic-calculus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/basic-calculus/subscriptions",
      "organizations_url": "https://api.github.com/users/basic-calculus/orgs",
      "repos_url": "https://api.github.com/users/basic-calculus/repos",
      "events_url": "https://api.github.com/users/basic-calculus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/basic-calculus/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T19:42:19Z",
    "updated_at": "2013-12-06T20:02:01Z",
    "body": "I heavily use oneshots in my [application](https://gitorious.org/p-x/p-x/source/83543f447b35d27909402467201d2a35367b6880:) and feel they offer a really nice API for asynchronous method calls. But I'm basically using oneshots as promises or futures so if a library along those lines is planned for the future I'd be fine with oneshots being removed.\n\nAlso I'm not sure why @alexcrichton would think oneshots can't be selected over. Wouldn't any of the suggestions given in issue #10624 work?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30022964/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30023077",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30023077",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30023077,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDIzMDc3",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T19:43:38Z",
    "updated_at": "2013-12-06T19:44:17Z",
    "body": "> #[thread_local] is a pointer offset in a static binary but in a dynamically linked one it's going to take hundreds of instructions\n\nHuh?\n\nAt worst it will get the TLS offset from a global variable in the dynamic library (or from the GOT to be more precise on x86-64), which might take something like 5 instructions.\n\nOf course this assumes a good implementation like the one in Linux/glibc.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30023077/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30023344",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30023344",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30023344,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDIzMzQ0",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T19:46:57Z",
    "updated_at": "2013-12-06T19:48:05Z",
    "body": "It will end up making calls to the `__tls_get_addr` function at runtime on Linux. It definitely runs more than 5 instructions. If you're using more restricted (more local) thread-local variables in dynamic libraries, then it has to do less work.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30023344/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30024873",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30024873",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30024873,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDI0ODcz",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T20:04:59Z",
    "updated_at": "2013-12-06T20:05:55Z",
    "body": "Sorry, 5 instructions was optimistic, I guess it's more around 20 for dynamic libraries in the fast path.\n\n__tls_get_addr is this, where of course the ifs are not executed for accesses after the first if no libraries have been loaded in between:\n\n```\nvoid *\n__tls_get_addr (tls_index* ti)\n{\n    dtv_t *dtv = THREAD_DTV ();\n\n    if (__builtin_expect (dtv[0].counter != _rtld_global.dl_tls_generation, 0))\n        return update_get_addr (ti);\n\n    void *p = dtv[ti->ti_module].pointer.val;\n\n    if (__builtin_expect (p == TLS_DTV_UNALLOCATED, 0))\n        return tls_get_addr_tail (ti, dtv, NULL);\n\n    return (char *) p + ti->ti_offset;\n}\n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30024873/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30026170",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30026170",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30026170,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDI2MTcw",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T20:23:27Z",
    "updated_at": "2013-12-06T20:23:27Z",
    "body": "> It seems that the handling of Packet::cnt is wrong\n\nIt's perfectly normal to see a large negative value in cnt. The only significant value is -1.\n\n> this assumes that the code never makes cnt negative for reason other than disconnection\n\nThat is not true. I mention explicitly in the documentation about how the channels work that the count can be very negative.\n\n> Alternatively, you can use a cmpxchg in Packet.increment\n\nThis is not does not have the progress semantics I would want. While most senders would reasonably only execute a cmpxchg a few times, it's much nicer to guarantee that only one atomic instruction is run.\n\n> However, what if a producer thread stops indefinitely while in the middle of reading the to_wake?\n\nI do not see the problem. The producer owns `to_wake` and the receiver just goes to sleep.\n\n> Producers don't seem to block consumers writing to_wake, so it seems it could be overwritten while a producer reads it.\n\nNo, as you found out, this is only read when the value is -1. The value is only -1 when `to_wake` is set.\n\n> In other words, I think you need to make to_wake a 1-word structure and manage it with atomics, or put a mutex around it.\n\nNo, acquire/release semantics will guarantee that _all_ writes on behalf of the producer are visible to the consumer.\n\n> Also, anything that to_wake points to must live infinitely if you don't use a mutex (since a producer might stall forever while waking up).\n\nNo, it just needs to be guaranteed to be alive for its use. The scheduler provides separate guarantees which enforce this. Additionally, see my XXX comment about how the `SchedHandle` is currently kept alive.\n\n> What if the user specifies the same port multiple times in the select() array?\n\nAh I forgot that I forgot to handle this. My original redesign had all the methods take `&mut self`, which as you pointed out, would certainly fix this. I plan on likely `fail!()` ing in this situation, but you're right that the code right now doesn't handle this.\n\n> BTW, select is inefficient\n\nSounds like you're describing the select syscall, which has nothing to do with `comm::select`. This implementation is `O(n)` in blocking and wakeup.\n\n> % RESCHED_FREQ should be & RESCHED_FREQ_MASK\n\nI have seen this nowhere in my profiles. Compared to an atomic instruction, this is not a concern.\n\n> As the code stands, try() might well spend the majority of the execution time dividing unnecessarily on some architectures...\n\nI do not believe that this is a matter of concern unless a concrete profile shows it to be.\n\n> this algorithm is probably completely broken anyway\n\nThis rescheduling is not used for correctness, it is used to prevent starvation. If a task only sends a few times on a few channels, then there's no manual rescheduling necessary. The starvation we're protecting against is when one task simply infinitely sends data without ever yielding to the scheduler (which this implementation is guaranteed to eventually check for a rescheduling).\n\n> Likewise, if one sends on several different channels, it may also never reschedule\n\nThat is not true. If the task exits after sending on channels, then there is most certainly a rescheduling. As mentioned above, this is just starvation prevention, not pre-emption.\n\n> #[thread_local] is very fast to access\n\nNot in my profiling. This is exactly why I added the only \"check to maybe reschedule every so often\". The TLS accesses were slowing the benchmark down by about 50-80%. The executables I was working with were all statically linked, and from what @thestinger mentioned, something may be going wrong if they're so slow.\n\n> Also I'm not sure why @alexcrichton would think oneshots can't be selected over\n\nThere is no magical \"let's select over everything all at once\" function to call. That has to be implemented by someone. Having implemented this iteration of select, I can tell you personally that it would be difficult. I'm not saying it's impossible.\n\nMy biggest concern is the type signature of select. This rewrite changes it to `fn select(ports: &[&Port]) -> int` which is exactly what one would expect. There are a few possibilities for how oneshots would fit into this argument list:\n- `fn ChanOne::new() -> (Port<T>, ChanOne<T>)` - the \"onceness\" is expressed as an invariant on the sender, not the receiver\n- `trait Selectable { ... }` and `fn select(ports: &[&Selectable])` - this is kind of what it is today, except the version where it takes anything. The problem with this is what is the `Selectable` trait? How can `fn select` actually do anything with it? Can user types implement this soundly?\n- `fn ChanOne::new() -> (PortOne<T>, ChanOne<T>)` plus `fn PortOne::unwrap(self) -> Port<T>`. This would allow the common way of expressing the invariant that a PortOne may be received on only once, while still allowing for selection over all `comm` ports. You could still call `unwrap` and recv twice, but at least you have to explicitly opt-in to it.\n\nOf those methods, I prefer the third, but it still doesn't sit well with me. As a result, I have chosen to not reimplement oneshot ports. Remember though, the _only_ semantic difference about a oneshot is that you can only use it once. A normal channel will suffice as a replacement in all circumstances (without having the same invariant of being used once). The only reason to _prefer_ a oneshot (ignoring semantics) is if your application is dominated with the creation of channels (in which case allocating a stream is slower). I do not forsee this as being very common (I could very well be wrong).\n\n> __tls_get_addr is this \n\nLet's please keep this pull request on topic. Discussions of how `thread_local` works/doesn't work as implemented today should be discussed elsewhere.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30026170/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30028392",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30028392",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30028392,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDI4Mzky",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T20:53:07Z",
    "updated_at": "2013-12-06T20:54:38Z",
    "body": "> It's perfectly normal to see a large negative value in cnt. The only significant value is -1.\n\nThe code asserts in several places that n >= 0 in matches where the only other case is n == DISCONNECTED, as far as I can tell.\n\nThis is wrong since a disconnected socket can have DISCONNECTED + 1 in the race window caused by your use of xadd instead of cmpxchg and in fact DISCONNECTED + k where k < max_simultaneously_running_tasks.\n\n> I do not see the problem. The producer owns to_wake and the receiver just goes to sleep.\n> The receiver won't go to sleep if after filling to_wake it finds out that the queue is actually non-empty (otherwise you have a race condition where the receiver sleeps forever).\n\nAnd then the producer owns to_wake, but the receiver can overwrite it as it writes again, as far as I can tell.\n\n> No, it just needs to be guaranteed to be alive for its use.\n\nIf the producer does not block receivers while reading to_wake (such as by having both take a mutex), then the producer thread might stop indefinitely between reading to_wake and waking up the task while receivers select on it multiple times, which means to_wake must be valid forever (the only thing that is guaranteed is that the channel will stay alive, so storing stuff in the channel is OK).\n\n> Sounds like you're describing the select syscall\n\nIf you are waiting on a million ports, you'll need to enqueue the task to wait on each of the million ports every time you receive a message.\n\nSo to receive a message each from a million ports, it takes a trillion iterations of the select inner loop, which is clearly not good.\n\nThis is exactly the same issue the OS select() and poll() syscalls have (since the poll() syscall does exactly the same thing as your code does in kernel), and it's why it has been replaced with epoll and kqueue in properly written software with unbounded amounts of fds to select over.\n\n> > As the code stands, try() might well spend the majority of the execution time dividing unnecessarily on some architectures...\n> > I do not believe that this is a matter of concern unless a concrete profile shows it to be.\n\nThat's probably because you profiled on an out-of-order architecture with hardware division (like an x86-64 CPU) where the branch predictor allowed to continue executing speculatively despite the division not having finished.\n\nTry it on an in-order architecture without hardware division (low-end ARM CPUs) and it should be far more visible.\n\nIn general, one should absolutely never divide (or use % which is the same) unless it's unavoidable (btw, this is a 64-bit division on 64-bit machines, which is even worse).\n\nIn this case, there's absolutely no justification to use a division, since the resched frequency is arbitrary anyway and can thus be made a power of two.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30028392/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30030117",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30030117",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30030117,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDMwMTE3",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T21:16:37Z",
    "updated_at": "2013-12-06T21:16:37Z",
    "body": "> This is wrong since a disconnected socket can have DISCONNECTED + 1 in the race window caused by your use of xadd instead of cmpxchg and in fact DISCONNECTED + k where k < max_simultaneously_running_tasks.\n\nSorry this was a little unclear. I've gone through a bunch of iterations and the relevant comment appears to have been removed. Regardless, you are correct in this description. The bug would occur if there were enough increments to bring the value to -1 from the disconnected state before the original task put disconnected back into the slot. On a 64-bit architecture, that will never happen. On a 32-bit architecture, I'm willing to bet money that will never happen.\n\n> And then the producer owns to_wake, but the receiver can overwrite it as it writes again, as far as I can tell.\n> \n> ...\n> \n> If the producer does not block receivers while reading to_wake (such as by having both take a mutex), then the producer thread might stop indefinitely between reading to_wake and waking up the task while receivers select on it multiple times, which means to_wake must be valid forever (the only thing that is guaranteed is that the channel will stay alive, so storing stuff in the channel is OK).\n\nI'm not understanding where you think the problem is. Can you provide me a trace which exposes the bug?\n\n> This is exactly the same issue the OS select() and poll() syscalls have\n\nOk, but it's also not helpful to say \"select is slow\". The select implementation is not slow at all, rather the interface inherently prevents an \"efficient implementation\" as you're expecting. This just means that we would need to evaluate whether we would need another abstraction. This abstraction would probably be something along the lines of:\n\n```\nfn selector<'a>(ports: &'a [&Port]) -> Selector<'a> { ... }\nimpl Selector {\n  fn select(&mut self) -> int;\n}\n```\n\nAnd that would prevent having to re-sleep on ports all the time (possibly, I have not considered implementation details).\n\nRegardless, the speed of `select()` versus another abstraction is not the main focus of this pull request, so I would like to continue this conversation elsewhere. If you have concrete suggestions for how to make the interface as-is today faster, then I'm willing to listen, but discussions of a different abstraction should occur elsewhere\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30030117/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30033437",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30033437",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30033437,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDMzNDM3",
    "user": {
      "login": "huonw",
      "id": 1203825,
      "node_id": "MDQ6VXNlcjEyMDM4MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huonw",
      "html_url": "https://github.com/huonw",
      "followers_url": "https://api.github.com/users/huonw/followers",
      "following_url": "https://api.github.com/users/huonw/following{/other_user}",
      "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huonw/subscriptions",
      "organizations_url": "https://api.github.com/users/huonw/orgs",
      "repos_url": "https://api.github.com/users/huonw/repos",
      "events_url": "https://api.github.com/users/huonw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huonw/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T22:02:27Z",
    "updated_at": "2013-12-06T22:02:27Z",
    "body": "( @bill-myers you may already know this, but one can put comments on individual lines of the code on the \"Files Changed\" tab of pull requests, which gives better locality for a review.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30033437/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30033696",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30033696",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30033696,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDMzNjk2",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T22:06:25Z",
    "updated_at": "2013-12-06T22:20:01Z",
    "body": "> The bug would occur if there were enough increments to bring the value to -1 from the disconnected state \n> No, I was not referring to that, which is not possible since there cannot be more simultaneously running tasks than words in the address space.\n\nI _think_ the issue might in fact not be present, because if something is set to DISCONNECTED, then we either no longer have any Port code executing or we have no more SharedChan code executing.\n\nIn the second case, there is only one Port, so no races are possible anymore.\n\nIn the former case, SharedChan seems to assert that n >= 0 if n != DISCONNECTED only in Drop when there is only one SharedChan instance, and so races are again impossible.\n\nNote however that if one were to implement a shutdown() method that would set DISCONNECTED on a chan/port without destroying either all SharedChan or Port, then this invariant would be broken.\n\nSo I guess it's fine for now, although it's not at all intuitive, since one would expect to be able to implement such a shutdown() method given the high-level design, and thus maybe it would be better to generalize things immediately to consider all values < -2 (or maybe <DISCONNECTED/2) as disconnected.\n\n> I'm not understanding where you think the problem is. Can you provide me a trace which exposes the bug?\n\nLet's say a producer is in the middle of executing \"(*packet).to_wake.take_unwrap().wake(can_resched)\", and let's say that take_unwrap code generated by the compiler works by first setting the Option discriminator to None and then reading the value inside the option.\n\nThis is the last code executed when sending something, so it means that ports and chans are in their \"normal\" state.\n\nAt this point, the owner of the Port is not necessarily sleeping, because a producer might have enqueued a packet just between the time BlockingContext sets to_wake and the time decrement() executes, causing the consumer to dequeue itself and not sleep.\n\nHence, consumers can change to_wake while \"(*packet).to_wake.take_unwrap().wake(can_resched)\" is executing, which means that the take_unwrap can return a mismash of the old and new data, resulting in a crash.\n\nMaybe I'm missing something though.\n\n> This just means that we would need to evaluate whether we would need another abstraction\n\nYes.\n\nThe abstraction MUST also allow to add and remove ports dynamically, since otherwise you still have O(n^2) runtime if you have to recreate the whole thing every time you need to listen on a new port.\n\nSo something like this:\n\n```\ntrait Selectable {...}\n\nimpl<T:Selectable> Selectable for ~T {...}\n\nstruct SelectorHandle<T> {...}\n\nstruct SelectorEvent<'a, T, D> {\nport: &'a mut T,\ncustom_data: D,\nevents: EventMask\n}\n\nimpl Selector<T: Selectable, D>\n{\nfn add(&mut self, port: T, event_mask: EventMask, custom_data: D) -> SelectorHandle<T> {...}\nfn modify(&mut self, handle: SelectorHandle<T>, event_mask: EventMask) {...}\nfn remove(&mut self, handle: SelectorHandle<T>) -> T {...}\nfn get<'a>(&'a mut self, handle: &'a SelectorHandle<T>) -> &'a mut T {...}\nfn signaled<'a>(&'a mut self, timeout: Option<TimeSpan>) -> Iterator<SelectorEvent<'a, T, D>> {...}\n}\n\nimpl<T, D> Selectable for Selector<T, D>\n\n// to select on multiple different T types, use Selector<~Selectable, D>\n```\n\n> Regardless, the speed of select() versus another abstraction is not the main focus of this pull request, so I would like to continue this conversation elsewhere\n\nWell, it might be better to not provide select() at all in favor of the other abstraction, to reduce code duplication and prevent inexperienced programmers from using the wrong one.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30033696/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30034581",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30034581",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30034581,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDM0NTgx",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T22:18:51Z",
    "updated_at": "2013-12-06T22:18:51Z",
    "body": "> Hence, consumers can change to_wake while \"(*packet).to_wake.take_unwrap().wake(can_resched)\" is executing\n\nRemember that there is only one consumer, which is why I don't think that this race exists.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30034581/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30034746",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30034746",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30034746,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDM0NzQ2",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T22:21:40Z",
    "updated_at": "2013-12-06T22:21:40Z",
    "body": "Yes, but I think the consumer is not necessarily asleep, because another producer might have sent a packet between the time the consumer enqueues itself and the time it calls decrement(), which causes the consumer to abort.\n\nOr is it?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30034746/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30034975",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30034975",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30034975,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDM0OTc1",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T22:25:27Z",
    "updated_at": "2013-12-06T22:25:27Z",
    "body": "I pointed this out in a few places in both the documentation and the code. The only time a sender will wake up a receiver is -1, and the only time that this is ever possibly seen is when `to_wake` is valid, and only when the receiver is blocking.\n\nI want to try to keep this pull request on track, so if you have a _concrete trace_ of a sequence of events which leads to a race, then I would certainly like to be aware of it. Otherwise, I would like to keep discussions of theoretical races to a forum which doesn't generate emails to all watchers of rust.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30034975/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30037513",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30037513",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30037513,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDM3NTEz",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-06T23:05:28Z",
    "updated_at": "2013-12-06T23:11:09Z",
    "body": "The consumer is always asleep in the recv case, but the select case seems problematic.\n\nI think this would trigger the issue:\n1. State: channel empty\n2. Consumer: select on this channel and another unrelated channel: sets cnt = -1, sets to_wake to wake up itself, and goes to sleep\n3. Producer: send: Packet::increment() sets cnt = 0, executes up to and starts executing, in SharedChan::try, v = (*packet).to_wake.take_unwrap()\n4. Another producer on another unrelated channel that the consumer is selecting on wakes up the consumer\n5: Consumer: executes abort_selection, sets cnt = 1\n6. Consumer: call recv to receive the packet that was sent, sets cnt = 0\n7. Consumer: call recv again, which causes it to set cnt = -1 and modify (*packet).to_wake to go to sleep\n8. Producer: send: finishes executing v = (*packet).to_wake.take_unwrap() while (7) was happening\n9. Producer: v now has corrupted data because we executed (*slot).take_unwrap() and *slot = Some(TaskHandle {...}) simultaneously, so v.wake(can_resched) crashes\n\nNote that in (3), (*packet).to_wake.take_unwrap() is at the very end of the code executed by the producer when calling chan.send(), so the channel is in a \"normal\" state on the producer side.\n\nOn the consumer side, the only consumer would normally be asleep if it were a recv, but in a select it can be awakened by another channel and then do anything including mucking with to_wake while the producer is still trying to wake it up.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30037513/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30046517",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30046517",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30046517,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDQ2NTE3",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-07T03:20:06Z",
    "updated_at": "2013-12-07T03:20:06Z",
    "body": "Yes, that is a race.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30046517/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30047175",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30047175",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30047175,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDQ3MTc1",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-07T04:06:32Z",
    "updated_at": "2013-12-07T04:06:32Z",
    "body": "BTW, note that if this is fixed by just making to_wake access atomic or protected by a lock, you'll still have spurious wakeups in the non-shared cases, so the code must be prepared for that, and it currently isn't, since both select and recv currently assert in that case.\n\nAssuming that the sched handle can be put in a task, then to_wake essentially becomes a 4-valued discriminator (green vs native, shared vs non-shared) and a pointer. This can be encoded as an atomic word with the two low bits used to store the discriminator, and then one can take it by xchg.\n\nHowever, I think there should probably just be a mutex around the whole slow path that deals with wait/wake (with double checked locking), which is the normal way to do this kind of stuff and would avoid the spurious wakeups, and allow to do things like put the wakeup data on the consumer stack and thus avoid having to allocate an Arc to hold the mutex in select.\n\nThere's also the issue that maybe when disconnecting the data should be removed immediately instead of left there until all sides are destroyed.\n\nThe \"simple\" solution there is having two rwlocks, one for the producer side and one for the consumer side (which can just be a mutex due to single consumer) to avoid contention, that get read locked by everything, except for disconnection that would write lock both and destroy everything; not sure if there is anything better.\n\nBTW, regarding contention, Packet needs to be put in the middle of the SPSC data structure, and the cacheline separation must be done there, so that fields like cnt and steals are also separated into different cachelines, since it's useless to do that in the SPSC struct and not elsewhere.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30047175/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30047977",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30047977",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30047977,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDQ3OTc3",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-07T05:07:12Z",
    "updated_at": "2013-12-07T18:20:06Z",
    "body": "Maybe an implementation done like this pseudocode could handle all concerns (destroy data on disconnection, don't have spurious wakeups).\n\ncnt and steals are no longer needed, as far as I can tell.\n\n```\nfn subscribe(&mut self, wakeup_data) {\n   let lock_guard = self.mutex.lock();\n   assert!(self.to_wake.is_none());\n\n   self.to_wake = Some(wakeup_data);\n   // ^- must happen before -V\n   self.state atomic= PortWaiting;\n   // ^- must happen before -V\n}\n\nfn unsubscribe() {\n   let lock_guard = self.mutex.lock();\n   self.state atomic= PortRunning;\n   self.to_wake = None; \n}\n\nfn select() {\n    loop {\n        for each port {if !port.queue.is_empty() {return index;}}\n        let cond = Cond();\n        cond.lock();\n        for each port {\n            if !port.queue.is_empty() {return None;}\n            port.subscribe(&cond);\n            if !port.queue.is_empty() {port.unsubscribe(); return None;}\n        }\n        cond.wait();\n        cond.unlock()\n        for each port {port.unsubscribe()};\n    }\n}\n\nfn internal_recv_opt(&mut self) {\n    let cond = Cond();\n    loop {\n        if v = self.pop() {return v;}\n        cond.lock():\n        self.subscribe(&cond)\n        if v = self.pop() {self.unsubscribe(); cond.unlock(); return v;}\n        cond.wait();\n        cond.unlock();\n        self.unsubscribe();\n    }\n}\n\n// we queue None when the last channel disconnects; otherwise, we queue Some(data)\nfn internal_send(&mut self, data) -> bool {\n   if self.state.atomic_read() == NoPort {return false;}\n\n   self.queue.push(data);\n\n   if self.state.atomic_read() == PortRunning {return true;}\n\n   let lock_guard = self.mutex.lock();\n\n   match self.state.atomic_read() {\n       PortRunning => true,\n       NoPort => {self.queue.pop(); false}\n       PortWaiting => {   \n           self.to_wake.lock();\n           self.to_wake.signal();\n           self.to_wake.unlock();\n           self.state atomic= PortRunning;\n           true\n       }\n   }\n}\n\nfn recv_opt(&mut self) -> Option<T> {\n    if self.disconnected {return None;}\n    let v = self.internal_recv_opt();\n    if v.is_none() {self.disconnected = true;}\n    return v;\n}\n\nfn send(&mut self, data) {\n    self.internal_send(Some(data));\n}\n\nfn drop_last_channel(&mut self)\n{\n   self.internal_send(None);\n}\n\nfn drop_or_shutdown_port(&mut self)\n{\n   self.state atomic= NoPort;\n\n   // now we are guaranteed that nothing is going to be pushed on the queue anymore\n   // finally, clear the queue\n   while !self.try_recv().is_none() {}\n\n   // make sure that if we call recv after shutting down the port, it reports disconnection\n   self.disconnected = true;\n}\n```\n\nEDIT: rewritten!\n\nIt was incorrectly destroying all data when the last channel exits, but that's stupid because if a Port still exists, then it should first read all data that was sent, and THEN report disconnection!\n\nDropping all channels is handled by queueing None whenever we drop the last channel (which of course means normal send queues Some(x) instead of x), and then when recv reads a None it sets a \"disconnected\" flag only used by the consumer.\n\nDropping the port is handled with a tri-state \"state\" variable that is PortRunning normally, PortWaiting when the port is waiting and NoPort when it is destroyed.\n\nIf this is indeed race free, it seems definitely the best approach.\n\nBTW, sending None can and should be optimized by either modifying the SPSC and MPSC queues to support queueing a magic pointer value for that, or by using an additional flag that is checked when the queue turns out to be empty\n\nAlso this version should be optimizable to be usable as a oneshot without much overhead (by doing the optimization above and making the initial node of the SPSC queue a field in the queue itself).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30047977/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30050197",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30050197",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30050197,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDUwMTk3",
    "user": {
      "login": "brendanzab",
      "id": 695077,
      "node_id": "MDQ6VXNlcjY5NTA3Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brendanzab",
      "html_url": "https://github.com/brendanzab",
      "followers_url": "https://api.github.com/users/brendanzab/followers",
      "following_url": "https://api.github.com/users/brendanzab/following{/other_user}",
      "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions",
      "organizations_url": "https://api.github.com/users/brendanzab/orgs",
      "repos_url": "https://api.github.com/users/brendanzab/repos",
      "events_url": "https://api.github.com/users/brendanzab/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brendanzab/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-07T08:01:06Z",
    "updated_at": "2013-12-07T08:01:06Z",
    "body": "> But I'm basically using oneshots as promises or futures so if a library along those lines is planned for the future I'd be fine with oneshots being removed.\n\n@sstewartgallus Note that `Future`s were [implemented using oneshots](https://github.com/mozilla/rust/pull/10830/files#diff-f2a9aa6142b89395a6e4125cd98183fcL108).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30050197/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30062041",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30062041",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30062041,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDYyMDQx",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-07T18:59:56Z",
    "updated_at": "2013-12-07T18:59:56Z",
    "body": "Alright, I have an idea which I believe will fix selection. In general though, I have realized that `fn select<T>(&[&Port<T>])` is the wrong signature for select. My previous idea of a \"heterogeneous select\" was \"select over any flavor of port\", but I have now realized that it is truly \"select over a chan of ints and a chan of chars\".\n\nTo this end, I believe that I can fix select as-is, but I would rather not land it as-is. I would like to remove `select` from this pull request (meaning we would have a period of time where selection over channels is not possible) and add it later once I have given it more thought to be designed. The other option is to close this request entirely and I'll come back once I've redesigned select to work how I would like it to. The last option is to fix select as-is, which means it won't get any worse than it is today, and I could always just improve it later.\n\n@brson, do you have a preference on a course of action?\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30062041/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30062351",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30062351",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30062351,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDYyMzUx",
    "user": {
      "login": "pcwalton",
      "id": 157897,
      "node_id": "MDQ6VXNlcjE1Nzg5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pcwalton",
      "html_url": "https://github.com/pcwalton",
      "followers_url": "https://api.github.com/users/pcwalton/followers",
      "following_url": "https://api.github.com/users/pcwalton/following{/other_user}",
      "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions",
      "organizations_url": "https://api.github.com/users/pcwalton/orgs",
      "repos_url": "https://api.github.com/users/pcwalton/repos",
      "events_url": "https://api.github.com/users/pcwalton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pcwalton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-07T19:12:58Z",
    "updated_at": "2013-12-07T19:12:58Z",
    "body": "My (very weak, feel free to override) vote is for the last option. Select is useful and has always been slow for as long as Rust has existed. Good Rust code always avoids select in performance critical code. When we have performant select, it'll be a joyous day, but we don't have to solve all problems at once. Having much faster channels is a huge win (kudos!) and that's reason enough for me to land this PR.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30062351/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30159471",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30159471",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30159471,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTU5NDcx",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-09T18:43:23Z",
    "updated_at": "2013-12-09T18:43:23Z",
    "body": "Thanks for the thorough review @bill-myers.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30159471/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30187379",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30187379",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30187379,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTg3Mzc5",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-10T00:01:25Z",
    "updated_at": "2013-12-10T00:01:25Z",
    "body": "I have added one more commit. This commit completely redesigns `select` to use more of a port-set-like interface. The implementation is the same as before, but in the future this should allow us to optimize the implementation a bit more.\n\nI believe that I have also fixed the race that was there before, albeit fixed very badly. Currently there's a yield-loop to get past the race condition, but this is clearly not ideal. I would think that a rewrite of select regardless would supersede trying to get rid of it, so I've decided to leave it for now.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30187379/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30192261",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30192261",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30192261,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTkyMjYx",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-10T01:38:55Z",
    "updated_at": "2013-12-10T01:38:55Z",
    "body": "The spsc queue looks good to me.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30192261/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30197805",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30197805",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30197805,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTk3ODA1",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-10T04:01:50Z",
    "updated_at": "2013-12-10T04:01:50Z",
    "body": "This has been rebased on top of master with all comments addressed and is ready for a review of `select`.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30197805/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30281375",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30281375",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30281375,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMjgxMzc1",
    "user": {
      "login": "bill-myers",
      "id": 4647491,
      "node_id": "MDQ6VXNlcjQ2NDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4647491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bill-myers",
      "html_url": "https://github.com/bill-myers",
      "followers_url": "https://api.github.com/users/bill-myers/followers",
      "following_url": "https://api.github.com/users/bill-myers/following{/other_user}",
      "gists_url": "https://api.github.com/users/bill-myers/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bill-myers/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bill-myers/subscriptions",
      "organizations_url": "https://api.github.com/users/bill-myers/orgs",
      "repos_url": "https://api.github.com/users/bill-myers/repos",
      "events_url": "https://api.github.com/users/bill-myers/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bill-myers/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-10T23:56:04Z",
    "updated_at": "2013-12-10T23:56:04Z",
    "body": "Is this Select design actually usable for a system that wants to begin selecting on new ports dynamically?\n\nSpecifically, add() returns an Handle with the same lifetime 'a as the &'a mut Port.\n\nBut the handle needs to persist across multiple iterations of the event loop (otherwise, the exercise is pointless since we have add/remove stuff every time and have O(n^2)), which that the lifetime 'a must contain the whole event loop, and thus the &mut Port must be valid for the whole event loop.\n\nBut Ports are created and destroyed in there (upon dynamic connection and disconnection of clients), so it seems impossible that one can get an &mut with such a long lifetime.\n\nHence, I think add() needs to take ports by value, not by &mut.\n\nAlternatively, it can take them by a short-lived reference, increment the reference count on them and dynamically check to ensure they aren't already being selected over.\n\nFinally, it seems wrong for Handle to have try_recv/recv/recv_opt instead of simply a method that allows to borrow the Port itself.\n\nAnd of course the implementation is all wrong since queuing needs to happen in add() and not wait(), and the set of ready ports needs to be stored instead of looping over every port, but I guess this is known.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30281375/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30286335",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30286335",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30286335,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMjg2MzM1",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-11T01:30:16Z",
    "updated_at": "2013-12-11T01:30:16Z",
    "body": "> Is this Select design actually usable for a system that wants to begin selecting on new ports dynamically?\n\nYes. I suppose that we could changing it to taking the port by value instead of by reference, I'm not convinced of the benefits, however. If you have trouble keeping the ports alive then you're surely going to have trouble keeping the handles alive, so I don't think that the lifetime issue is the problem of keeping ports in a port set. If you couldn't keep a port alive longer than the port set then it seems like you'd have a lot of trouble keeping the handle alive for as long as the port set.\n\n> Alternatively, it can take them by a short-lived reference, increment the reference count on them and dynamically check to ensure they aren't already being selected over.\n\nI've opted for now to statically ensure that a port is selected over only once. We may want to relax this in the future, but for now I believe that this is the right decision.\n\n> Finally, it seems wrong for Handle to have try_recv/recv/recv_opt instead of simply a method that allows to borrow the Port itself.\n\nOh good point, I had initially thought that I didn't want to allow this, but there's no reason if you're not returning `&mut Port`, so I think I'll just add a `get()` method.\n\n> And of course the implementation is all wrong since queuing needs to happen in add() and not wait(), and the set of ready ports needs to be stored instead of looping over every port, but I guess this is known.\n\nI would not call it \"wrong\" but rather inefficient, but yes, this is known. I wanted to create something that could in the future be optimized, but right now I don't want to have to grapple with this problem at the same time as redesigning the rest of channels.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30286335/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30762443",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30762443",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30762443,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwNzYyNDQz",
    "user": {
      "login": "zargony",
      "id": 5121,
      "node_id": "MDQ6VXNlcjUxMjE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5121?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zargony",
      "html_url": "https://github.com/zargony",
      "followers_url": "https://api.github.com/users/zargony/followers",
      "following_url": "https://api.github.com/users/zargony/following{/other_user}",
      "gists_url": "https://api.github.com/users/zargony/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zargony/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zargony/subscriptions",
      "organizations_url": "https://api.github.com/users/zargony/orgs",
      "repos_url": "https://api.github.com/users/zargony/repos",
      "events_url": "https://api.github.com/users/zargony/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zargony/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-17T15:53:16Z",
    "updated_at": "2013-12-17T15:53:16Z",
    "body": "This is awesome (and the docs are great)! I assume `select!` will become available as a std_macro?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30762443/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30770554",
    "html_url": "https://github.com/rust-lang/rust/pull/10830#issuecomment-30770554",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/10830",
    "id": 30770554,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwNzcwNTU0",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-17T17:18:09Z",
    "updated_at": "2013-12-17T17:18:09Z",
    "body": "Eventually I want `select!` to be a general for-use macro, but for now I'm leaving it inside of `std::comm::select` because it's a little experimental. If you copy it though (for now), it should definitely be usable!\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/30770554/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
