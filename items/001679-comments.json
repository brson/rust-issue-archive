[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3680219",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3680219",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3680219,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2ODAyMTk=",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T00:59:48Z",
    "updated_at": "2012-01-27T00:59:48Z",
    "body": "- This is a good observation and in general I agree with it.\n- Disjoint unions are implemented using typestate in Hermes, using this mechanism. Check the papers :)\n- I've proposed permitting tag constructor names as implicit predicates in the past, precisely for this reason.\n- I don't see a strong distinction between \"datasort refinement\" and \"predicate applied to single immutable value\". Except possibly implementation mechanism. Can you elaborate on the difference?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3680219/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3680374",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3680374",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3680374,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2ODAzNzQ=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T01:15:02Z",
    "updated_at": "2012-01-27T01:15:02Z",
    "body": "In response to the last question: the difference is just that the compiler has special knowledge about datasort refinements and can use it to eliminate checks. In the example I already gave, if `bar` had one field, then if `whee` was given a refined type, the compiler could compile away the `alt` and just extract the field directly -- no tag checking would be needed.\n\nIn general it's hard to see how arbitrary predicates applied to single immutable values can be exploited by the compiler to do optimizations.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3680374/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3683975",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3683975",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3683975,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2ODM5NzU=",
    "user": {
      "login": "marijnh",
      "id": 144427,
      "node_id": "MDQ6VXNlcjE0NDQyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marijnh",
      "html_url": "https://github.com/marijnh",
      "followers_url": "https://api.github.com/users/marijnh/followers",
      "following_url": "https://api.github.com/users/marijnh/following{/other_user}",
      "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions",
      "organizations_url": "https://api.github.com/users/marijnh/orgs",
      "repos_url": "https://api.github.com/users/marijnh/repos",
      "events_url": "https://api.github.com/users/marijnh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marijnh/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T09:13:04Z",
    "updated_at": "2012-01-27T09:13:04Z",
    "body": "> now that I'm going through and making all alts exhaustive\n\nPlease don't. I agree that alts should be exhaustive by default, but some just aren't, and being able to use a non-exhaustive alt as an assertion is a very valuable thing to have.\n\nI assume you're just adding `_ { fail \"something...\"; }` clauses to such non-exhaustive alts. This tends to clutter the code, and produce no more informative error message than the default failure generated for such things by the compiler.\n\nI'd much prefer if you added a way to explicitly specify that an alt is non-exhaustive, which would disable the warning/error for non-exhaustiveness, and make the compiler generate the implicit error path that current alts have.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3683975/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3691997",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3691997",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3691997,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTE5OTc=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T18:51:36Z",
    "updated_at": "2012-01-27T18:51:36Z",
    "body": "Marijn: What do you think of the proposal above? It accomplishes the same goal as your suggestion (\"a way to explicitly specify that an alt is non-exhaustive\"), but with less clutter (because annotations are part of a type signature, there will be fewer of them), and with a static guarantee that there will be no non-exhaustive alt failures (because it becomes possible to check statically that all alts are actually exhaustive).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3691997/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3692417",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3692417",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3692417,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTI0MTc=",
    "user": {
      "login": "marijnh",
      "id": 144427,
      "node_id": "MDQ6VXNlcjE0NDQyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marijnh",
      "html_url": "https://github.com/marijnh",
      "followers_url": "https://api.github.com/users/marijnh/followers",
      "following_url": "https://api.github.com/users/marijnh/following{/other_user}",
      "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions",
      "organizations_url": "https://api.github.com/users/marijnh/orgs",
      "repos_url": "https://api.github.com/users/marijnh/repos",
      "events_url": "https://api.github.com/users/marijnh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marijnh/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T19:15:03Z",
    "updated_at": "2012-01-27T19:15:03Z",
    "body": "The problem is that proving that a given value was constructed by a specific (subset of) variant will, in a lot of situations, be equivalent to the halting problem. So you get the same thing that makes typestate painful to use: you'll have to run a check on your value (and probably also first put it in a local variable), to be able to pattern-match on it.\n\nIn some programs this might work out, but I think there'll be enough cases where it won't, in which a non-statically-proven-safe form of non-exhaustive alt is still useful.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3692417/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693012",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3693012",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3693012,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTMwMTI=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T19:54:14Z",
    "updated_at": "2012-01-27T19:54:14Z",
    "body": "Another problem that I see is that inserting an \"alt-unsafe\" (or whatever) form doesn't encourage the programmer to document why it's actually safe to assume that the alt will actually match. Allowing the programmer to state invariants by giving more precise types to values than is currently possible encourages more rigorous reasoning, IMO. \"alt-unsafe\" could encourage people to just throw it in until the compiler is happy.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693012/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693082",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3693082",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3693082,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTMwODI=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T19:59:06Z",
    "updated_at": "2012-01-27T19:59:06Z",
    "body": "Where I'm coming from with this is that I'm looking at the many, many non-exhaustive alts in rustc and asking: \"Why is this alt guaranteed to be exhaustive? What's the invariant?\" And since in every single case, there is no documentation of why the code author expected that to be true, it's always unclear whether the non-exhaustivity is an error (that has coincidentally worked so far) or intentional. And I don't think having a different alt-unsafe form does much about that problem. I guess it does document one bit of information about the programmer's intent (that they believe there's an invariant), but not what the invariant is.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693082/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693191",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3693191",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3693191,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTMxOTE=",
    "user": {
      "login": "marijnh",
      "id": 144427,
      "node_id": "MDQ6VXNlcjE0NDQyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marijnh",
      "html_url": "https://github.com/marijnh",
      "followers_url": "https://api.github.com/users/marijnh/followers",
      "following_url": "https://api.github.com/users/marijnh/following{/other_user}",
      "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions",
      "organizations_url": "https://api.github.com/users/marijnh/orgs",
      "repos_url": "https://api.github.com/users/marijnh/repos",
      "events_url": "https://api.github.com/users/marijnh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marijnh/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T20:06:13Z",
    "updated_at": "2012-01-27T20:07:28Z",
    "body": "Well, at the risk of sounding somewhat snarky, the invariant is _that one of the patterns in the alt will match_. I agree this doesn't usually amount to a perfect explanation, but neither will a special type or a predicate being applied to the value.\n\n(Don't get me wrong, I think the feature proposed here would be awesome. I just don't think it's a full solution to the unexhastive alt problem.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693191/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693232",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3693232",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3693232,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTMyMzI=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T20:09:24Z",
    "updated_at": "2012-01-27T20:09:24Z",
    "body": "Well, you could also say that in a unityped language, the invariant is that there will be no dynamic type errors. However, statically typed languages allows richer invariants to be specified through the type system.\n\nIn this case, the reason why the programmer believes that one of the pattern will match presumably has something to do with dataflow and control flow properties, and types are a way to express an approximation to these properties. As you pointed out, the properties that need to be specified may be undecidable in general, but I would say that if it's not the case that most invariants that currently underlie inexhaustive cases in rustc are simple to state, then there's something wrong. The whole principle behind static typing is that while some of the properties we might like to check are undecidable, many useful properties can be captured in a decidable type system.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693232/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693265",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3693265",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3693265,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTMyNjU=",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T20:11:24Z",
    "updated_at": "2012-01-27T20:13:40Z",
    "body": "I have a wondrous solution!\n\nYou know how we have `if check` that combines the flow-control goodness of `if` with the typestate nutrition of `check`?\n\nI hereby propose `alt check` which does the same. Specifically:\n- The form of the `alt` has to be a simple N-way branch on the enum ctors. No nested matching or guards.\n- If control passes the `alt`, it went through one of the arms, so the enum refinement of the disjunction-of-the-arms is valid in the poststate.\n- If you didn't say `alt check` then nonexhaustive matches warn. You can inhibit the warning if you want.\n- You can write `_ { }` if you want fallthrough.\n- If a given enum-refinement already holds, it can be used to prove a non-exhaustive alt legal anyways. IOW\n  if you were to say `check x | some(*); alt x { some(y) { ... } }` this would compile w/o error.\n\nThis actually generalizes nicely to refutable patterns in `let` bindings too. Add `let check`:\n- `let check some(y) = x;` establishes the enum refinement on `x` (or fails), then unpacks its value to `y`.\n- `check x | some(*); let some(y) = x;` means the same thing and compiles w/o error.\n- `let some(y) = x` on its own gives a refutable-pattern warning (that you can inhibit).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693265/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693352",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3693352",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3693352,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTMzNTI=",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T20:17:28Z",
    "updated_at": "2012-01-27T20:17:28Z",
    "body": "(Granted, this has the slightly non-intuitive behavior that you have to write `alt check` to get the `alt` that fails at runtime, where you might think `alt check` is actually the strict `alt` that demands exhaustiveness. Tolerable UI idiosyncracy? I do think we want `alt` to default to exhaustiveness-checking, that's the thing ... which argues for \"you have to say a little bit more to get non-exhaustiveness\")\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693352/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693395",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3693395",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3693395,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTMzOTU=",
    "user": {
      "login": "marijnh",
      "id": 144427,
      "node_id": "MDQ6VXNlcjE0NDQyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marijnh",
      "html_url": "https://github.com/marijnh",
      "followers_url": "https://api.github.com/users/marijnh/followers",
      "following_url": "https://api.github.com/users/marijnh/following{/other_user}",
      "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions",
      "organizations_url": "https://api.github.com/users/marijnh/orgs",
      "repos_url": "https://api.github.com/users/marijnh/repos",
      "events_url": "https://api.github.com/users/marijnh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marijnh/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T20:19:55Z",
    "updated_at": "2012-01-27T20:19:55Z",
    "body": "`check` can be interpreted as 'adds a run-time exhaustiveness check'. I think it's fine.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693395/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693408",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3693408",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3693408,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTM0MDg=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T20:21:31Z",
    "updated_at": "2012-01-27T20:21:31Z",
    "body": "Graydon: this looks OK to me, though I would prefer to call it something different from \"alt check\" (I'm not sure what). A construct like \"alt check\" would be necessary anyway for introducing values that have refined types. The only thing non-standard in what you're suggesting is that, basically, the \"failure\" case would be implicit (the compiler would insert an implicit fail in the case where none of the listed constructors match).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693408/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693421",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3693421",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3693421,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTM0MjE=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T20:22:36Z",
    "updated_at": "2012-01-27T20:22:36Z",
    "body": "I think the name \"alt check\" is confusing because \"if check\" is the version of \"check\" that never aborts the program if the check fails -- whereas an \"alt check\" can abort the program.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693421/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693494",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3693494",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3693494,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTM0OTQ=",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T20:26:56Z",
    "updated_at": "2012-01-27T20:26:56Z",
    "body": "Yeah. It's true, the thing is not exactly analogous to `if check` (in the sense that in `if check` the predicate holds in the true branch but we don't implicitly fail in the false branch. Hmm.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693494/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693501",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3693501",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3693501,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTM1MDE=",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T20:27:19Z",
    "updated_at": "2012-01-27T20:29:27Z",
    "body": "I strongly disagree with @marijnh.  I want to know when my alts are not exhaustive (it can be a warning, as long as we have -Werror :).  Further, I want a way to prove to the type system that my alt IS in fact exhaustive, because I only need to consider a subset of cases here.  We have neither of those things right now.  I've found that Scala (which does support this sort of thing, through subtyping) made enums substantially more expressive than O'Caml.\n\n@pcwalton @dherman and I have been kicking around ideas on this for a while.  An early proposal was something like:\n\n```\nenum expr {\n    enum tuple_like { \n        ex_tup()\n        ex_rec()\n    }\n    enum lvalue {\n        ex_path()\n        ex_index()\n    }\n}\n```\n\nHowever, this was not satisfactory for several reasons.  First, rightward drift. Second, it only supported trees.  What if I had a case that was both an lvalue and tuple-like?\n\n@pcwalton just proposed an interesting idea where you can \"expand\" an enum, so you might write:\n\n```\nenum tuple_like {\n    tup()\n    rec()\n}\n\nenum lvalue {\n    path()\n    index()\n}\n\nenum expr < tuple_like, lvalue {\n    some_other_case()\n}\n```\n\nNote that `expr` here is a _supertype_ (not subtype) of `tuple_like` and `lvalue`.  If I wanted a case that was both tuple-like and an lvalue, I could do:\n\n```\nexpr both { ... }\nexpr tuple_like < both { ... }\nexpr lvalue < both { ... }\nexpr expr < lvalue, tuple_like { ... }\n```\n\nThis also neatly solves the problem of \"open enums\" that forced Scala to add `sealed`. Nifty.\n\nThis does imply subtyping between enums: but no solution to this problem gets around that.  (Refinement types will have subtyping relations based on their predicates)\n\nAnyway, this is a straw man.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693501/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693874",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3693874",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3693874,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTM4NzQ=",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T20:50:15Z",
    "updated_at": "2012-01-27T20:50:15Z",
    "body": "If I may ask to calm the conversation a bit; the third adjective in our language summary is \"practical\", so I don't want to consider scala as our target-to-beat. It's blown the user complexity budget several times over.\n\nWe have managed to avoid introducing general subtyping so far and I would like to continue trying to avoid it. Part of the purpose of the typestate system is to let off steam that would otherwise push us towards more-elaborate static reasoning and over-burdening the type system. Inference and exactness can remain out of reach; the motivated user can add `check` expressions to re-assert membership.\n\nFurther consideration of `if check` vs. `alt check` apparent \"asymmetry\" makes me think it's not really there, that `alt check` still makes good sense as a solution. If we consider `alt` as \"always exhaustive\", then leaving off an arm is always a _static_ error, in a way that omitting `else` from `if` simply isn't. So it makes sense to consider `alt check` as \"check-or-fail + exhaustive-conditional-branch\", in symmetry with `if check` meaning \"check-or-fail + nonexhaustive-conditional-branch\". We want `if` to always implicitly fall through, by default. We want `alt` to always implicitly not-fall-through. So they're already different. We'd just be preserving that difference between `if check` and `alt check`.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3693874/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3694317",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3694317",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3694317,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTQzMTc=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T21:18:39Z",
    "updated_at": "2012-01-27T21:18:39Z",
    "body": "@graydon (or anyone) -- any comment on separating the implementation of datasort refinements from the existing typestate mechanism (so that they can be used to eliminate checks)?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3694317/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3694806",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3694806",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3694806,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTQ4MDY=",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T21:50:33Z",
    "updated_at": "2012-01-27T21:50:33Z",
    "body": "Long story short: I would like to solve this problem.  If it can be done well through typestate I'm interested.  Otherwise, I think extensible enums seem promising.  I think both refined types and extensible enums are a form of subtyping and are more-or-less equivalent in that regard.\n\n> I don't want to consider scala as our target-to-beat\n\nI agree.  I just am not above borrowing a good idea.\n\n> We have managed to avoid introducing general subtyping so far and I would like to continue trying to avoid it. Part of the purpose of the typestate system is to let off steam that would otherwise push us towards more-elaborate static reasoning and over-burdening the type system. \n\nI don't understand how having subtyping only in refinements is not subtyping.\n\n> Inference and exactness can remain out of reach; the motivated user can add check expressions to re-assert membership.\n\nWhy is this any less true here?  The inference may not always pick the right thing.  Maybe you have to specify the type manually or write a \"downcast\" (let x = check x as tuple_like).  I mean, a check predicate is a downcast too.\n\nAll that said, I am sympathetic to wanting to use typestate to solve this problem so that we don't have too many tools in the toolshed.  I'd like to see a more specific proposal: I imagine we'd want to have special \"per-variant\" predicates and then some way to declare a predicate that says \"it's one of these 5 variants\".  These variant predicates would not be opaque to the compiler (unlike other predicates).  I haven't read up on the past work you cited; I will soon (bit busy right now).  I could imagine it being useful to have the dataflow propagation.\n\n@catamorphism I am not too worried about the soundness issue.  If you write a bogus `unchecked` predicate and then you end up with an exception about \"unhandled case\" in an alt statement that is supposedly exhaustive, I guess that's your problem.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3694806/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3695378",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3695378",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3695378,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTUzNzg=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T22:30:36Z",
    "updated_at": "2012-01-27T22:30:36Z",
    "body": "@nikomatsakis What I'm worried about with bogus predicates is the compiler taking advantage of knowledge about impossible cases, and generating code that results in a segfault if the predicates return misleading results.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3695378/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3695668",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3695668",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3695668,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTU2Njg=",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T22:50:06Z",
    "updated_at": "2012-01-27T22:50:06Z",
    "body": "@catamorphism Yes, I know.  That is something to keep in mind for sure.  I just mean that allowing us to prune down exhaustiveness checking will not, in and of itself, lead to seg faults.  I can imagine that other optimizations might.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3695668/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3695876",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3695876",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3695876,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTU4NzY=",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-27T23:06:03Z",
    "updated_at": "2012-01-27T23:06:03Z",
    "body": "@catamorphism A separate pass is plausible, I guess? Predicates are all supposed to be pure though. Redundant check  elimination ought equally well to apply to any predicate, if it's statically holding in the typestate of the check.\n\n@nikomatsakis \n\n> Why is this any less true here? The inference may not always pick the right thing. Maybe you have to specify the type manually or write a \"downcast\" (let x = check x as tuple_like). I mean, a check predicate is a downcast too.\n\nThis gets a bit language-theoretical, but I'll try to state my beliefs as concisely as possible. Sorry if they're a bit unorthodox. Mainly I disagree with the broadest interpretation of the phrase \"types are theorems\". I think it is a bit of an oversimplification of language technology. Types certainly _are_ theorems, but I think they're not just \"any old theorems\", and I think a \"type checker\" is not the right place to prove every theorem.\n\nSpecifically, the theorems I think \"belong\" in types are those that describe the correctness of _actual machine-level instructions_ such as arithmetic (are we operating on the right kind of number) and load/store (are we following pointers into dead memory). Correctness at _that_ level is usually plausible to build a type system for with very nice properties:\n- Decidable, fast\n- Gives comprehensible error messages\n- Mostly-inferable from terms, stays out of the way\n\nLots of type systems don't have those properties, but I think those languages are abusing their type systems and users often pay the price: by mixing \"nice\" and also _very_ necessary machine-representation questions (\"can I navigate the data structure\") with higher-level program-correctness issues that have been \"encoded\" into types. Everyone has some favourite haskell, ML, scala or C++ error messages they can mention from such delightful \"encoding\" of deeper semantic checks in the type system.\n\nI think the cost in program comprehensibility and compile time by mixing those issues into the type system is not the right balance, and it's better to add secondary layers of static analysis beyond the types. Even though in a strict Curry-Howard sense the secondary layers are just \"more types\", they're types that may be expressed through a completely different language-level UI (unordered predicate lists), inference and checking rules (flow-sensivity), set of manual overrides (runtime predicate-checks vs. reinterpret_cast) and error-reporting system.\n\nIMO those differences matter.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3695876/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3697617",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3697617",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3697617,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTc2MTc=",
    "user": {
      "login": "dherman",
      "id": 307871,
      "node_id": "MDQ6VXNlcjMwNzg3MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/307871?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dherman",
      "html_url": "https://github.com/dherman",
      "followers_url": "https://api.github.com/users/dherman/followers",
      "following_url": "https://api.github.com/users/dherman/following{/other_user}",
      "gists_url": "https://api.github.com/users/dherman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dherman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dherman/subscriptions",
      "organizations_url": "https://api.github.com/users/dherman/orgs",
      "repos_url": "https://api.github.com/users/dherman/repos",
      "events_url": "https://api.github.com/users/dherman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dherman/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-28T02:26:10Z",
    "updated_at": "2012-01-28T02:26:10Z",
    "body": "We should try to avoid debates getting too abstract in bug threads. Let's discuss feature concerns and proposals in our group meetings.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3697617/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3699009",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3699009",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3699009,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTkwMDk=",
    "user": {
      "login": "marijnh",
      "id": 144427,
      "node_id": "MDQ6VXNlcjE0NDQyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marijnh",
      "html_url": "https://github.com/marijnh",
      "followers_url": "https://api.github.com/users/marijnh/followers",
      "following_url": "https://api.github.com/users/marijnh/following{/other_user}",
      "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions",
      "organizations_url": "https://api.github.com/users/marijnh/orgs",
      "repos_url": "https://api.github.com/users/marijnh/repos",
      "events_url": "https://api.github.com/users/marijnh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marijnh/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-28T08:16:04Z",
    "updated_at": "2012-01-28T08:16:04Z",
    "body": "> I strongly disagree with @marijnh. I want to know when my alts are not exhaustive (it can be a warning, as long as we have -Werror :). Further, I want a way to prove to the type system that my alt IS in fact exhaustive,\n\nNeither of these conflict with my proposal, so maybe you just didn't read it very well.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3699009/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3701644",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3701644",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3701644,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MDE2NDQ=",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-28T16:43:04Z",
    "updated_at": "2012-01-28T16:43:58Z",
    "body": "> Neither of these conflict with my proposal, so maybe you just didn't read it very well.\n\nI read your proposal.  I'm not necessarily opposed to having some sort of way to say that an alt is intentionally non-exhaustive.  However, I think if we do our job right, it should be very rarely used.  Therefore, I am not sure that I want to make it easy to write non-exhaustive alts, I'd rather encourage people to use the type system and prove that those cases are impossible.\n\np.s., @graydon, I somehow missed your post regarding `alt check` before.  I guess you typed that while I was typing my post and I didn't refresh the github window.  Interesting idea.  I think I'd prefer it if `alt` and `alt check` behaved the same.  That is, both have exhaustiveness checking, and both fail if there is no matching arm.  That makes it more analogous to `if check`: it has the same behavior, it just says that you want the compiler to track the result.  If it is so painful to write `_ { fail }` or `_ {}`, we could consider marijn's proposal.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3701644/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3701933",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-3701933",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 3701933,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MDE5MzM=",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-01-28T17:26:32Z",
    "updated_at": "2012-01-28T17:26:32Z",
    "body": "Also, I don't see why we have to limit the forms of patterns that are allowed in an `alt check`, though it might make sense if the pattern guards had to be pure functions (or else allow `if check` in a pattern guard), so that they too could be added to the typestate.  Basically, if we allowed arbitrary patterns, we could still add some predicate regarding the \"top-level\" pattern.  That is:\n\n```\nalt check foo {\n    some(some(bar)) {\n        // adds a predicate foo | some(*)\n    }\n    some(none) {\n        // also adds a predicate foo | some(*)\n    }\n    none { ... }\n}\n```\n\nThat said, I think @dherman is probably right that we ought to continue this in another forum---which I am not respecting, sorry about that---and anyhow I'd like to let the various ideas sit for a bit.  So I'll stop writing now.  I am mostly just turning over this idea about `alt check` in my head and wanted to get some thoughts down before I run out the door.\n\nAnyway, I think the critical question is: \"Besides datasort refinements, what else do we plan to use typestate for?\" So far it hasn't seen much (productive) use, unfortunately.  If we do find that we use it for a lot, it probably makes sense to use it for datasorts as well.  If datasorts are all we use it for, I am not sure it's the simplest way to get these benefits.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/3701933/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7264524",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-7264524",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 7264524,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyNjQ1MjQ=",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-07-25T22:40:29Z",
    "updated_at": "2012-07-25T22:40:43Z",
    "body": "I see that I am a little late to the party.\n\nI won't comment on the various ways of dealing with nonexhaustiveness, but I think it is very important to have arbitrary refinements for subtyping enums, so the type system could let us match exhaustively when we want to match exhaustively on a subset of things.\n\n@nikomatsakis wrote:\n\n> ```\n> expr both { ... }\n> expr tuple_like < both { ... }\n> expr lvalue < both { ... }\n> expr expr < lvalue, tuple_like { ... }\n> ```\n\nI propose the following syntax, which allows you to write one definition per useful subset instead of one per intersection-of-subsets (2^n?). (said perhaps more intuitively: one per circle in a venn diagram, instead of one per area in a venn diagram.)\n\n```\nenum expr {\n        ex_tup(...),\n        ex_rec(...),\n        ex_path(...),\n        ex_index(...),\n        ex_tuple_lvalue(...),\n}\nenum tuple_like : expr { ex_tup, ex_rec, ex_tuple_lvalue }\nenum lvalue : expr { ex_path, ex_index, ex_tuple_lvalue }\n```\n\nAll you have to write in the refinements are the arms - no need to repeat the stuff they carry (since they have to be the same). If @pcwalton adds his case-class-y idea of having fields shared in all arms, you wouldn't need to write duplicates of that in the refinements either for the same reason.\n\nThe `:` syntax is a nod to C++ class inheritance, and hints strongly at the subtyping (hopefully in a way that will be intuitive even to people unfamiliar with disjunctive types).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7264524/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7264561",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-7264561",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 7264561,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyNjQ1NjE=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-07-25T22:42:22Z",
    "updated_at": "2012-07-25T22:42:22Z",
    "body": "I note that my \"once something of enum type is constructed, its tag is immutable\" comment in the OP is now obsolete -- if we implement this, it's going to have to deal with mutable algebraic data somehow (requiring refinement-typed things to be immutable is a totally reasonable way of dealing with it).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7264561/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7264883",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-7264883",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 7264883,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyNjQ4ODM=",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-07-25T22:59:22Z",
    "updated_at": "2012-07-25T23:10:44Z",
    "body": "For those who aren't convinced that the need for arbitrary-subset refinement comes up in practice, my motivation comes from a bug I had writing a C-like compiler in undergrad. Liveness analysis was done on an abstract assembly language, which looked like this (originally haskell, translated into rust).\n\n```\nenum Instruction {\n    BinExp(...),\n    Load(...),\n    Store(...),\n    Jump(...),\n    Call(...),\n    Return(...)\n}   \n\nfn usedVariables(inst: Instruction) -> ~[Variable] {\n    alt inst {\n        BinExp(_, t1, t2)   { ~[t1, t2] }\n        Store(_, t)         { ~[t] }\n        ...\n        ... more similar cases follow ...\n        ... \n        // All other instructions don't use any variables!\n        _                   { ~[] }\n    }   \n}   \n\nfn successorLines(inst: Instruction, linenr: uint) -> ~[uint] {\n    alt inst {\n        Jump(lbl)   { ~[lookupLabel(lbl)] }\n        Return(_)   { ~[] }\n        // All other instructions don't alter flow control.\n        _           { ~[linenr + 1] }\n    }   \n}   \n```\n\nIt wasn't until late in the project that I added `JumpCondition` as another arm in the language. Unfortunately the liveness code was in another file, and I missed adding cases for it in these functions because the catch-all prevented there from being a compiler error.\n\nWhat I really wanted was to get rid of the catch-all and replace it with arbitrary refinements, like this:\n\n```\nenum FlowControl : Instruction {\n    Jump, Return, JumpCondition\n}\nenum VariableUse : Instruction {\n    BinExp, Load, Store, Call, Return, JumpCondition\n}   \n```\n\nAlthough I will also note that I'd need some equivalent of `instanceof` to know whether to use the catch-all logic or not to begin with. On one hand, maybe i should've used an oo-like trait pattern. On another hand, maybe I could've written something like:\n\n```\nfn isFlowControl(instr: Instruction) -> option<FlowControl> {\n    alt instr {\n        x@Jump(*) | x@Return(*) | x@JumpCondition(*) { some(x) }\n        _ { none }\n    }\n}\n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7264883/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7264901",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-7264901",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 7264901,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyNjQ5MDE=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-07-25T23:00:35Z",
    "updated_at": "2012-07-25T23:00:35Z",
    "body": "It already comes up all the time in rustc, IMO -- every single `alt check` expression is a case where a refinement should really be used instead.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7264901/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7265495",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-7265495",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 7265495,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyNjU0OTU=",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-07-25T23:33:22Z",
    "updated_at": "2012-07-25T23:33:22Z",
    "body": "@catamorphism I am not sure what you meant by this:\n\n> I note that my \"once something of enum type is constructed, its tag is immutable\" comment in the OP is now obsolete  -- if we implement this, it's going to have to deal with mutable algebraic data somehow (requiring refinement-typed  things to be immutable is a totally reasonable way of dealing with it).\n\nI guess I am not sure what you mean by \"this\".  If we use the case class-like approach, in particular, this kind of correctness seems to just fall out of the standard soundness of the type system.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7265495/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7265513",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-7265513",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 7265513,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyNjU1MTM=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-07-25T23:34:39Z",
    "updated_at": "2012-07-25T23:34:39Z",
    "body": "@nikomatsakis By \"this\" I meant any sort of datasort refinements, but I guess I'm still not familiar with the case class proposal (has it been written up somewhere?), so I wasn't thinking of that approach in particular.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7265513/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7282537",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-7282537",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 7282537,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyODI1Mzc=",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-07-26T16:22:54Z",
    "updated_at": "2012-07-26T16:22:54Z",
    "body": "I'm more curious about how you would actually _use_ arbitrary-subset forms, not declare them. As in: what would the type checker infer for the `JumpCondition` constructor when used as an expression, a pattern, etc.? I suppose you'd be doing something like \"intersect all possible refinements for a given type variable and complain if there's more than one\"; but how does this scale across multiple crates if `JumpCondition` can randomly be included in new ones? Does it become a new thing the coherence check has to restrict? I.e. do we need to restrict it to only permit refining an `enum` inside the declaring crate?\n\nAlternatively, if it's really _just_ about missed pattern cases, you could have possibly gotten by with other mechanisms:\n\nMacros:\n\n```\n#macro([ #FlowControl(...), Jump(...) | Return(...) | JumpCondition(...) ])\n\nalt x {\n   ...\n   #FlowControl(*) { ... }\n}\n```\n\nPattern guards:\n\n```\nfn is_flowControl(instr: instruction) -> bool {\n    alt instr {\n        Jump(*) | Return(*) | JumpCondition(*) { true }\n        _ { false }\n    }\n}\n\nalt x {\n    ...\n    v if is_flowControl(v) { ... }\n    _ { ... }\n```\n\nThe former gets you static exhaustiveness checking, the latter gets you turing-complete refinements.\n\nAs far as the suggestion that all our current `alt check` cases are subsumed by this: that is simply not true. The point of `alt check` was to indicate _non-exhaustive_ `alt` in a way that involved less clutter than writing catchalls that do nothing more than fail, so that we could upgrade `alt` to be exhaustive by default. The non-exhaustiveness is not (from what I can tell) usually to do with the type not being specific enough, it's due to the expression's value being data-dependent, so not something we can pin-down fully into a type.\n\nI agree that, in general, the reason 'effectively-non-exhaustive\" `alt`s exist in the first place is that the type language can't encode enough information to \"push the check back further\", but that line _has to be drawn_ somewhere -- types are not turing complete and don't have access to the runtime environment for such minor details as \"all the data the program's behavior depends on\" -- so I'd suggest looking in detail at each of the `alt check` cases and trying to figure out how much \"further back\" a refinement would push the check. Hashtable contents? Results of a unification? Next character read from a stream? About the only ones I can see are the AST subset cases -- that is, the encodings for \"this has to be an lval\" and such -- and it's not clear to me that the _partial_ support for refinements @pcwalton proposed on IRC, that I asked @bblum to write up and compare with \"arbitrary refinements\" here, isn't enough.\n\nSince it didn't get written down above, here's what @pcwalton suggested on IRC:\n- Each `enum` constructor is, itself, a type. So a bunch of 1-member refinements all exist.\n- Each `enum` has a `struct` of common fields that are accessible in all values of the `enum` type, without `alt`-ing.\n\nThis combination lets you encode \"tree-shaped\" refinements, so to speak, by factoring your `enum` into a set of distinct sub-`enum`s, sharing fields whenever possible. It means you have to specify 1 ctor for each level of the \"refinement tree\" when constructing or pattern-matching, but you can use each of those levels as a type as well, if you want to \"push a check back\" to outside a function boundary and only handle a subset of cases. So it's sort of a middle ground. The user has to do more work and can express less, but the semantics are less complicated.\n\nI'm curious about an honest comparison between this and arbitrary-subsets. What's easy, what's hard. Try modeling cases that matter to you as each, see how they fare.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7282537/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7282881",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-7282881",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 7282881,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyODI4ODE=",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-07-26T16:34:10Z",
    "updated_at": "2012-07-26T16:34:24Z",
    "body": "I think @graydon summarized the situation pretty well.  I definitely agree that `alt check` (that is, non-exhaustive alts) will not be ruled out, though there will likely be fewer of them.\n\nFor what it's worth, in my PhD work I built a compiler in Scala which _does_ support arbitrary subset refinements.  They do this by using a `case class` system (in fact, they invented the term) combined with multiple inheritance (traits).  When we were initially discussing this, I thought that having support for arbitrary subsets was crucial: but when I looked back at my code, it turned out that every place where I had made use of arbitrary subsets had ultimately been converted to a tree shape.  This is not to claim that arbitrary subsets have no use, just that there are many more cases where things do form a hierarchy.  Of course, this is just one data point, and it was \"gradware\" to boot.  But perhaps if we want to get a better idea of what the expressive power and limitations are in real-world code, we should look to Scala projects and see what they do with it.  \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7282881/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7284433",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-7284433",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 7284433,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyODQ0MzM=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-07-26T17:27:24Z",
    "updated_at": "2012-07-26T17:27:24Z",
    "body": "@graydon Neither the macro nor the pattern-guard approach actually allows the compiler to omit checks safely, so far as I can see. (That is, even if you know you're matching on a `FlowControl` thing, either you or the compiler will have to include the `_` case anyhow.) So I think we could do better.\n\nI'd like to see a code example for the \"partial support for refinements\" proposal before I pass judgment on it.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7284433/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7294159",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-7294159",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 7294159,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyOTQxNTk=",
    "user": {
      "login": "graydon",
      "id": 14097,
      "node_id": "MDQ6VXNlcjE0MDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/graydon",
      "html_url": "https://github.com/graydon",
      "followers_url": "https://api.github.com/users/graydon/followers",
      "following_url": "https://api.github.com/users/graydon/following{/other_user}",
      "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/graydon/subscriptions",
      "organizations_url": "https://api.github.com/users/graydon/orgs",
      "repos_url": "https://api.github.com/users/graydon/repos",
      "events_url": "https://api.github.com/users/graydon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/graydon/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-07-26T23:54:52Z",
    "updated_at": "2012-07-26T23:54:52Z",
    "body": "@catamorphism the macro one would, assuming you mentioned enough subsets to totally cover the cases. And if you didn't, the compiler would tell you. That's why I said it gives static exhaustiveness checking. Of course the `if`-guarded one doesn't.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7294159/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7298286",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-7298286",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 7298286,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyOTgyODY=",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-07-27T06:08:57Z",
    "updated_at": "2012-07-27T06:08:57Z",
    "body": "@graydon Re: the macro one, I meant where you know `#FlowControl` describes something, so you want to leave out the other variants in the enum.\n\n(I'll confess that I'm not in a huge rush to implement anything that's been discussed on this page, so it doesn't seem like a pressing question. Unless someone else wants to do it.)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7298286/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/16828351",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-16828351",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 16828351,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2ODI4MzUx",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-04-22T22:35:35Z",
    "updated_at": "2013-04-22T22:35:35Z",
    "body": "I would still like to implement something along these lines, but not until after 1.0.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/16828351/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/16840047",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-16840047",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 16840047,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2ODQwMDQ3",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-04-23T05:26:24Z",
    "updated_at": "2013-04-23T05:26:24Z",
    "body": "I was taking a look at #2896, and then I ran across this bug which looked really similar. Most of this syntax/discussion far predates when I came into rust, but it looks to be mostly outdated now. It seems as if this issue boils down to what #2896 wants to do, and if so one of them should probably be closed.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/16840047/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/16840097",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-16840097",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 16840097,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2ODQwMDk3",
    "user": {
      "login": "catamorphism",
      "id": 427212,
      "node_id": "MDQ6VXNlcjQyNzIxMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/catamorphism",
      "html_url": "https://github.com/catamorphism",
      "followers_url": "https://api.github.com/users/catamorphism/followers",
      "following_url": "https://api.github.com/users/catamorphism/following{/other_user}",
      "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions",
      "organizations_url": "https://api.github.com/users/catamorphism/orgs",
      "repos_url": "https://api.github.com/users/catamorphism/repos",
      "events_url": "https://api.github.com/users/catamorphism/events{/privacy}",
      "received_events_url": "https://api.github.com/users/catamorphism/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-04-23T05:28:54Z",
    "updated_at": "2013-04-23T05:29:55Z",
    "body": "No, refinement types are different from pattern checking. The first one requires the programmer to make their intentions clear by writing their types differently. The second one is more about using fancy static analysis to let the programmer write something that _looks_ like it might fail with a non-exhaustive match error, but potentially doesn't. Both are useful, but both are wishlist items that aren't required for 1.0.\n\nIn other words, refinement types are about giving programmers the tools to express invariants and prove them to the compiler; whereas tools like Catch are about saying \"I know it's safe and I want the compiler to do the work of proving that.\"\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/16840097/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/20569335",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-20569335",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 20569335,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIwNTY5MzM1",
    "user": {
      "login": "emberian",
      "id": 704250,
      "node_id": "MDQ6VXNlcjcwNDI1MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emberian",
      "html_url": "https://github.com/emberian",
      "followers_url": "https://api.github.com/users/emberian/followers",
      "following_url": "https://api.github.com/users/emberian/following{/other_user}",
      "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emberian/subscriptions",
      "organizations_url": "https://api.github.com/users/emberian/orgs",
      "repos_url": "https://api.github.com/users/emberian/repos",
      "events_url": "https://api.github.com/users/emberian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emberian/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-07T11:22:07Z",
    "updated_at": "2013-07-07T11:22:07Z",
    "body": "@catamorphism is this still relevant even though typestate is gone?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/20569335/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/20573580",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-20573580",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 20573580,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIwNTczNTgw",
    "user": {
      "login": "bblum",
      "id": 1820515,
      "node_id": "MDQ6VXNlcjE4MjA1MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bblum",
      "html_url": "https://github.com/bblum",
      "followers_url": "https://api.github.com/users/bblum/followers",
      "following_url": "https://api.github.com/users/bblum/following{/other_user}",
      "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bblum/subscriptions",
      "organizations_url": "https://api.github.com/users/bblum/orgs",
      "repos_url": "https://api.github.com/users/bblum/repos",
      "events_url": "https://api.github.com/users/bblum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bblum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-07T16:54:43Z",
    "updated_at": "2013-07-07T16:54:43Z",
    "body": "This is a different feature from typestate.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/20573580/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/20573691",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-20573691",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 20573691,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIwNTczNjkx",
    "user": {
      "login": "emberian",
      "id": 704250,
      "node_id": "MDQ6VXNlcjcwNDI1MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emberian",
      "html_url": "https://github.com/emberian",
      "followers_url": "https://api.github.com/users/emberian/followers",
      "following_url": "https://api.github.com/users/emberian/following{/other_user}",
      "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emberian/subscriptions",
      "organizations_url": "https://api.github.com/users/emberian/orgs",
      "repos_url": "https://api.github.com/users/emberian/repos",
      "events_url": "https://api.github.com/users/emberian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emberian/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-07-07T17:02:49Z",
    "updated_at": "2013-07-07T17:02:49Z",
    "body": "Ah, reading the full thread this becomes obvious; I had glanced through some of the earlier comments that heavily involved typestate.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/20573691/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22455684",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-22455684",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 22455684,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNDU1Njg0",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-08-11T10:33:41Z",
    "updated_at": "2013-08-11T10:33:41Z",
    "body": "Here is my latest proposal for this, for reference:\n\nhttp://smallcultfollowing.com/babysteps/blog/2012/08/24/datasort-refinements/\n\nAlso, I've been thinking that this would be fairly straightforward to implement and may be worth the trouble. There are a few thorny special cases that would go away if we could give `None::<~int>` a different type from `Some(~3)`. For example, it'd be straightforward to make things like `[None::<~int>, ..2]` compile without error, whereas today you cannot handle this situation.\n\nOne concern I have is that while the design I laid out above is quite straightforward, it lacks the ability to parameterize types over the refinement. In other words, imagine I wanted to make a newtype'd option `struct MyOption<T>(Option<T>)`. I'd lose the ability to distinguish `MyOption(None)` from `MyOption(Some(x))`. However, I guess you can work around this by doing something like:\n\n```\nstruct MyOption_<T>(T)\ntype MyOption<T> = MyOption_<Option<T>> // usual case\ntype MyNone<T> = MyOption_<Option<T> {None}>\ntype MySone<T> = MyOption_<Option<T> {Some}>\n```\n\nInelegant but perhaps adequate in practice. Anyway, I wanted to get this (rather old at this point) blog post linked to the issue.    \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/22455684/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/42485244",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-42485244",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 42485244,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNDg1MjQ0",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-05-07T21:26:12Z",
    "updated_at": "2014-05-07T21:26:12Z",
    "body": "A change like this needs to go through the (relatively new) RFC process:\n\n  https://github.com/rust-lang/rfcs/\n\n(And it is actually possible that one of the existing RFC's may cover the use case(s) documented here.)\n\nI am closing this ticket; if anyone wants to revive the request for this feature, please write up a proper RFC for it.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/42485244/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/71593787",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-71593787",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 71593787,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcxNTkzNzg3",
    "user": {
      "login": "ftxqxd",
      "id": 2055302,
      "node_id": "MDQ6VXNlcjIwNTUzMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ftxqxd",
      "html_url": "https://github.com/ftxqxd",
      "followers_url": "https://api.github.com/users/ftxqxd/followers",
      "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}",
      "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions",
      "organizations_url": "https://api.github.com/users/ftxqxd/orgs",
      "repos_url": "https://api.github.com/users/ftxqxd/repos",
      "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ftxqxd/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-27T05:57:33Z",
    "updated_at": "2015-01-27T05:57:33Z",
    "body": "I think this issue should be moved to the RFCs repo (as an issue). cc @nick29581\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/71593787/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/71669082",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-71669082",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 71669082,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcxNjY5MDgy",
    "user": {
      "login": "steveklabnik",
      "id": 27786,
      "node_id": "MDQ6VXNlcjI3Nzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/steveklabnik",
      "html_url": "https://github.com/steveklabnik",
      "followers_url": "https://api.github.com/users/steveklabnik/followers",
      "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}",
      "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions",
      "organizations_url": "https://api.github.com/users/steveklabnik/orgs",
      "repos_url": "https://api.github.com/users/steveklabnik/repos",
      "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/steveklabnik/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-27T15:43:20Z",
    "updated_at": "2015-01-27T15:43:20Z",
    "body": "@P1start it's already been closed. As @pnkfelix says:\n\n>  if anyone wants to revive the request for this feature, please write up a proper RFC for it.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/71669082/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/71734283",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-71734283",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 71734283,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcxNzM0Mjgz",
    "user": {
      "login": "ftxqxd",
      "id": 2055302,
      "node_id": "MDQ6VXNlcjIwNTUzMDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ftxqxd",
      "html_url": "https://github.com/ftxqxd",
      "followers_url": "https://api.github.com/users/ftxqxd/followers",
      "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}",
      "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions",
      "organizations_url": "https://api.github.com/users/ftxqxd/orgs",
      "repos_url": "https://api.github.com/users/ftxqxd/repos",
      "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ftxqxd/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-27T21:45:34Z",
    "updated_at": "2015-01-27T21:45:34Z",
    "body": "@steveklabnik Yes, but it was closed before we started having issues in the RFCs repo. I am under the impression that issues that should have RFCs written for them (such as this one) should be open issues in the RFCs repo, not closed issues in rust-lang/rust.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/71734283/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/71857139",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-71857139",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 71857139,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcxODU3MTM5",
    "user": {
      "login": "steveklabnik",
      "id": 27786,
      "node_id": "MDQ6VXNlcjI3Nzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/steveklabnik",
      "html_url": "https://github.com/steveklabnik",
      "followers_url": "https://api.github.com/users/steveklabnik/followers",
      "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}",
      "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions",
      "organizations_url": "https://api.github.com/users/steveklabnik/orgs",
      "repos_url": "https://api.github.com/users/steveklabnik/repos",
      "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/steveklabnik/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-28T15:49:06Z",
    "updated_at": "2015-01-28T15:49:06Z",
    "body": "@P1start so, my thought process was basically \"It's not like we're gonna dig through all the old issues and move any one that's relevant over, let's wait until someone says something,\" but that ignores that, uh, here, you're basically saying something. So you're right. Sorry about that! \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/71857139/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/71857427",
    "html_url": "https://github.com/rust-lang/rust/issues/1679#issuecomment-71857427",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/1679",
    "id": 71857427,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcxODU3NDI3",
    "user": {
      "login": "steveklabnik",
      "id": 27786,
      "node_id": "MDQ6VXNlcjI3Nzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/steveklabnik",
      "html_url": "https://github.com/steveklabnik",
      "followers_url": "https://api.github.com/users/steveklabnik/followers",
      "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}",
      "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions",
      "organizations_url": "https://api.github.com/users/steveklabnik/orgs",
      "repos_url": "https://api.github.com/users/steveklabnik/repos",
      "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/steveklabnik/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-28T15:50:30Z",
    "updated_at": "2015-01-28T15:50:30Z",
    "body": "I'm pulling a massive triage effort to get us ready for 1.0. As part of this, I'm moving stuff that's wishlist-like to the RFCs repo, as that's where major new things should get discussed/prioritized.\n\nThis issue has been moved to the RFCs repo: rust-lang/rfcs#754\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/71857427/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
