[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/104058876",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-104058876",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 104058876,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNDA1ODg3Ng==",
    "user": {
      "login": "lilyball",
      "id": 714,
      "node_id": "MDQ6VXNlcjcxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lilyball",
      "html_url": "https://github.com/lilyball",
      "followers_url": "https://api.github.com/users/lilyball/followers",
      "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
      "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
      "organizations_url": "https://api.github.com/users/lilyball/orgs",
      "repos_url": "https://api.github.com/users/lilyball/repos",
      "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lilyball/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-20T22:16:16Z",
    "updated_at": "2015-05-20T22:16:16Z",
    "body": "If `RefCell` were changed to poison itself on panic, would that fix this issue? Immutable TLS isn't a problem, and offhand I believe that mutable TLS requires either `RefCell` or some inter-thread data primitive (such as `Mutex`, which already handles this case).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/104058876/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/104112415",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-104112415",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 104112415,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNDExMjQxNQ==",
    "user": {
      "login": "steveklabnik",
      "id": 27786,
      "node_id": "MDQ6VXNlcjI3Nzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/steveklabnik",
      "html_url": "https://github.com/steveklabnik",
      "followers_url": "https://api.github.com/users/steveklabnik/followers",
      "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}",
      "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions",
      "organizations_url": "https://api.github.com/users/steveklabnik/orgs",
      "repos_url": "https://api.github.com/users/steveklabnik/repos",
      "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/steveklabnik/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-21T03:20:45Z",
    "updated_at": "2015-05-21T03:20:45Z",
    "body": "/cc @alexcrichton \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/104112415/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/104331163",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-104331163",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 104331163,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNDMzMTE2Mw==",
    "user": {
      "login": "Stebalien",
      "id": 310393,
      "node_id": "MDQ6VXNlcjMxMDM5Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/310393?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Stebalien",
      "html_url": "https://github.com/Stebalien",
      "followers_url": "https://api.github.com/users/Stebalien/followers",
      "following_url": "https://api.github.com/users/Stebalien/following{/other_user}",
      "gists_url": "https://api.github.com/users/Stebalien/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Stebalien/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Stebalien/subscriptions",
      "organizations_url": "https://api.github.com/users/Stebalien/orgs",
      "repos_url": "https://api.github.com/users/Stebalien/repos",
      "events_url": "https://api.github.com/users/Stebalien/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Stebalien/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-21T15:59:09Z",
    "updated_at": "2015-05-21T15:59:09Z",
    "body": "@kballard I'm not entirely convinced that would be safe but I can't prove it unsafe either. In the multithreaded case, data protected by a lock must not violate any invariants any time the lock isn't held because one generally can't make statements about the state of other threads. However, in single threaded environments one can reasonably make scope-based invariants. For example, my [horrorshow](/Stebalien/horrorshow-rs) template macro emulates scoped TLS as follows:\n\n`````` rust\npub fn __with_template_reentrant<F: FnMut(&mut Template)>(mut f: F) {\n    // The scoped variant is unstable so we do this ourselves...\n    __TEMPLATE.with(|template| {\n        let mut local_template = None;\n        ::std::mem::swap(&mut *template.borrow_mut(), &mut local_template);\n        (f)(local_template.as_mut().unwrap());\n        ::std::mem::swap(&mut *template.borrow_mut(), &mut local_template);\n    });\n}```\n\nIf the last swap isn't run, the invariant is violated and my library will likely panic at some future point.\n\n\nHowever, this example doesn't violate memory safety and I can't find a way to do so without using `unsafe`.\n``````\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/104331163/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/104370773",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-104370773",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 104370773,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNDM3MDc3Mw==",
    "user": {
      "login": "lilyball",
      "id": 714,
      "node_id": "MDQ6VXNlcjcxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lilyball",
      "html_url": "https://github.com/lilyball",
      "followers_url": "https://api.github.com/users/lilyball/followers",
      "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
      "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
      "organizations_url": "https://api.github.com/users/lilyball/orgs",
      "repos_url": "https://api.github.com/users/lilyball/repos",
      "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lilyball/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-21T17:53:04Z",
    "updated_at": "2015-05-21T17:53:04Z",
    "body": "@Stebalien You're effectively poisoning the TLS value while that code is being run. If the thread panics and avoids the last `swap`, a subsequent attempt to access it will panic. And that's perfectly fine (although you might want to consider the idea of explicit poisoning so you can let the user detect this case without panicking). Panicking is not memory unsafety.\n\nIn the case of `RefCell`, a panic will run the destructors on the extant borrows, which will return the `RefCell` to the unborrowed state, but the value it contains may be violating invariants (in a manner that can lead to memory unsafety). This is the same issue that `Mutex` had, which is why `Mutex` poisons itself if the thread panics while a lock is held. `RefCell` doesn't have poisoning because it can't be shared between multiple threads without some thread synchronization primitive (e.g. `Mutex`). But `std::thread::catch_panic()` plus TLS does give rise to the same situation.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/104370773/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/104370825",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-104370825",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 104370825,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNDM3MDgyNQ==",
    "user": {
      "login": "bluss",
      "id": 3209739,
      "node_id": "MDQ6VXNlcjMyMDk3Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bluss",
      "html_url": "https://github.com/bluss",
      "followers_url": "https://api.github.com/users/bluss/followers",
      "following_url": "https://api.github.com/users/bluss/following{/other_user}",
      "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bluss/subscriptions",
      "organizations_url": "https://api.github.com/users/bluss/orgs",
      "repos_url": "https://api.github.com/users/bluss/repos",
      "events_url": "https://api.github.com/users/bluss/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bluss/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-21T17:53:19Z",
    "updated_at": "2015-05-21T17:53:19Z",
    "body": "Can't you use the binaryheap again? It was used to show unsoundness off thread scoped (the first time)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/104370825/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105041460",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-105041460",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 105041460,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNTA0MTQ2MA==",
    "user": {
      "login": "bluss",
      "id": 3209739,
      "node_id": "MDQ6VXNlcjMyMDk3Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bluss",
      "html_url": "https://github.com/bluss",
      "followers_url": "https://api.github.com/users/bluss/followers",
      "following_url": "https://api.github.com/users/bluss/following{/other_user}",
      "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bluss/subscriptions",
      "organizations_url": "https://api.github.com/users/bluss/orgs",
      "repos_url": "https://api.github.com/users/bluss/repos",
      "events_url": "https://api.github.com/users/bluss/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bluss/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-24T17:37:52Z",
    "updated_at": "2015-05-25T11:25:59Z",
    "body": "Ok, so I put myself to work since it was my suggestion.\n\nDo you remember soundness issue **the first time** with std::thread::scoped (issue  #20807) and why we made it stop catching panics? The following is (possibly?) a reason: It allows violating invariants in a type, and still go back to using that same value.\n\nThe following code example segfaults in safe rust. I'm using a mutex and ignoring poison (this is safe rust). I think we have other ways to share memory that would avoid mutex altogether, so I think we can probably ignore mutex in the discussion(?).\n\n**Note: This segfault works just as well with thread::spawn!**\n\nrustc version: rustc 1.2.0-nightly (0cc99f9cc 2015-05-17) (built 2015-05-18)\n\n[(playpen link)](https://play.rust-lang.org/?gist=5b0f1a5aedbaaf62d38b&version=nightly)\n\n``` rust\n#![feature(catch_panic, collections, std_misc)]\nuse std::cmp::Ordering;\nuse std::collections::BinaryHeap;\nuse std::collections::BTreeSet;\nuse std::thread;\nuse std::sync::{Arc, Mutex};\n\n#[derive(PartialEq, Eq, Ord, Debug, Clone)]\nstruct Panicker<T>(T);\n\nimpl<T: PartialEq> PartialOrd for Panicker<T>\n{\n    fn partial_cmp(&self, _: &Self) -> Option<Ordering>\n    {\n        panic!()\n    }\n}\n\nfn main() {\n    let heap = Arc::new(Mutex::new(BinaryHeap::new()));\n    let heap_ref = heap.clone();\n    let guard = thread::catch_panic(move || {\n        let mut local_heap = heap.lock().unwrap();\n        local_heap.push(Panicker(BTreeSet::<i32>::new()));\n        local_heap.push(Panicker(BTreeSet::<i32>::new()));\n    });\n    println!(\"Thread result: {:?}\", guard);\n\n    let mutex_guard = match heap_ref.lock() {\n        Ok(inner) => inner,\n        Err(e) => e.into_inner(),\n    };\n\n    let vector_from_binary_heap = mutex_guard.clone().into_vec();\n    println!(\"{:?}\", vector_from_binary_heap);\n}\n```\n\nQ: Why use BTreeSet as the element type?  \nA: BinaryHeap will mark an element as dropped (zeroing or filling) before starting its sift down algorithm and comparing values. We catch the panic to get the binaryheap in this state. BTreeSet is used for a value that we know is really corrupted / memory unsafe when used in zeroed/filled state.\n\nYou have to ask the question: Is it catching panics or BinaryHeap that is broken? If we fix BinaryHeap, what other type invariants can we break for fun & unsoundness?\n\nEdit: as tomaka says below, is it _ignoring poisoning_ that is unsafe?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105041460/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105042715",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-105042715",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 105042715,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNTA0MjcxNQ==",
    "user": {
      "login": "bluss",
      "id": 3209739,
      "node_id": "MDQ6VXNlcjMyMDk3Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bluss",
      "html_url": "https://github.com/bluss",
      "followers_url": "https://api.github.com/users/bluss/followers",
      "following_url": "https://api.github.com/users/bluss/following{/other_user}",
      "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bluss/subscriptions",
      "organizations_url": "https://api.github.com/users/bluss/orgs",
      "repos_url": "https://api.github.com/users/bluss/repos",
      "events_url": "https://api.github.com/users/bluss/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bluss/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-24T17:51:42Z",
    "updated_at": "2015-05-24T17:51:42Z",
    "body": "Time to call in the cavalry, cc @nikomatsakis @aturon \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105042715/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105042980",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-105042980",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 105042980,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNTA0Mjk4MA==",
    "user": {
      "login": "bluss",
      "id": 3209739,
      "node_id": "MDQ6VXNlcjMyMDk3Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bluss",
      "html_url": "https://github.com/bluss",
      "followers_url": "https://api.github.com/users/bluss/followers",
      "following_url": "https://api.github.com/users/bluss/following{/other_user}",
      "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bluss/subscriptions",
      "organizations_url": "https://api.github.com/users/bluss/orgs",
      "repos_url": "https://api.github.com/users/bluss/repos",
      "events_url": "https://api.github.com/users/bluss/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bluss/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-24T17:57:51Z",
    "updated_at": "2015-05-24T17:57:51Z",
    "body": "oh and cc @tomaka\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105042980/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105045017",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-105045017",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 105045017,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNTA0NTAxNw==",
    "user": {
      "login": "tomaka",
      "id": 1412254,
      "node_id": "MDQ6VXNlcjE0MTIyNTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1412254?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tomaka",
      "html_url": "https://github.com/tomaka",
      "followers_url": "https://api.github.com/users/tomaka/followers",
      "following_url": "https://api.github.com/users/tomaka/following{/other_user}",
      "gists_url": "https://api.github.com/users/tomaka/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tomaka/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tomaka/subscriptions",
      "organizations_url": "https://api.github.com/users/tomaka/orgs",
      "repos_url": "https://api.github.com/users/tomaka/repos",
      "events_url": "https://api.github.com/users/tomaka/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tomaka/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-24T18:07:37Z",
    "updated_at": "2015-05-24T18:07:48Z",
    "body": "`std::sync::PoisonError::into_inner()` should definitely be unsafe.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105045017/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105046031",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-105046031",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 105046031,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNTA0NjAzMQ==",
    "user": {
      "login": "bluss",
      "id": 3209739,
      "node_id": "MDQ6VXNlcjMyMDk3Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bluss",
      "html_url": "https://github.com/bluss",
      "followers_url": "https://api.github.com/users/bluss/followers",
      "following_url": "https://api.github.com/users/bluss/following{/other_user}",
      "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bluss/subscriptions",
      "organizations_url": "https://api.github.com/users/bluss/orgs",
      "repos_url": "https://api.github.com/users/bluss/repos",
      "events_url": "https://api.github.com/users/bluss/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bluss/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-24T18:24:47Z",
    "updated_at": "2015-05-24T18:24:47Z",
    "body": "I want to be sure we solve the fundamental issues and don't just patch the holes in an unsound bag. I don't know which of the two categories ignoring poisoning belongs to.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105046031/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105046903",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-105046903",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 105046903,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNTA0NjkwMw==",
    "user": {
      "login": "tomaka",
      "id": 1412254,
      "node_id": "MDQ6VXNlcjE0MTIyNTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1412254?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tomaka",
      "html_url": "https://github.com/tomaka",
      "followers_url": "https://api.github.com/users/tomaka/followers",
      "following_url": "https://api.github.com/users/tomaka/following{/other_user}",
      "gists_url": "https://api.github.com/users/tomaka/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tomaka/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tomaka/subscriptions",
      "organizations_url": "https://api.github.com/users/tomaka/orgs",
      "repos_url": "https://api.github.com/users/tomaka/repos",
      "events_url": "https://api.github.com/users/tomaka/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tomaka/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-24T18:40:44Z",
    "updated_at": "2015-05-24T19:02:38Z",
    "body": "The golden rule is that when a panic occurs, any object that is mutably borrowed must no longer be used in the future (except for its destructor) because its internal state is possibly messed up.\n\nRust cleans up local variables inside the closure passed to `catch_panic` and `spawn`, so the only problem comes when accessing variables from the outside:\n- References/mutable references.\n- `Rc`/`Arc`. (`Gc` in the future?)\n- Anything static or static-like such as thread local storage.\n- Raw pointers, but these are unsafe anyway so we don't care.\n\nReferences are explicitely forbidden because the closure is required to be `Send` and `'static` (by the way I don't see why `Send` is required for `catch_panic`, but I may be missing something).\n\nOnly `Rc`, `Arc` and statics are problematic, but they only allow immutable access to their content. Therefore the problem lies in types that allow interior mutability: `Cell`, `RefCell`, `Mutex`, `Atomic`. \n`Cell` and `Atomic` can't panic during their mutations, and `RefCell` and `Mutex` use/should use poisoning.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105046903/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105047350",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-105047350",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 105047350,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNTA0NzM1MA==",
    "user": {
      "login": "tomaka",
      "id": 1412254,
      "node_id": "MDQ6VXNlcjE0MTIyNTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1412254?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tomaka",
      "html_url": "https://github.com/tomaka",
      "followers_url": "https://api.github.com/users/tomaka/followers",
      "following_url": "https://api.github.com/users/tomaka/following{/other_user}",
      "gists_url": "https://api.github.com/users/tomaka/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tomaka/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tomaka/subscriptions",
      "organizations_url": "https://api.github.com/users/tomaka/orgs",
      "repos_url": "https://api.github.com/users/tomaka/repos",
      "events_url": "https://api.github.com/users/tomaka/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tomaka/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-24T18:47:53Z",
    "updated_at": "2015-05-24T19:00:19Z",
    "body": "One thing that I neglected in the previous post are destructors. Maybe with a lot of hacky (but safe) code it could possible to trigger a crash by writing a destructor that is being run during a panic (that's just a supposition, I have absolutely no idea how). Destructors are some kind of gray area when it comes to exception-safety.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105047350/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105047830",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-105047830",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 105047830,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNTA0NzgzMA==",
    "user": {
      "login": "tomaka",
      "id": 1412254,
      "node_id": "MDQ6VXNlcjE0MTIyNTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1412254?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tomaka",
      "html_url": "https://github.com/tomaka",
      "followers_url": "https://api.github.com/users/tomaka/followers",
      "following_url": "https://api.github.com/users/tomaka/following{/other_user}",
      "gists_url": "https://api.github.com/users/tomaka/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tomaka/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tomaka/subscriptions",
      "organizations_url": "https://api.github.com/users/tomaka/orgs",
      "repos_url": "https://api.github.com/users/tomaka/repos",
      "events_url": "https://api.github.com/users/tomaka/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tomaka/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-24T18:59:55Z",
    "updated_at": "2015-05-24T19:01:50Z",
    "body": "This problem is really specific to TLS, because `RefCells` can't be put inside `Arcs` and that `thread::spawn` requires a closure that implements `Send`.\n\nThat's probably the reason why `catch_panic` requires `Send` as well, but it didn't account for TLS.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105047830/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105051024",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-105051024",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 105051024,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNTA1MTAyNA==",
    "user": {
      "login": "bluss",
      "id": 3209739,
      "node_id": "MDQ6VXNlcjMyMDk3Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bluss",
      "html_url": "https://github.com/bluss",
      "followers_url": "https://api.github.com/users/bluss/followers",
      "following_url": "https://api.github.com/users/bluss/following{/other_user}",
      "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bluss/subscriptions",
      "organizations_url": "https://api.github.com/users/bluss/orgs",
      "repos_url": "https://api.github.com/users/bluss/repos",
      "events_url": "https://api.github.com/users/bluss/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bluss/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-24T19:12:42Z",
    "updated_at": "2015-05-24T19:12:42Z",
    "body": "For completeness, the [TLS + RefCell version](https://play.rust-lang.org/?gist=5a3e9dbd66f2a9b5ae15&version=nightly) of the same segfault.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105051024/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105761252",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-105761252",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 105761252,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNTc2MTI1Mg==",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-27T05:20:51Z",
    "updated_at": "2015-05-27T05:20:51Z",
    "body": "@tbu- can you clarify what you're looking for in this issue? There's discussion about referencing `RefCell` after the thread has already panicked, and I just want to make sure we're all on the same page.\n\n---\n\n@kballard \n\n> If RefCell were changed to poison itself on panic, would that fix this issue?\n\nIt's currently an explicit design decision that `RefCell` is _not_ poisoned like mutexes. The rationale behind this being that a panic propagation across threads can not be detected _without_ poisoning, but within a thread it can be detected via other means. This rationale did predate `catch_panic`, however.\n\n---\n\n@bluss \n\n> Is it catching panics or BinaryHeap that is broken?\n\nLooks like the implementation of BinaryHeap is the one at fault here, it is not panic-safe.\n\n---\n\n@tomaka \n\n> std::sync::PoisonError::into_inner() should definitely be unsafe.\n\nIt's a fundamental part of poisoning that this is **not** unsafe. It is only possible to break memory safety as a part of panic safety with `unsafe` code, if there is no `unsafe` code then all code is automatically panic-safe. As a result a poison error is simply an indication that a panic happened, which _much_ of the time means a bug, but sometimes it can be safely ignored.\n\n> The golden rule is that when a panic occurs, any object that is mutably borrowed must no longer be used in the future (except for its destructor) because its internal state is possibly messed up.\n\nThis is only true for for unsafe code, safe code can only have logical invariants violated.\n\n> by the way I don't see why Send is required for catch_panic, but I may be missing something\n\nThe precise bounds for this API are a little squishy (hence the instability), but the goal was to prevent unnecessary leakage of accidental vectors of panic safety. It was thought that the bounds can be dropped possibly if good rationale comes up in the future.\n\n> That's probably the reason why catch_panic requires Send as well, but it didn't account for TLS.\n\nYes, TLS did not come up much in the initial discussions of `catch_panic`\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105761252/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105766606",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-105766606",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 105766606,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNTc2NjYwNg==",
    "user": {
      "login": "tomaka",
      "id": 1412254,
      "node_id": "MDQ6VXNlcjE0MTIyNTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1412254?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tomaka",
      "html_url": "https://github.com/tomaka",
      "followers_url": "https://api.github.com/users/tomaka/followers",
      "following_url": "https://api.github.com/users/tomaka/following{/other_user}",
      "gists_url": "https://api.github.com/users/tomaka/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tomaka/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tomaka/subscriptions",
      "organizations_url": "https://api.github.com/users/tomaka/orgs",
      "repos_url": "https://api.github.com/users/tomaka/repos",
      "events_url": "https://api.github.com/users/tomaka/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tomaka/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-27T05:55:57Z",
    "updated_at": "2015-05-27T08:03:43Z",
    "body": "> It is only possible to break memory safety as a part of panic safety with unsafe code, if there is no unsafe code then all code is automatically panic-safe.\n\nOn one hand several changes have to been made to help unsafe code writers: forbidding transmuting `&self` to `&mut self`, removing the `Send`/`Sync` implementations from raw pointers, tying the lifetime of a slice produced from a raw pointer to the lifetime of the pointer, etc.\n\nOn the other hand, failure to write panic-safe code should be blamed on the writer?\nOne of the reasons why critical code is written in C and not C++ is because C doesn't have exceptions, and exception-safey is **awefully hard** to do right.\nI know that the idea behind Rust is that any unsafe code should be carefully auditted, but this is almost impossible to do right, and without even looking I'm sure that there are panic-safety-related bugs in most unsafe code of the stdlib.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105766606/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105808301",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-105808301",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 105808301,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNTgwODMwMQ==",
    "user": {
      "login": "bluss",
      "id": 3209739,
      "node_id": "MDQ6VXNlcjMyMDk3Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bluss",
      "html_url": "https://github.com/bluss",
      "followers_url": "https://api.github.com/users/bluss/followers",
      "following_url": "https://api.github.com/users/bluss/following{/other_user}",
      "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bluss/subscriptions",
      "organizations_url": "https://api.github.com/users/bluss/orgs",
      "repos_url": "https://api.github.com/users/bluss/repos",
      "events_url": "https://api.github.com/users/bluss/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bluss/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-27T07:57:25Z",
    "updated_at": "2015-05-27T07:57:25Z",
    "body": "@alexcrichton BinaryHeap hasn't even been updated from zeroing to filling drop.. This is super broken!\n\nIf we choose to blame this particular location in libstd\n- That means we have a memory safety bug in 1.0 -- and why wasn't it fixed the first time it was pointed out?\n- You are implying that  #20807 was overblown and not an issue\n- We need to keep looking for type invariants that will break memory safety when broken. I'll try to help there.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/105808301/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/106475860",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-106475860",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 106475860,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNjQ3NTg2MA==",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-28T16:41:45Z",
    "updated_at": "2015-05-28T16:41:45Z",
    "body": "@tomaka \n\n> On the other hand, failure to write panic-safe code should be blamed on the writer?\n\nNote that like the abstractions of `Send` and `Sync` being removed from raw pointers, we strive to have you _opt-in_ to extra features (e.g. explicitly requiring the marker trait annotations) for unsafe code, but we still allow it to happen. Another example is how for poisoning you have to opt-in to ignoring remote panics.\n\n> without even looking I'm sure that there are panic-safety-related bugs in most unsafe code of the stdlib.\n\nWhatever the outcome of this bug is, however, this isn't super relevant as they all need to be fixed regardless.\n\n---\n\n@bluss \n\n> That means we have a memory safety bug in 1.0 -- and why wasn't it fixed the first time it was pointed out?\n\nWe're all quite busy and things fall under the radar from time to time, it's not like we all sat down at a table and decided that a memory safety bug in BinaryHeap was OK to make it into 1.0.\n\n> You are implying that #20807 was overblown and not an issue\n\nI mean only to clarify what the outcome of the issue was. We definitely realize that exception safety is a problem for `unsafe` code, but this is not an issue that can just be ignored by sweeping it under an `unsafe` rug, it _always_ needs to be dealt with no matter what.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/106475860/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/106563653",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-106563653",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 106563653,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNjU2MzY1Mw==",
    "user": {
      "login": "bluss",
      "id": 3209739,
      "node_id": "MDQ6VXNlcjMyMDk3Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bluss",
      "html_url": "https://github.com/bluss",
      "followers_url": "https://api.github.com/users/bluss/followers",
      "following_url": "https://api.github.com/users/bluss/following{/other_user}",
      "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bluss/subscriptions",
      "organizations_url": "https://api.github.com/users/bluss/orgs",
      "repos_url": "https://api.github.com/users/bluss/repos",
      "events_url": "https://api.github.com/users/bluss/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bluss/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-28T18:46:19Z",
    "updated_at": "2015-05-28T18:46:38Z",
    "body": "I was apparently not on the same page. I think it sounds good that we tackle exception safety head on, but it seems to be a different kind of direction than what [#20807 concluded](https://github.com/rust-lang/rust/issues/20807#issuecomment-74574828).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/106563653/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/106574018",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-106574018",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 106574018,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNjU3NDAxOA==",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-28T19:31:15Z",
    "updated_at": "2015-05-28T19:31:15Z",
    "body": "I pretty much agree with what @alexcrichton said, and I think that was my takeaway from #20807 as well. That is, exception safety is \"still a thing\" -- but we do our best to minimize its impact on your life, particularly if you are not developing unsafe code. We opted to change the API for #20807 not because we believed it would render exception safety unnecessary, but because the current API was effectively adding an (ineffecient, but otherwise relatively usable) \"catch\" keyword to the language, which wasn't really the intention. (If we want catch, we should just add _catch_.) This is also the intention of poisoning mutexes (but letting you bypass it). It is not intended to absolutely prevent you from obtaining bad data, but it does make you think about it at least. \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/106574018/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/106577548",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-106577548",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 106577548,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNjU3NzU0OA==",
    "user": {
      "login": "bluss",
      "id": 3209739,
      "node_id": "MDQ6VXNlcjMyMDk3Mzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bluss",
      "html_url": "https://github.com/bluss",
      "followers_url": "https://api.github.com/users/bluss/followers",
      "following_url": "https://api.github.com/users/bluss/following{/other_user}",
      "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bluss/subscriptions",
      "organizations_url": "https://api.github.com/users/bluss/orgs",
      "repos_url": "https://api.github.com/users/bluss/repos",
      "events_url": "https://api.github.com/users/bluss/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bluss/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-05-28T19:49:51Z",
    "updated_at": "2015-05-28T19:49:51Z",
    "body": "Ok. I'll just say, total days during which binaryheap was known to be broken: 1 single day*.\n\n*<sup>Known defined as having bug reported</sup> \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/106577548/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216051086",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-216051086",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 216051086,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxNjA1MTA4Ng==",
    "user": {
      "login": "lhecker",
      "id": 2256941,
      "node_id": "MDQ6VXNlcjIyNTY5NDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2256941?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lhecker",
      "html_url": "https://github.com/lhecker",
      "followers_url": "https://api.github.com/users/lhecker/followers",
      "following_url": "https://api.github.com/users/lhecker/following{/other_user}",
      "gists_url": "https://api.github.com/users/lhecker/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lhecker/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lhecker/subscriptions",
      "organizations_url": "https://api.github.com/users/lhecker/orgs",
      "repos_url": "https://api.github.com/users/lhecker/repos",
      "events_url": "https://api.github.com/users/lhecker/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lhecker/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-05-01T15:45:06Z",
    "updated_at": "2016-05-01T15:47:35Z",
    "body": "@alexcrichton We (@zonyitoo and me) noticed another issue with the current behaviour of `std::panic::catch_unwind`: It assumes that the smallest \"scope\" in which something can be processed is a thread. Which is why it uses a thread-local variable to count the current number of \"active\" unwinds, right?\nBut what if you have a smaller scope like... coroutines? A coroutine can migrate between threads (using e.g. a work stealing scheduler). The `PANIC_COUNT` however is thread-local, while for coroutines it would be \"coroutine-local\". For instance `catch_unwind(func)` might be called in one thread while `func` completes under another one. At this point the wrong `PANIC_COUNT` (from the original thread) will be set to a invalid value without any synchronization primitives.\nWill this be fixed one day in Rust (since it does work in C++), or will this forever be broken, under the assumption that there are no userland-threads? Because that would be quite sad. :cry: \n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216051086/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216053585",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-216053585",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 216053585,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxNjA1MzU4NQ==",
    "user": {
      "login": "zonyitoo",
      "id": 1067951,
      "node_id": "MDQ6VXNlcjEwNjc5NTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1067951?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zonyitoo",
      "html_url": "https://github.com/zonyitoo",
      "followers_url": "https://api.github.com/users/zonyitoo/followers",
      "following_url": "https://api.github.com/users/zonyitoo/following{/other_user}",
      "gists_url": "https://api.github.com/users/zonyitoo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zonyitoo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zonyitoo/subscriptions",
      "organizations_url": "https://api.github.com/users/zonyitoo/orgs",
      "repos_url": "https://api.github.com/users/zonyitoo/repos",
      "events_url": "https://api.github.com/users/zonyitoo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zonyitoo/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-05-01T16:26:22Z",
    "updated_at": "2016-05-01T16:26:22Z",
    "body": "There is one easy solution for this: Don't allow panic in `Drop::drop`!\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216053585/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216053980",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-216053980",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 216053980,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxNjA1Mzk4MA==",
    "user": {
      "login": "lhecker",
      "id": 2256941,
      "node_id": "MDQ6VXNlcjIyNTY5NDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2256941?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lhecker",
      "html_url": "https://github.com/lhecker",
      "followers_url": "https://api.github.com/users/lhecker/followers",
      "following_url": "https://api.github.com/users/lhecker/following{/other_user}",
      "gists_url": "https://api.github.com/users/lhecker/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lhecker/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lhecker/subscriptions",
      "organizations_url": "https://api.github.com/users/lhecker/orgs",
      "repos_url": "https://api.github.com/users/lhecker/repos",
      "events_url": "https://api.github.com/users/lhecker/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lhecker/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-05-01T16:33:10Z",
    "updated_at": "2016-05-01T16:40:00Z",
    "body": "Preventing panics in `drop()` is akin to how C++ works...\n\nThe only alternative I see right now is to introduce some additional API which allows us to \"register a stack\". We could pass a callback to that register method which could be invoked whenever the panic & unwind modules need the panic count. What is at the momen the thread-local `PANIC_COUNT` would serve as the default handler in `std::thread::Builder::spawn()`.\nThus in coroutine implementations a custom handler could be passed. This handler could query the currently executing coroutine on the current thread and poll it's own panic count.\n\nIMHO this would be the least intrusive and most flexible approach right now. Closing down Rust to only support threads and nothing more seems to me like an unnecessary limitation though.\nAny opinions on that? I'd value especially yours, @alexcrichton.\n\nApart from that I think there are only 2 solutions: One of which would be to adapt the C++ model and the other would be to have \"stack-local\" instead of \"thread-local\" data.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216053980/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216055742",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-216055742",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 216055742,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxNjA1NTc0Mg==",
    "user": {
      "login": "sfackler",
      "id": 1455697,
      "node_id": "MDQ6VXNlcjE0NTU2OTc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sfackler",
      "html_url": "https://github.com/sfackler",
      "followers_url": "https://api.github.com/users/sfackler/followers",
      "following_url": "https://api.github.com/users/sfackler/following{/other_user}",
      "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions",
      "organizations_url": "https://api.github.com/users/sfackler/orgs",
      "repos_url": "https://api.github.com/users/sfackler/repos",
      "events_url": "https://api.github.com/users/sfackler/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sfackler/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-05-01T17:06:10Z",
    "updated_at": "2016-05-01T17:06:10Z",
    "body": "@lhecker The concern is a userland context switch in the middle of unwinding? Things should work if you `panic::catch_unwind` in the initial thread and then `panic::propagate` in the new thread when a coroutine is migrating.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216055742/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216092672",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-216092672",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 216092672,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxNjA5MjY3Mg==",
    "user": {
      "login": "zonyitoo",
      "id": 1067951,
      "node_id": "MDQ6VXNlcjEwNjc5NTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1067951?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zonyitoo",
      "html_url": "https://github.com/zonyitoo",
      "followers_url": "https://api.github.com/users/zonyitoo/followers",
      "following_url": "https://api.github.com/users/zonyitoo/following{/other_user}",
      "gists_url": "https://api.github.com/users/zonyitoo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zonyitoo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zonyitoo/subscriptions",
      "organizations_url": "https://api.github.com/users/zonyitoo/orgs",
      "repos_url": "https://api.github.com/users/zonyitoo/repos",
      "events_url": "https://api.github.com/users/zonyitoo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zonyitoo/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-05-02T02:04:44Z",
    "updated_at": "2016-05-02T02:06:53Z",
    "body": "@sfackler Nope. Not in the middle of unwinding.\n\nAs you can see in [here](https://github.com/rust-lang/rust/blob/master/src/libstd/sys/common/unwind/mod.rs#L148), the `f` is the coroutine's callback, what if we transfer the coroutine to a new thread before it finished? Yes, the `s` still points to the original thread's TLS!!! And after the coroutine is finished, `s.set(prev)` will cause data race!\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216092672/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216106819",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-216106819",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 216106819,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxNjEwNjgxOQ==",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-05-02T05:19:43Z",
    "updated_at": "2016-05-02T05:19:43Z",
    "body": "@lhecker, @zonyitoo \n\nThis is unfortunately one of the major drawbacks of coroutines in a systems language right now, which is that they don't support native TLS easily. It sounds like this interaction with `PANIC_COUNT` is indeed one location where things can go awry, but it's not the only one use of TLS in the standard library. For example this is also used for poisoning on mutexes. Additionally, many external libraries rely on TLS for various bits and pieces of an implementation.\n\nI don't think this problem is necessarily contained to `catch_unwind` in particular. This would either be the responsibility of a coroutine library to swap out TLS tables as well as the stack, or the standard library would provide an API to save/restore all thread-local context whenever a switch happened.\n\nAlso note that TLS has bad interactions with optimizations in LLVM right now, specifically the usage of TLS across a function call that can change threads may cause segfaults. (some info about this is in 12c5fc5877f708e8e4df05bf834261f5237ac437)\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216106819/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216108167",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-216108167",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 216108167,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxNjEwODE2Nw==",
    "user": {
      "login": "zonyitoo",
      "id": 1067951,
      "node_id": "MDQ6VXNlcjEwNjc5NTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1067951?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zonyitoo",
      "html_url": "https://github.com/zonyitoo",
      "followers_url": "https://api.github.com/users/zonyitoo/followers",
      "following_url": "https://api.github.com/users/zonyitoo/following{/other_user}",
      "gists_url": "https://api.github.com/users/zonyitoo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zonyitoo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zonyitoo/subscriptions",
      "organizations_url": "https://api.github.com/users/zonyitoo/orgs",
      "repos_url": "https://api.github.com/users/zonyitoo/repos",
      "events_url": "https://api.github.com/users/zonyitoo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zonyitoo/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-05-02T05:37:06Z",
    "updated_at": "2016-05-02T06:33:14Z",
    "body": "@alexcrichton Hmm, unfortunately, switching TLS tables could not solve this problem, because after switching, the current executing context still holds pointers to values in the original TLS (for example, the `s` I mentioned before in [here](https://github.com/rust-lang/rust/blob/master/src/libstd/sys/common/unwind/mod.rs#L148)).\n\nIt is not easy to make coroutine compatible with `thread_local!`. But .. is it possible to override the behavior of `thread_local!`? Which is a solution for \"swap out TLS tables as well as the stack\".\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216108167/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216162216",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-216162216",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 216162216,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxNjE2MjIxNg==",
    "user": {
      "login": "lhecker",
      "id": 2256941,
      "node_id": "MDQ6VXNlcjIyNTY5NDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2256941?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lhecker",
      "html_url": "https://github.com/lhecker",
      "followers_url": "https://api.github.com/users/lhecker/followers",
      "following_url": "https://api.github.com/users/lhecker/following{/other_user}",
      "gists_url": "https://api.github.com/users/lhecker/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lhecker/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lhecker/subscriptions",
      "organizations_url": "https://api.github.com/users/lhecker/orgs",
      "repos_url": "https://api.github.com/users/lhecker/repos",
      "events_url": "https://api.github.com/users/lhecker/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lhecker/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-05-02T09:06:40Z",
    "updated_at": "2016-05-02T09:27:47Z",
    "body": "@alexcrichton The only thing with Rust where TLS is used in a way which **does not** work with coroutines is `std::panic` (even if we wanted to). Reason being that it holds a [_reference_](https://github.com/rust-lang/rust/blob/a92ee0f664c84545c3cba70644472ec3df23c1ee/src/libstd/sys/common/unwind/mod.rs#L134) to a TLS store while calling a callback function, which could move from thread to thread. While this might be reasonable with threads it's a major error with coroutines.\n\nFor instance the poison flag you mentioned? That's not inherently a problem! The poison flag only calls `thread::panicking()`, which is in fact alright, because only one coroutine can run on a single thread at a time and if a panic happens while it's currently already panicking it's obviously an error.\n\nBut what happens if you catch that panic? The `PANIC_COUNT` of the _current_ thread won't be reset to 0, but instead the `PANIC_COUNT` of the thread where `catch_unwind` was called first will be reset to 0.\n\nAFAIK this is the only _major_ problem with TLS & Coroutines in Rust right now. And as I said earlier this could either be solved by:\n- Disallowing `catch_unwind()` while a panic is currently active. That way the `PANIC_COUNT` will _always_ be 0 before calling the callback. You could then simply set the `PANIC_COUNT` to 0 after `intrinsic::try()` catched an unwind.\n- Adding a API similiar to `panic::set_hook()` which allows providing a custom `PANIC_COUNT`\n\n**Edit:** You're right though about it being dangerous... For instance a `ThreadRng` should not be used with coroutines. But it does not change the fact that it and all those external libraries have some alternatives at least while `std::panic` has none. :cry: \n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216162216/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216301803",
    "html_url": "https://github.com/rust-lang/rust/issues/25662#issuecomment-216301803",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/25662",
    "id": 216301803,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxNjMwMTgwMw==",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-05-02T17:24:59Z",
    "updated_at": "2016-05-02T17:24:59Z",
    "body": "Thinking more on this, the bug pointed out in https://github.com/rust-lang/rust/commit/12c5fc5877f708e8e4df05bf834261f5237ac437 essentially means that any use of TLS is subject to segfaults with coroutines currently. That's unfortunately not the only problem that needs to be solved (e.g. also this business with `PANIC_COUNT`), but no local solution with `PANIC_COUNT` will solve the entire problem, however.\n\nThe gist of that bug is that this code can segfault:\n\n``` rust\nfn foo() -> bool {\n    let a = thread::panicking();\n    bar();\n    a && thread::panicking()\n}\n```\n\n---\n\nAs a side note, I just realized that this issue is basically now long since closed. We've discussed the whole `std::panic` story quite thoroughly now! I'm gonna close this, and we may want to continue discussing coroutines/TLS elsewhere (as this may not be the most appropriate place)\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/216301803/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
