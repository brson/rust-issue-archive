[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/46589883",
    "html_url": "https://github.com/rust-lang/rust/issues/15040#issuecomment-46589883",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/15040",
    "id": 46589883,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTg5ODgz",
    "user": {
      "login": "emberian",
      "id": 704250,
      "node_id": "MDQ6VXNlcjcwNDI1MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emberian",
      "html_url": "https://github.com/emberian",
      "followers_url": "https://api.github.com/users/emberian/followers",
      "following_url": "https://api.github.com/users/emberian/following{/other_user}",
      "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emberian/subscriptions",
      "organizations_url": "https://api.github.com/users/emberian/orgs",
      "repos_url": "https://api.github.com/users/emberian/repos",
      "events_url": "https://api.github.com/users/emberian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emberian/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-06-19T17:18:56Z",
    "updated_at": "2014-06-19T17:18:56Z",
    "body": "I believe @kimundi had some ideas here.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/46589883/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47089034",
    "html_url": "https://github.com/rust-lang/rust/issues/15040#issuecomment-47089034",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/15040",
    "id": 47089034,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MDg5MDM0",
    "user": {
      "login": "Kimundi",
      "id": 2903206,
      "node_id": "MDQ6VXNlcjI5MDMyMDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Kimundi",
      "html_url": "https://github.com/Kimundi",
      "followers_url": "https://api.github.com/users/Kimundi/followers",
      "following_url": "https://api.github.com/users/Kimundi/following{/other_user}",
      "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions",
      "organizations_url": "https://api.github.com/users/Kimundi/orgs",
      "repos_url": "https://api.github.com/users/Kimundi/repos",
      "events_url": "https://api.github.com/users/Kimundi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Kimundi/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-06-25T11:24:05Z",
    "updated_at": "2014-06-25T11:24:05Z",
    "body": "Dynamic loading of non-Rust libraries can probably not be made safe in general because of missing type metadata, so I'll only talk about dynamically loaded Rust crates. \n\nAdditionally, dynamically loaded crates and dynamically compiled crates (like produced by a jit compiler) both only start to exist at runtime and can get cleaned up, so I see this as an issue for any kind of native code with non-`'static` lifetimes.\n\n# Requirements\n\nIn an ideal world, you would have a safe way to dynamically load a library, use its symbols, and then afterwards unload the library again, likely implemented with some kind of RAAI scheme.\n\nThe interface should be typesafe, which implies that communication between host executable and dynamic library can only happen through types known to both.\n\nAnd if should be memory safe, which implies that no dependencies on dynamically loaded code should escape the lifetime of the dynamic library.\n\nHowever, there are three problems that need to be solved for this to happen:\n- **Typechecking**  \n  This one is comparatively easy, but probably needs to have a intrinsic added. It could be implemented by having a generic function `fn load_symbol<T>(path: &str)`, used like `load_symbol::<fn(uint, Bar) -> Baz>(\"a::b::c::bar_adder\")`.  \n  It would create a globally unique identifier for the type it got instantiated with, read the metadata of the dynamic library, try to resolve the given path in it, and then confirms that it points at an item with the same unique type identifier. This might be implementable with the current `type_id` intrinsic, but you might want to have a intrinsic that gives a few more informations.\n- **Don't let function pointers escape**  \n  A problem in the Rust language right now is that function pointers are always implicitly assumed to be equivalent to something like `&'static code`, that is they are copyable and can outlive any scope. This is true for direct function types like `fn(Foo) -> Bar`, as well for types that implicitly contain them, like `&Trait` or `|Foo| -> Bar`, where the function pointers are hidden in vtables or similar.  \n  If all code is valid for the duration of the process, this is not a problem and makes things easier, but with dynamically loaded libraries you have a problem. Say you have the symbol `fn() -> Box<Trait>`. It would allow you to get a new owned trait object with a vtable that becomes invalid as soon as the dynamic library gets unloaded. Bad!  \n  Even if the function pointer itself gets a lifetime, you could have a type like `fn () -> fn() -> fn() -> ()`, where each return value is a new independent value that also needs to be lifetime restricted. So you can't just look at the type itself, but also at all types deriveable by function calls or similar.\n- **Not letting `'static` lifetimes escape**  \n  This is similar to the problem above: Say you have a symbol `fn() -> &'static Foo`. Normally you could assume from such a signature that there is a constant of type `Foo` that you are returning a reference too, which you can continue using afterwards without any lifetime restrictions.\n  \n  However, in the case of a dynamic library such a type would lie: The lifetime of the reference is not `'static`, its actually a `'a` that is the intersection of `'static` and the lifetime of the crate it got loaded from.\n\n# Possible solutions:\n1. Don't change the language, and always leak the loaded dynamic code so that lifetimes never end.\n   This is a valid approach, but ugly because it leaks memory, which restricts the possible use cases it applies too. For example, a simple plugin system might not have a problem with this, as the number if plugins is limited, but a system that repeatedly jits new code could get into trouble fast with this approach.\n2. Don't change the language, but restrict the set of possible loadable symbols.\n   This would involve the symbol loader figuring out if a given symbol can lead to lifetime-leaking function pointers or `&'static`s, and prohibit those symbols from being loaded, and otherwise only expose the actual function pointer through a wrapper struct that ensures a lifetime dependency on it.\n   This might be enough for many cases, but probably would have to block language features like type erasure in general to be made sound.\n3. Extend the typesystem with a optional annotation to \"taint\" any `'static` lifetime in a type graph with a smaller lifetime `'a`. I'm not sure exactly how and if that could work, but I imagine it being similar to the build-in traits. The dynamic code loader could then use that annotation to limit the graph starting with the symbol function pointer itself.\n   This approach has probably the most promise, but its also the hardest to implement as it involves language changes.\n   Imaginary example syntax:\n   \n   ```\n   fn load_symbol<'a, T>(&'a self) -> T<crate: 'a>;\n   let x = c.load_symbol::<fn() -> fn() -> ()>();\n   let f: (fn() -> fn() -> ())<crate: 'a> = x; // OK\n   let g: (fn() -> ())<crate: 'a> = x(); // OK\n   let h: fn() -> () = x(); // ERROR!\n   ```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47089034/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/59989701",
    "html_url": "https://github.com/rust-lang/rust/issues/15040#issuecomment-59989701",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/15040",
    "id": 59989701,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5OTg5NzAx",
    "user": {
      "login": "PatrLind",
      "id": 4456415,
      "node_id": "MDQ6VXNlcjQ0NTY0MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4456415?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PatrLind",
      "html_url": "https://github.com/PatrLind",
      "followers_url": "https://api.github.com/users/PatrLind/followers",
      "following_url": "https://api.github.com/users/PatrLind/following{/other_user}",
      "gists_url": "https://api.github.com/users/PatrLind/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PatrLind/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PatrLind/subscriptions",
      "organizations_url": "https://api.github.com/users/PatrLind/orgs",
      "repos_url": "https://api.github.com/users/PatrLind/repos",
      "events_url": "https://api.github.com/users/PatrLind/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PatrLind/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-10-21T20:05:49Z",
    "updated_at": "2014-10-21T20:05:49Z",
    "body": "How about keeping track of all things related to the library and not allow unload until it is safe to do so?\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/59989701/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/59990495",
    "html_url": "https://github.com/rust-lang/rust/issues/15040#issuecomment-59990495",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/15040",
    "id": 59990495,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5OTkwNDk1",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-10-21T20:10:51Z",
    "updated_at": "2014-10-21T20:11:01Z",
    "body": "It's fundamentally _impossible_ for runtime library loading to be safe. It can be made safer via verification of the metadata in the crate, but loading a library from a path dynamically will always be `unsafe`. It's not sane to trust files at arbitrary files on the filesystem and there is no race-free way to do something like verifying that the library is controlled by root or the current user.\n\nA library runs arbitrary initialization code upon loading, and nothing prevents the code from having invalid metadata or simply being memory unsafe. It would be trivial to bypass safety restrictions by outputting arbitrary code in a plugin and running it.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/59990495/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/60035029",
    "html_url": "https://github.com/rust-lang/rust/issues/15040#issuecomment-60035029",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/15040",
    "id": 60035029,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwMDM1MDI5",
    "user": {
      "login": "emberian",
      "id": 704250,
      "node_id": "MDQ6VXNlcjcwNDI1MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emberian",
      "html_url": "https://github.com/emberian",
      "followers_url": "https://api.github.com/users/emberian/followers",
      "following_url": "https://api.github.com/users/emberian/following{/other_user}",
      "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emberian/subscriptions",
      "organizations_url": "https://api.github.com/users/emberian/orgs",
      "repos_url": "https://api.github.com/users/emberian/repos",
      "events_url": "https://api.github.com/users/emberian/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emberian/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-10-22T04:24:11Z",
    "updated_at": "2014-10-22T04:24:11Z",
    "body": "Yes, of course the actual loading would be unsafe for obvious reasons, but\nit could still be type safe and memory safe after it's loaded, given an\nassumption that the library is \"trusted\", even if that's only verified by a\nhash or signature. At some point you need to give up on absolute security\nif you want the flexibility afforded by runtime reloading, and assume the\nsystem is hostile.\n\nOn Tue, Oct 21, 2014 at 4:11 PM, Daniel Micay notifications@github.com\nwrote:\n\n> It's fundamentally _impossible_ for runtime library loading to be safe.\n> It can be made safer via verification of the metadata in the crate, but\n> loading a library from a path dynamically will always be unsafe. It's not\n> sane to trust files at arbitrary files on the filesystem and there is no\n> race-free way to do something like verifying that the library is controlled\n> by root or the current user. A library runs arbitrary initialization code\n> upon loading, and nothing prevents the code from having invalid metadata or\n> simply being memory unsafe. It would be trivial to bypass safety\n> restrictions by outputting arbitrary code in a plugin and running it.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/rust-lang/rust/issues/15040#issuecomment-59990495.\n\n## \n\nhttp://octayn.net/\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/60035029/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/60035216",
    "html_url": "https://github.com/rust-lang/rust/issues/15040#issuecomment-60035216",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/15040",
    "id": 60035216,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwMDM1MjE2",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-10-22T04:27:58Z",
    "updated_at": "2014-10-22T04:29:21Z",
    "body": "It can only be verified by a hash / signature if you load the entire thing into memory first and then somehow load it from there without touching the file again. It's never going to be appropriate to remove the `unsafe` marker from the API because running arbitrary code from an arbitrary path is fundamentally memory unsafe.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/60035216/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/60073121",
    "html_url": "https://github.com/rust-lang/rust/issues/15040#issuecomment-60073121",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/15040",
    "id": 60073121,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwMDczMTIx",
    "user": {
      "login": "Kimundi",
      "id": 2903206,
      "node_id": "MDQ6VXNlcjI5MDMyMDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Kimundi",
      "html_url": "https://github.com/Kimundi",
      "followers_url": "https://api.github.com/users/Kimundi/followers",
      "following_url": "https://api.github.com/users/Kimundi/following{/other_user}",
      "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions",
      "organizations_url": "https://api.github.com/users/Kimundi/orgs",
      "repos_url": "https://api.github.com/users/Kimundi/repos",
      "events_url": "https://api.github.com/users/Kimundi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Kimundi/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-10-22T11:52:52Z",
    "updated_at": "2014-10-22T11:52:52Z",
    "body": "I fail to see how dynamically loading a library manually is any more unsafe than dynamically loading a library by having it dynamically linked to from the beginning. In both cases there is a point where the compiler/usercode has to trust that the file being loaded does actually contain what is expected.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/60073121/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69764461",
    "html_url": "https://github.com/rust-lang/rust/issues/15040#issuecomment-69764461",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/15040",
    "id": 69764461,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NzY0NDYx",
    "user": {
      "login": "mzabaluev",
      "id": 1198919,
      "node_id": "MDQ6VXNlcjExOTg5MTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1198919?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mzabaluev",
      "html_url": "https://github.com/mzabaluev",
      "followers_url": "https://api.github.com/users/mzabaluev/followers",
      "following_url": "https://api.github.com/users/mzabaluev/following{/other_user}",
      "gists_url": "https://api.github.com/users/mzabaluev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mzabaluev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mzabaluev/subscriptions",
      "organizations_url": "https://api.github.com/users/mzabaluev/orgs",
      "repos_url": "https://api.github.com/users/mzabaluev/repos",
      "events_url": "https://api.github.com/users/mzabaluev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mzabaluev/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-13T15:45:26Z",
    "updated_at": "2015-01-13T22:23:04Z",
    "body": "Code trust issues aside, an operation certainly unsafe for the process image integrity is _un_loading of libraries. The problems and the per-platform variability here are such that all cross-platform programming environments I've seen that allow loading of arbitrary dynamic libraries have chosen to disable or discourage unloading. There hasn't been much demand for the feature either; memory is cheap, and in systems supporting dynamic libraries it is almost certainly virtually mapped. Being able to change parts of the program at runtime is neat, but I don't think it is compatible with what Rust is aimed to be otherwise.\n\nTo be safely unloaded, a module and the program using it must ensure that none of the in-image data it adds to the process is referenced elsewhere. This extends to any dynamic libraries the module might be linked to as the single consumer in the process, because the libraries are unloaded together with it (any alternatives to this behavior are not portable to the best of my knowledge). Even if Rust provides a solution for safe code with lifetimes, I expect the issues with foreign libraries will be too numerous and hard to debug. Heaven help you if any of those libraries is in C++; implementations of _language features_ there are not safe with regard to unloading.\n\nI think it best for everyone's sanity if the unload operation is kept unsafe, or not provided at all. This will remove the problem with soundness of `'static`, because any in-binary data added to the process image is assumed to stay there forever.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69764461/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69815668",
    "html_url": "https://github.com/rust-lang/rust/issues/15040#issuecomment-69815668",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/15040",
    "id": 69815668,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5ODE1NjY4",
    "user": {
      "login": "Kimundi",
      "id": 2903206,
      "node_id": "MDQ6VXNlcjI5MDMyMDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Kimundi",
      "html_url": "https://github.com/Kimundi",
      "followers_url": "https://api.github.com/users/Kimundi/followers",
      "following_url": "https://api.github.com/users/Kimundi/following{/other_user}",
      "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions",
      "organizations_url": "https://api.github.com/users/Kimundi/orgs",
      "repos_url": "https://api.github.com/users/Kimundi/repos",
      "events_url": "https://api.github.com/users/Kimundi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Kimundi/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-13T20:40:21Z",
    "updated_at": "2015-01-13T20:40:21Z",
    "body": "Yeah, supporting unloading for arbitrary libraries is a tricky issue for sure. But I still think it could be made safe in controlled environments like Rust-only libraries explicitly compiled as unloadable plugins.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/69815668/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/70905932",
    "html_url": "https://github.com/rust-lang/rust/issues/15040#issuecomment-70905932",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/15040",
    "id": 70905932,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTA1OTMy",
    "user": {
      "login": "steveklabnik",
      "id": 27786,
      "node_id": "MDQ6VXNlcjI3Nzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/steveklabnik",
      "html_url": "https://github.com/steveklabnik",
      "followers_url": "https://api.github.com/users/steveklabnik/followers",
      "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}",
      "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions",
      "organizations_url": "https://api.github.com/users/steveklabnik/orgs",
      "repos_url": "https://api.github.com/users/steveklabnik/repos",
      "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/steveklabnik/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-01-21T19:36:18Z",
    "updated_at": "2015-01-21T19:36:18Z",
    "body": "I'm pulling a massive triage effort to get us ready for 1.0. As part of this, I'm moving stuff that's wishlist-like to the RFCs repo, as that's where major new things should get discussed/prioritized.\n\nThis issue has been moved to the RFCs repo: rust-lang/rfcs#661\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/70905932/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
