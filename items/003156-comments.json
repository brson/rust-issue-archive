[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7613816",
    "html_url": "https://github.com/rust-lang/rust/issues/3156#issuecomment-7613816",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3156",
    "id": 7613816,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc2MTM4MTY=",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-08-09T13:23:51Z",
    "updated_at": "2012-08-09T13:23:51Z",
    "body": "I agree this would be nice to fix.  Considering your points in reverse order:\n- I think #912 is a non-starter.  I closed it.  \n- It's not obvious to me how higher-kinded types solves this problem.  I think the problem has to do with the fact that we do not connect type parameters.  That is to say, I don't think that unifying `IA<A>` with `option<{f: int}>` would necessarily equate `A` with `{f: int}`.  I guess it depends on how flexible our system was, but I could imagine a higher-kinded type `option<{f: _}>` or `foo<str, _>`.  In the latter case, the value would be `foo<str, {f: int}>` (not `option<int>`).  So how could I unify `foo<str, {f: int}>` with `IA<A>` (not knowing what `IA` is) and extract a value for `A`?  \n\nMoreover, even if we had higher-kinded types, I am not sure that `iterable` would be a suitable place to use it.  Defining iterable that way would rule out a type like BitSet from implementing `iterable<int>` and no other type.\n- That leaves us with determining ifaces earlier rather than later.  I would like to experiment with this but I do recall that the last time we talked it through there were complications, though I can't recall what they were.  I guess the best thing to do is to read up more carefully on what Haskell does.  If memory serves---and I could be wrong, I don't know Haskell very well---this particular problem that we are talking about is also related to functional dependencies: that is, we would like to be able to say that each iterable thing is only iterable over one type, and therefore if we know the value for `IA`, we can deduce the value for `A`.  I think this relates to overloading: conceivably (in today's system) there could be a type `empty_iterable` which is defined for all `A`, for example, which would not help us in deducing the type of `A`.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7613816/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7613896",
    "html_url": "https://github.com/rust-lang/rust/issues/3156#issuecomment-7613896",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/3156",
    "id": 7613896,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc2MTM4OTY=",
    "user": {
      "login": "nikomatsakis",
      "id": 155238,
      "node_id": "MDQ6VXNlcjE1NTIzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nikomatsakis",
      "html_url": "https://github.com/nikomatsakis",
      "followers_url": "https://api.github.com/users/nikomatsakis/followers",
      "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}",
      "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions",
      "organizations_url": "https://api.github.com/users/nikomatsakis/orgs",
      "repos_url": "https://api.github.com/users/nikomatsakis/repos",
      "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nikomatsakis/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2012-08-09T13:26:47Z",
    "updated_at": "2012-08-09T13:27:02Z",
    "body": "To clarify what I wrote about higher-kinded types and inference: what I meant is that somewhere (the impl, I suppose) we'd have to define how `IA<A>` is mapped to the concrete self type for this impl.  I think implicit in your point was an assumption that, to implement an interface with one type parameter, you must supply a nominal type with one parameter.  And maybe this is the right way to do it, but it's not the only way to do it.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/7613896/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
