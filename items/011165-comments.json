[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31279933",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-31279933",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 31279933,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjc5OTMz",
    "user": {
      "login": "lilyball",
      "id": 714,
      "node_id": "MDQ6VXNlcjcxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lilyball",
      "html_url": "https://github.com/lilyball",
      "followers_url": "https://api.github.com/users/lilyball/followers",
      "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
      "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
      "organizations_url": "https://api.github.com/users/lilyball/orgs",
      "repos_url": "https://api.github.com/users/lilyball/repos",
      "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lilyball/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-27T21:01:40Z",
    "updated_at": "2013-12-27T21:01:40Z",
    "body": "cc @alexcrichton \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31279933/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31280439",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-31280439",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 31280439,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjgwNDM5",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-27T21:16:06Z",
    "updated_at": "2013-12-27T21:16:06Z",
    "body": "I am still not entirely convinced that this is the correct way to go about this. I would rather explore other pathways first such as an I/O `select()` instead of having a split.\n\nThe good thing about `select()` is that it's generic while with `split()` it has to be implemented for all readers/writers seperately (different native and green implementations as well).\n\nThis is definitely a problem that needs to be fixed before 1.0 (so I'm nominating this), but I want to approach this carefully and avoid just blindly implementing a solution which won't extend very well into the future.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31280439/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31301030",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-31301030",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 31301030,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMzAxMDMw",
    "user": {
      "login": "lilyball",
      "id": 714,
      "node_id": "MDQ6VXNlcjcxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lilyball",
      "html_url": "https://github.com/lilyball",
      "followers_url": "https://api.github.com/users/lilyball/followers",
      "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
      "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
      "organizations_url": "https://api.github.com/users/lilyball/orgs",
      "repos_url": "https://api.github.com/users/lilyball/repos",
      "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lilyball/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2013-12-28T17:46:26Z",
    "updated_at": "2013-12-28T17:46:26Z",
    "body": "Having `select()` work with I/O in addition to ports/chans would be quite nice. I suggested `split()` because that seems simpler.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31301030/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31609736",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-31609736",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 31609736,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNjA5NzM2",
    "user": {
      "login": "derekchiang",
      "id": 1535686,
      "node_id": "MDQ6VXNlcjE1MzU2ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535686?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/derekchiang",
      "html_url": "https://github.com/derekchiang",
      "followers_url": "https://api.github.com/users/derekchiang/followers",
      "following_url": "https://api.github.com/users/derekchiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/derekchiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/derekchiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/derekchiang/subscriptions",
      "organizations_url": "https://api.github.com/users/derekchiang/orgs",
      "repos_url": "https://api.github.com/users/derekchiang/repos",
      "events_url": "https://api.github.com/users/derekchiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/derekchiang/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-05T17:27:33Z",
    "updated_at": "2014-01-05T17:27:33Z",
    "body": "@alexcrichton are you working on a solution?  I would like to help to resolve this issue quickly as my project is blocked by this :)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31609736/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31962471",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-31962471",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 31962471,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTYyNDcx",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T18:39:15Z",
    "updated_at": "2014-01-09T18:39:15Z",
    "body": "Updated title to reflect that the solution isn't known.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31962471/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31962482",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-31962482",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 31962482,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTYyNDgy",
    "user": {
      "login": "pnkfelix",
      "id": 173127,
      "node_id": "MDQ6VXNlcjE3MzEyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pnkfelix",
      "html_url": "https://github.com/pnkfelix",
      "followers_url": "https://api.github.com/users/pnkfelix/followers",
      "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}",
      "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions",
      "organizations_url": "https://api.github.com/users/pnkfelix/orgs",
      "repos_url": "https://api.github.com/users/pnkfelix/repos",
      "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pnkfelix/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-09T18:39:25Z",
    "updated_at": "2014-01-09T18:39:25Z",
    "body": "Assigning to P-high.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/31962482/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32102210",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32102210",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32102210,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTAyMjEw",
    "user": {
      "login": "Matthias247",
      "id": 6330334,
      "node_id": "MDQ6VXNlcjYzMzAzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthias247",
      "html_url": "https://github.com/Matthias247",
      "followers_url": "https://api.github.com/users/Matthias247/followers",
      "following_url": "https://api.github.com/users/Matthias247/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthias247/orgs",
      "repos_url": "https://api.github.com/users/Matthias247/repos",
      "events_url": "https://api.github.com/users/Matthias247/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthias247/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-11T17:47:58Z",
    "updated_at": "2014-01-11T17:47:58Z",
    "body": "I stumbled across the same issue today, while I was starting to implement a websocket library for Rust.\nMy design idea was to have a websocket task, which owns the TcpStream. It receives and sends through the socket. And it receives data-to-send through a channel from the user and pushes received data in another channel towards the user. No I discovered that as soon as I would start to `receive()` anything in the task I would never be able to send (unless the remote side sends sth., because I'm blocked).\nAlso as long as I'm waiting for data to send by `port.recv()` I could not receive anything from the socket.\n\nI guess this state makes it impossible to implement any protocols that do not follow a `request -> response -> request -> response` pattern.\nIt also doesn't allow for a graceful shutdown of a connection, because as long as you are in a blocking receive you can't close the connection.\n\nI basically see the same possible solutions as you:\n- Allow to split `TcpStream` in `TcpWriteStream` and `TcpReadStream`. That would propably equal that what most simpler programs in other languages would do. I also don't like it that much because it would require a blocking background task in addition to the task that writes and you somehow have to care for synchronization between the two parts.\n- Update `select()` into a version that works on ports as well as all kind of I/O. would absolutely favour this and have some more ideas about that that I will write down later.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32102210/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32116120",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32116120",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32116120,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTE2MTIw",
    "user": {
      "login": "derekchiang",
      "id": 1535686,
      "node_id": "MDQ6VXNlcjE1MzU2ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535686?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/derekchiang",
      "html_url": "https://github.com/derekchiang",
      "followers_url": "https://api.github.com/users/derekchiang/followers",
      "following_url": "https://api.github.com/users/derekchiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/derekchiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/derekchiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/derekchiang/subscriptions",
      "organizations_url": "https://api.github.com/users/derekchiang/orgs",
      "repos_url": "https://api.github.com/users/derekchiang/repos",
      "events_url": "https://api.github.com/users/derekchiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/derekchiang/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-12T06:02:55Z",
    "updated_at": "2014-01-12T06:02:55Z",
    "body": "For those of you looking for a work-around in the mean time, the following seems to work for me:\n\nSay you have a TcpStream called `tcp`, then you do:\n\n``` rust\nuse std::sync::arc::UnsafeArc;\nlet (tcp_send_arc, tcp_recv_arc) = UnsafeArc::new2(tcp);\n```\n\nThen, you can use `tcp_send_arc` and `tcp_recv_arc` in different tasks.  For example:\n\n``` rust\ndo spawn {\n    unsafe {\n        let tcp_recv_ptr = tcp_recv_arc.get();\n        loop {\n            // Then you could use the stream like you would, using (*tcp_recv_ptr)\n            let bytes =  (*tcp_recv_ptr).read_to_end();\n            // ...\n        }\n    }\n}\n```\n\nThe thing here is that the underlying `libc` implementation of sockets uses different buffers for read and write, so it's safe to read in one thread and write in another.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32116120/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32162122",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32162122",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32162122,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTYyMTIy",
    "user": {
      "login": "ehsanul",
      "id": 49203,
      "node_id": "MDQ6VXNlcjQ5MjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/49203?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ehsanul",
      "html_url": "https://github.com/ehsanul",
      "followers_url": "https://api.github.com/users/ehsanul/followers",
      "following_url": "https://api.github.com/users/ehsanul/following{/other_user}",
      "gists_url": "https://api.github.com/users/ehsanul/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ehsanul/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ehsanul/subscriptions",
      "organizations_url": "https://api.github.com/users/ehsanul/orgs",
      "repos_url": "https://api.github.com/users/ehsanul/repos",
      "events_url": "https://api.github.com/users/ehsanul/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ehsanul/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-13T11:38:55Z",
    "updated_at": "2014-01-13T11:38:55Z",
    "body": "Having `select` work with OS objects (file descriptors and handlers) in addition to ports/channels has come up in the context of timers as well: https://github.com/mozilla/rust/pull/11294#issuecomment-31613198\n\nIs this likely to happen? And we are definitely all talking about [this select](https://github.com/mozilla/rust/blob/master/src/libstd/comm/select.rs), right?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32162122/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32162652",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32162652",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32162652,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTYyNjUy",
    "user": {
      "login": "Matthias247",
      "id": 6330334,
      "node_id": "MDQ6VXNlcjYzMzAzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthias247",
      "html_url": "https://github.com/Matthias247",
      "followers_url": "https://api.github.com/users/Matthias247/followers",
      "following_url": "https://api.github.com/users/Matthias247/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthias247/orgs",
      "repos_url": "https://api.github.com/users/Matthias247/repos",
      "events_url": "https://api.github.com/users/Matthias247/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthias247/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-13T11:49:12Z",
    "updated_at": "2014-01-13T11:49:12Z",
    "body": "The problem with your solution is that you can't close the socket and your connection will persist unless the remote will close the collection.\nThis is because the TcpStream does not expose a `close()` method and only dropping the writing side reference would not cause a close.\nI guess if splitting is implemented the writing side should expose a `close()` method which would cause the read end to return. I don't know if this would work with libuv bindings or if there is a restriction that you can't own a handle to a connection after you have closed it.\n\nI started yesterday evening a little with experimenting how a `select()` for sockets and Channels could look like. My first impressions are that a good API design is far from easy.\nI basically started with native IO (1:1) because that's easier for me to understand than all the implications of the scheduler. My idea there was to use epoll (or comparable things like IOCP on Win and kqueue on OSX) as the backend for a `Selector`, so basically the same thing that libuv does. Integrating this with channels should not be that hard. If some new data arrives at the port simply lookup if that port is registered at a `Selector` and if yes than wake that up. Timers can also be easily integrated in the form of providing a timeout to the `select`.\n\nBut then there's the question about the API design for sockets and other IO. Should the user be able to register for IO readiness and `select` would unblock when R/W is possible or should it unblock on IO completion. So basically the Unix model vs. Windows model thing. Both have their pros and cons.\nThen `TcpStream` (as an example) must expose functions that register at the selector. My first thoughts were going in the direction of having sth. like `async_read(self, selector: &Selector, buffer: ~[u8], offset: uint, length: uint)` which would register the IOStream at the selector  and starts an asynchronous transfer. The stream should not be available for any more synchronous or asynchronous reads as long as this operation is pending - but still for writes. That could be either by simply setting a flag which would case an IoError on following writes or by consuming TcpStream and returning an object without write methods.\n\n`Selector.select()` would somehow extract finished operations. The question is what this returns and how to propagate the finish information to the original caller / socket owner. Classic APIs like boost asio or libuv do this by allowing to store a callback together with the beginning of the IO which can be called (or will be automatically called) when the operation finishes. I'm not sure if this works good with Rust, because it's easy to self-destruct objects from inside such callbacks and there goes your safety. We could also use a `*Trait` to define which object has to signaled when the operation is completed, but it is essentially the same as a callback.\n\nAnother idea would be to return IDs when the async operation is started and `select()` returns the ID of the finished operation. This would be used to call sth. like `finish_async_read(id)` on the socket. Would however be quite complicated to associate the ID with the corresponding object that sent the request and owns the IOObject in bigger codebases. With a \"user data\" field in the ID the user can still store a pointer to a callback if he wants to go the unsafe route.\n\nWhat is obvious for me is that when the IoObject get's destructed then it should be automatically deregistered from the `Selector`. Maybe also when it get's moved, but I don't know if that's possible. \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32162652/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32414450",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32414450",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32414450,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNDE0NDUw",
    "user": {
      "login": "lilyball",
      "id": 714,
      "node_id": "MDQ6VXNlcjcxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lilyball",
      "html_url": "https://github.com/lilyball",
      "followers_url": "https://api.github.com/users/lilyball/followers",
      "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
      "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
      "organizations_url": "https://api.github.com/users/lilyball/orgs",
      "repos_url": "https://api.github.com/users/lilyball/repos",
      "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lilyball/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-15T21:01:37Z",
    "updated_at": "2014-01-15T21:01:37Z",
    "body": "@derekchiang I'm not convinced that approach is safe. When using libgreen, TcpStream is presumably implemented on top of libuv, and I have no idea whether the libuv data is safe to be accessed from multiple threads.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32414450/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32455217",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32455217",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32455217,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNDU1MjE3",
    "user": {
      "login": "Matthias247",
      "id": 6330334,
      "node_id": "MDQ6VXNlcjYzMzAzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthias247",
      "html_url": "https://github.com/Matthias247",
      "followers_url": "https://api.github.com/users/Matthias247/followers",
      "following_url": "https://api.github.com/users/Matthias247/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthias247/orgs",
      "repos_url": "https://api.github.com/users/Matthias247/repos",
      "events_url": "https://api.github.com/users/Matthias247/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthias247/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-16T09:55:38Z",
    "updated_at": "2014-01-16T10:02:35Z",
    "body": "@kballard When using libgreen the scheduler that should guarantee that all calls to the libuv streams are from the done from the (single) native thread which owns the associated libuv eventlooop. Therefore I think that the threading is no problem. However the scheduler and libuv wrapper implementations are propably not designed to support parallel requests on the same libuv streams, so it will still be pretty much undefined what happens.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32455217/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32480677",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32480677",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32480677,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNDgwNjc3",
    "user": {
      "login": "sw17ch",
      "id": 95705,
      "node_id": "MDQ6VXNlcjk1NzA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/95705?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sw17ch",
      "html_url": "https://github.com/sw17ch",
      "followers_url": "https://api.github.com/users/sw17ch/followers",
      "following_url": "https://api.github.com/users/sw17ch/following{/other_user}",
      "gists_url": "https://api.github.com/users/sw17ch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sw17ch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sw17ch/subscriptions",
      "organizations_url": "https://api.github.com/users/sw17ch/orgs",
      "repos_url": "https://api.github.com/users/sw17ch/repos",
      "events_url": "https://api.github.com/users/sw17ch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sw17ch/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-16T15:48:33Z",
    "updated_at": "2014-01-16T15:49:58Z",
    "body": "Just to clarify something, the proposed `select` would work on any `Port<T>` as well as Unix-like file handles? This implies the following pseudo-usage pattern:\n\n``` rust\n// Do things up here to setup processor tasks.\n\nlet request_processor_ports = [...];\nlet socket = bind_listen_and_accept();\n\nwhile true {\n    let selected = select(socket, request_processor_ports);\n\n    if (selected == socket) {\n        available_request_processor.process(socket.read());\n    } else {\n        let msg = selected.read();\n        socket.write(msg);\n    }\n}\n```\n\nAm I misunderstanding the proposal for select? Sorry if I botched the syntax a bit.\n\nEdit: as a followup, would there be a way to do this entirely without tasks?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32480677/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32501552",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32501552",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32501552,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTAxNTUy",
    "user": {
      "login": "Matthias247",
      "id": 6330334,
      "node_id": "MDQ6VXNlcjYzMzAzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthias247",
      "html_url": "https://github.com/Matthias247",
      "followers_url": "https://api.github.com/users/Matthias247/followers",
      "following_url": "https://api.github.com/users/Matthias247/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthias247/orgs",
      "repos_url": "https://api.github.com/users/Matthias247/repos",
      "events_url": "https://api.github.com/users/Matthias247/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthias247/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-16T18:17:30Z",
    "updated_at": "2014-01-16T18:21:05Z",
    "body": "Basically you won't need extra tasks. You would select directly on the TcpStream somehow.\nYour example also describes an API that works upon I/O readiness (like `select` or `(e)poll` on low level).\nI'm currently leaning more in the direction of I/O completion, because\n- I/O readiness does not work good in Windows\n- I think I/O completion does also work better for M:N scheduled green threads, because you won't have to yield 2 times into the I/O thread.\n\nI have started working on a solution and can tell you what my current API looks like, but it's far from finished.\n\n``` rust\n// Create a selector which is a new object\nlet selector = Selector::new().unwrap();\n\n// First create a TcpStream object. \n// This is in my current implementation quite the same as the native I/O ip stream\n// - a very thin wrapper on top of the FD. It provides the same read and write methods.\nlet mut nativeStream = TcpStream::connect(socketaddr).unwrap();\n\nnativeStream.set_blocking(false); // Switch to non-blocking I/O if desired\n\n// This is new. It \"upgrades\" the TcpStream into a SelectableTcpStream object by consuming it. \n// This class features additonal async read/write methods that will be performed by using the \n// associated selector.\n// I like that approach quite much because if you don't want async I/O you don't need to use it.\nlet mut selectableStream = stream.associate_selector(&selector);\n\n// By performing selectableStream.disassociate_selector() the original TcpStream can be restored.\n// This will only work when no async I/O operation is pending\n\n// Start an async I/O operations. \n// In contrast to the existing APIs the operation needs an owned buffer \n// in order to manipulate it in the background.\nlet handle = selectableStream.read_some_async(\n    ByteBuffer { buffer: ~[0, ..100], offset: 0, length: 20}\n);\n// handle is either an IoResult<uint>, so either an IoError or a uint as a handle.\n\n// Query the selector for finished I/O when required\nlet result = selector.wait();\n// This blocks until one of the started async operations finishes. It also returns an IoResult<uint>\n// which contains in case of success the handle of the operation that finished.\n\n// In case the handles match the result of the async operation can be retrieved\nmatch (handle, result) { \n    (Ok(h1),Ok(h2)) if h1 == h2 => {\n        let result = stream.end_read_async();\n        // This will return either an IoError or the result of the operation which consists of the ByteBuffer\n        // that was passed at the start of the operation and the number of bytes that were read.\n    },...\n}\n\n```\n\nWhile an async read is in progress no other sync or async read can be started.\nI played with transforming the SelectableSocket into a WriteOnlySocket then, but in the end mutating the objects in 4 different types only gives headaches.\n\nSo that's basically my current state and what I have to about 60% implemented using native I/O on Linux.\n\nWhat I like is the association and disassociation of the `TcpStream` to the `Selector`.\nWhat I'm not convinced of yet is what the `read_some_async` and `selector.wait()` operations should return.\nA handle is ok in easy cases. But in advanced cases associating the handle to the actual Stream/Channel/Timer/... might be quite hard. \nThe C# async APIs allow to pass some userstate to the read call which can be retrieved later. \nMaybe that's a possibilty, but it screams a little bit `unsafe` because it would be propably sth. like `*void`.\nAnother idea I had was like that: \n\n``` rust\nlet pending_op= selectableStream.read_some_async(\n    ByteBuffer { buffer: ~[0, ..100], offset: 0, length: 20}\n).unwrap();\nlet result = selector.wait().unwrap();\n\nif (result.pending_op == pending_op) {\n    let read_result = pending_op.end_read_async();\n}\n```\n\nSo calling the end methods directly on the handle that is returned. But returning complex handles propably leads to very complex lifetime semantics.\n\nSome things that are also not that easy to decide and to implement are what should happen if the the user closes the socket or if get's destructed. -> Should the selector still return the aborted op or not\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32501552/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32520118",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32520118",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32520118,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTIwMTE4",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-16T19:24:00Z",
    "updated_at": "2014-01-16T19:24:00Z",
    "body": "@Matthias247, that sounds promising! I'm not quite understanding how everything quite works right now, and I'm not sure how async reads play into all this (and how they work in general).\n\nFor me, I would start designing all this with an understanding of what primitives we actually have to deal with:\n- libgreen - `uv_poll_t` and `uv_read_start`/`uv_read_stop` (we can't cancel writes). Note that using `uv_read_start` and `uv_read_stop` is currently not possible because you're not guaranteed that all I/O handles are on the same event loop. This means that for `libgreen` the only solution I can think of is `uv_poll_t` which is sadly super slow on windows (according to the documentation)\n- libnative linux - epoll\n- libnative osx - kqueue (which I believe is very similar to epoll)\n- libnative - select (probably want to use epoll instead)\n\nThat's what I know of, I don't really know of what windows has to offer on this front. Do you know of any good docs I can read up about windows apis?\n\nI very much like the idea of a `Selector` object, I think that any design will end up using that. I'm not entirely sure what the api would look like though. I like your idea of adding kinda arbitrary events to the object. I'm not really a fan of dealing with `set_blocking` or a `read_async` method (what does `read_async` do?).\n\nI don't think that you necessarily need to consume the I/O handle but rather just take a mutable loan on it to prevent further usage. You would regain usage when you drop the select handle returned to you. Regardless, something along these lines sound like a good idea.\n\nAll in all, this sounds really promising!\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32520118/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32520616",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32520616",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32520616,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTIwNjE2",
    "user": {
      "login": "lilyball",
      "id": 714,
      "node_id": "MDQ6VXNlcjcxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lilyball",
      "html_url": "https://github.com/lilyball",
      "followers_url": "https://api.github.com/users/lilyball/followers",
      "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
      "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
      "organizations_url": "https://api.github.com/users/lilyball/orgs",
      "repos_url": "https://api.github.com/users/lilyball/repos",
      "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lilyball/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-16T19:30:09Z",
    "updated_at": "2014-01-16T19:30:09Z",
    "body": "I would really like the ability to select on both I/O and Chans simultaneously. I also need to be able to wrap `TcpStream` in a `BufferedReader` (or `BufferedStream`) and have it still work.\n\n@Matthias247 Assuming your proposal does not allow for selecting on Chans as well, and it doesn't appear to, then the only alternative is to spawn an extra task in order to provide a Chan-based interface to the stream. This is less than ideal, especially when using libnative. And I need to be able to buffer the stream because I need a line-based interface and that's what `BufferedReader` provides.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32520616/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32520927",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32520927",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32520927,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTIwOTI3",
    "user": {
      "login": "sw17ch",
      "id": 95705,
      "node_id": "MDQ6VXNlcjk1NzA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/95705?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sw17ch",
      "html_url": "https://github.com/sw17ch",
      "followers_url": "https://api.github.com/users/sw17ch/followers",
      "following_url": "https://api.github.com/users/sw17ch/following{/other_user}",
      "gists_url": "https://api.github.com/users/sw17ch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sw17ch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sw17ch/subscriptions",
      "organizations_url": "https://api.github.com/users/sw17ch/orgs",
      "repos_url": "https://api.github.com/users/sw17ch/repos",
      "events_url": "https://api.github.com/users/sw17ch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sw17ch/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-16T19:33:25Z",
    "updated_at": "2014-01-16T19:33:54Z",
    "body": "@alexcrichton could you explain how `select` would be generic where `split` would not? I don't think I follow and understanding this would help me understand just a bit better a `select` interface over a `split` interface. :)\n\nEdit: initial comment about being generic was here: https://github.com/mozilla/rust/issues/11165#issuecomment-31280439\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32520927/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32521713",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32521713",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32521713,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTIxNzEz",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-16T19:41:54Z",
    "updated_at": "2014-01-16T19:41:54Z",
    "body": "@kballard selecting over I/O and chans is pretty difficult, the only reasonable solution I know of is to convert a `Chan` to an OS pipe underneath and spawn a task that recvs and then `write`s or something like that. You're fundamentally dealing with file descriptors and \"something else\", and all interfaces that I know of only deal with file descriptors.\n\n@sw17ch You'd only need to implement `select` once, but all I/O objects would have to opt-in to being selectable. There'd be a small amount of glue for what an I/O object needs to tell the `Selector` how to select on it. With `split`, you'd have to managed the split halves on _all_ primitives, meaning you're reimplementing the same sort of dup/arc/refcnt code across all of them. Additionally, it's unclear what split should return. Should it return a `TcpReader` and a `TcpWriter`, a `~Reader` and `~Writer`, a `TcpReader` and a `~Writer`, or should it actually return two `TcpStream` objects? I'm not really happy with any of the answers, but they all have their merits.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32521713/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32522073",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32522073",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32522073,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTIyMDcz",
    "user": {
      "login": "lilyball",
      "id": 714,
      "node_id": "MDQ6VXNlcjcxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lilyball",
      "html_url": "https://github.com/lilyball",
      "followers_url": "https://api.github.com/users/lilyball/followers",
      "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
      "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
      "organizations_url": "https://api.github.com/users/lilyball/orgs",
      "repos_url": "https://api.github.com/users/lilyball/repos",
      "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lilyball/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-16T19:45:49Z",
    "updated_at": "2014-01-16T19:45:49Z",
    "body": "@alexcrichton Cocoa's `NSRunLoop` manages to handle all sorts of different \"sources\", including file descriptors, mach messages, timers, and arbitrary user-defined sources.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32522073/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32524697",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32524697",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32524697,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTI0Njk3",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-16T19:50:59Z",
    "updated_at": "2014-01-16T19:50:59Z",
    "body": "Something like `NSRunLoop` is much more specific though because you have previous knowledge about being an event loop and hence all events are synchronized. We're dealing with a much more parallel context where we have no such knowledge (all events can happen simultaneously).\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32524697/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32528715",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32528715",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32528715,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTI4NzE1",
    "user": {
      "login": "lilyball",
      "id": 714,
      "node_id": "MDQ6VXNlcjcxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lilyball",
      "html_url": "https://github.com/lilyball",
      "followers_url": "https://api.github.com/users/lilyball/followers",
      "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
      "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
      "organizations_url": "https://api.github.com/users/lilyball/orgs",
      "repos_url": "https://api.github.com/users/lilyball/repos",
      "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lilyball/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-16T19:53:35Z",
    "updated_at": "2014-01-16T19:53:35Z",
    "body": "@alexcrichton What do you mean? Multiple sources in `NSRunLoop` can fire simultaneously. Events can be delivered, fds become available for reading/writing, and custom `CFRunLoopSource`s may be signaled all at the same time, and when the runloop wakes up (or returns from processing the previous callback) it has to pick among the available sources to fire the next callback. The analogous behavior in a `select`-style API would be to pick from among the available sources to return an index (presumably picking randomly).\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32528715/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32528745",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32528745",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32528745,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTI4NzQ1",
    "user": {
      "login": "Matthias247",
      "id": 6330334,
      "node_id": "MDQ6VXNlcjYzMzAzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthias247",
      "html_url": "https://github.com/Matthias247",
      "followers_url": "https://api.github.com/users/Matthias247/followers",
      "following_url": "https://api.github.com/users/Matthias247/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthias247/orgs",
      "repos_url": "https://api.github.com/users/Matthias247/repos",
      "events_url": "https://api.github.com/users/Matthias247/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthias247/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-16T19:53:57Z",
    "updated_at": "2014-01-16T19:53:57Z",
    "body": "@alexcrichton \nFor the I/O primitives you are basically right.\nThe Windows equivalent for epoll and kqueue are IO completion ports (IOCP).\nThere are various resources on the net, but I don't know what's really good. If you want to see how it's used - you know the libuv sources :-)\nIOCP has a major difference to epoll and kqueue: You don't wait for the OS telling you that a object is ready to do sth. but instead just start the operation and let it tell you when it's ready. Therefore a common API for the 2 worlds is different. And all that have done one (libuv, boost::asio) have gone for the completion based one, which I tried to mimic here in Rust -> 'read_async' starts the asynchronous operation. The main difference is that I don't automatically invoke callbacks.\n\nIf libnative has good async-capable I/O implementation that could be the basis also for the libgreen main threads instead of using uv. However that's propably a far future vision.\nThe main target I see currently is to get good API in one implementation so that the others can be adjusted to the same one. Regarding `set_blocking`: I see switching between blocking and nonblocking also as a fundamental feature for very fast I/O. In my experience the lowest latency I/O is trying to do nonblocking calls and only when they fail fallback to using the Selector. If you don't want to deal with it you don't have to and can just stay on blocking and async reads.\n\n@kballard Of course the target is to get this also running on Channels. And on Timers. Propably not on files.\nI only have it not yet implemented. Want to finish sockets first.\n@alexcrichton It should be doable. At least libuv can already do it too. The basic challenge is to wakeup the Selector when the Channel is associated to one and message is delivered. As you already said, it can be done with self pipes, or on Linux with eventfd and on Win also somehow. I'm also sure that kqueue provides a sophisticated way.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32528745/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32529188",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32529188",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32529188,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTI5MTg4",
    "user": {
      "login": "Matthias247",
      "id": 6330334,
      "node_id": "MDQ6VXNlcjYzMzAzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthias247",
      "html_url": "https://github.com/Matthias247",
      "followers_url": "https://api.github.com/users/Matthias247/followers",
      "following_url": "https://api.github.com/users/Matthias247/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthias247/orgs",
      "repos_url": "https://api.github.com/users/Matthias247/repos",
      "events_url": "https://api.github.com/users/Matthias247/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthias247/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-16T19:58:35Z",
    "updated_at": "2014-01-16T20:29:34Z",
    "body": "@sw17ch \nI even think both approaches are possible in parallel.\nIn my approach I at first create a `TcpStream` that is a very simple (non-threadsafe and not async-capable) object, which can be freely moved between threads.\nNow in my example I have gone in one direction and mutated it into a 'SelectableTcpStream' that adds the async and select capabilities.\nAnother approach would be to mutate from a 'TcpStream'  into a a split Read and WriteStream, which could work by creating new objects which use a mutex to share the underlying TcpStream.\n\nWhat I like better about the other solution is that the split TcpStream still does not solve things like receiving and listening to a timer in parallel.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32529188/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32530640",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32530640",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32530640,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTMwNjQw",
    "user": {
      "login": "sw17ch",
      "id": 95705,
      "node_id": "MDQ6VXNlcjk1NzA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/95705?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sw17ch",
      "html_url": "https://github.com/sw17ch",
      "followers_url": "https://api.github.com/users/sw17ch/followers",
      "following_url": "https://api.github.com/users/sw17ch/following{/other_user}",
      "gists_url": "https://api.github.com/users/sw17ch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sw17ch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sw17ch/subscriptions",
      "organizations_url": "https://api.github.com/users/sw17ch/orgs",
      "repos_url": "https://api.github.com/users/sw17ch/repos",
      "events_url": "https://api.github.com/users/sw17ch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sw17ch/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-16T20:14:26Z",
    "updated_at": "2014-01-16T20:14:26Z",
    "body": "> What I like better about the other solution is that the split TcpStream still does not solve things like receiving and listening to a timer in parallel.\n\nAh, good point. It would be nice to have a better 'event' API in general, I suppose.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32530640/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32798282",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32798282",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32798282,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzk4Mjgy",
    "user": {
      "login": "Matthias247",
      "id": 6330334,
      "node_id": "MDQ6VXNlcjYzMzAzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthias247",
      "html_url": "https://github.com/Matthias247",
      "followers_url": "https://api.github.com/users/Matthias247/followers",
      "following_url": "https://api.github.com/users/Matthias247/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthias247/orgs",
      "repos_url": "https://api.github.com/users/Matthias247/repos",
      "events_url": "https://api.github.com/users/Matthias247/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthias247/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-20T21:22:47Z",
    "updated_at": "2014-01-20T21:26:42Z",
    "body": "In the meanwhile I'm one step further.\nWhat I also didn't like that much about my last approach was the statefulness and the complexity of using the async send and receive methods. I then decided to review what others do and had a look at the Go, D and Erlang libraries (but they didn't help too much).\n\nI then had another idea that I decided to try. It's basically a quite old (aka rusty) concept, which is basically a mixture of of what QT or AS3 networking APIs or the Windows wndproc look like.\n\nBut as code says more than 1000 words I simply start with an example that I have running (on Linux):\n\n``` rust\nfn main() {\n    // Create an event queue. That's the central element instead of Select\n    let mut ev_queue = EventQueue::new(); \n    // Create a port/chan pair. Same as rust std API, but different in implementation\n    let (port,chan): (Port<~str>, Chan<~str>) = Chan::new();\n    // Upgrade the port to a selectable port. Still need another name for that\n    let mut selport = SelectablePort::from_port(port, &ev_queue);\n\n    // Create an event based timer \n    let mut main_timer = Timer::create(&ev_queue).unwrap();\n    main_timer.set_interval(2000);  \n    main_timer.start();\n\n    // Start a subtask that communicates with us\n    do native::task::spawn() {\n        subtask(chan);\n    }\n\n    loop {\n        // Wait for events to arrive\n        let event = ev_queue.next_event().unwrap();         \n\n        // Look for the origin and the type and then check what to do\n        if event.originates_from(selport) {\n            match event.event_type {\n                event::ChannelMessageEvent => {\n                    // We know that we received a message and can fetch it in a nonblocking style\n                    let msg = selport.recv().unwrap();\n                    println!(\"Message from subtask: {}\", msg);\n                },\n                event::ChannelClosedEvent => {\n                    // Oh, the channel seams dead now\n                    println!(\"Subtask closed\");\n                    return;\n                },\n                _ => ()\n            }\n        }\n        else if event.originates_from(main_timer) {\n            // The timer send a tick event\n            println!(\"main_timer::tick()\");\n        }\n    }\n}\n\nfn subtask(chan: Chan<~str>) {\n    // The other task also gets an event queue and a timer\n    let mut ev_queue = EventQueue::new();\n    let mut sub_timer = Timer::create(&ev_queue).unwrap();\n    let mut iterations = 3;\n    let mut stream_alive = false;\n\n    // We will play with TCP here, so let's connect to somewhere. This is currently blocking\n    let opt_ipaddr:Option<IpAddr> = FromStr::from_str(\"192.168.1.99\");\n    let socketaddr = SocketAddr {ip: opt_ipaddr.unwrap(), port: 8000};\n    let mut rawstream = TcpStream::connect(socketaddr).unwrap();\n    let mut stream = SelectableTcpStream::from_tcp_stream(rawstream, &ev_queue);\n    stream_alive = true;\n\n    // Start a timer\n    sub_timer.set_interval(3000);   \n    sub_timer.start();\n\n    // Send a request. This is also currently blocking\n    let request = ~\"GET /index.html HTTP/1.1\\r\\n\\r\\n\";\n    stream.write(request.as_bytes());\n    iterations -= 1;\n\n    loop {\n        // Fetch events and checkout what to do\n        let event = ev_queue.next_event().unwrap();\n\n        if event.originates_from(sub_timer) {\n            // Send something to the mainthread.\n            chan.send(~\"subtimer::tick()\");\n            if !stream_alive {              \n                if iterations > 0 {\n                    iterations -= 1;\n                    // Create a new stream. The old one wil be killed through RAII here\n                    rawstream = TcpStream::connect(socketaddr).unwrap();\n                    stream = SelectableTcpStream::from_tcp_stream(rawstream, &ev_queue);\n                    stream_alive = true;\n                    stream.write(request.as_bytes());\n                }\n                else {\n                    return;                     \n                }\n            }\n        }\n        else if event.originates_from(stream) {\n            match event.event_type {\n                event::StreamClosedEvent => {\n                    // Oops, the TCP connection was closed by the remote\n                    chan.send(~\"TCP connection closed\");\n                    stream_alive = false;\n                },\n                event::DataAvailableEvent(nr_bytes) => {\n                    // Yay, we know that we received at least nr_bytes and can \"safely\" read them in a nonblocking fashion\n                    let mut buffer: ~[u8] = std::vec::from_elem::<u8>(nr_bytes, 0);\n                    let read_res = stream.read(buffer);\n                    match read_res {\n                        Err(err) => {\n                            chan.send(err.desc.to_owned());\n                        }\n                        Ok(nr_read) => {\n                            let txt = std::str::from_utf8(buffer.slice(0, nr_read));\n                            chan.send(txt.to_owned());\n                        }\n                    }\n                },\n                _ => ()\n            }\n        }\n    }\n\n    // Stop my IO performing objects. This will also by done in RAII style if you forget it.\n    sub_timer.stop();\n    stream.close();\n}\n```\n\nOoh, and of course the glorious output:\n\n```\nMessage from subtask: HTTP/1.1 500 Internal Server Error\n\nMessage from subtask: TCP connection closed\nmain_timer::tick()\nMessage from subtask: subtimer::tick()\nMessage from subtask: HTTP/1.1 500 Internal Server Error\n\nMessage from subtask: TCP connection closed\nmain_timer::tick()\nmain_timer::tick()\nMessage from subtask: subtimer::tick()\nMessage from subtask: HTTP/1.1 500 Internal Server Error\n\nMessage from subtask: TCP connection closed\nmain_timer::tick()\nMessage from subtask: subtimer::tick()\nSubtask closed\n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32798282/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32803782",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32803782",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32803782,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODAzNzgy",
    "user": {
      "login": "Matthias247",
      "id": 6330334,
      "node_id": "MDQ6VXNlcjYzMzAzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthias247",
      "html_url": "https://github.com/Matthias247",
      "followers_url": "https://api.github.com/users/Matthias247/followers",
      "following_url": "https://api.github.com/users/Matthias247/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthias247/orgs",
      "repos_url": "https://api.github.com/users/Matthias247/repos",
      "events_url": "https://api.github.com/users/Matthias247/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthias247/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-20T22:35:47Z",
    "updated_at": "2014-01-20T23:20:30Z",
    "body": "Ok, so after the code example some more info about it.\n\n# The concept\n\nAs you can see the whole asynchronous functionality is build around events which are dispatched from an event queue. The events notifiy the user that something has happened, is ready or was finished.\n\nAn event is something quite simply and lightweight:\n\n``` rust\npub struct Event\n{\n    event_type: EventKind, // The type of the event which occured and all necessary info\n    is_valid: bool, // Internally used\n    source: Rc<bool> // source of the event. Type is not relevant for the user\n}\n\n// All types of events that are known. This is what I used in the examples, but there would be much more\n// Rusts enums are really a great way to describe different kinds of events and their associated data\npub enum EventKind\n{\n    StreamClosedEvent,\n    IoErrorEvent(IoError),\n    DataAvailableEvent(uint),\n    TimerEvent,\n    ChannelClosedEvent,\n    ChannelMessageEvent,\n    ...,\n    SignalReceived(uint),\n    DnsQueryResolved(),\n    PacketReceived(uint)\n}\n```\n\nThat makes the API somewhat similar to the `select/poll/...`, but is at a higher level and therefore much easier to use. Qt performs quite in the same way. The difference is they send a signal/callback that there is data to read and then you can start reading it. Here you must find the mapping from the Event to the associated object yourself. But I want to add 2 more fields to the Event so that you can automatize it:\n\n``` rust\npub struct Event\n{\n    ...\n    callback_fn: fn(ev: &Event),\n    user_data: ~Any\n}\n```\n\nThen you could build a callback style eventloop as simple as\n\n``` rust\nloop {\n        // Wait for events to arrive\n        let event = ev_queue.next_event().unwrap(); \n        event.callback_fn(event);\n}\n```\n\nThings that are also relevant to me:\n- An event that is not processed should not be harmful. Accessing I/O objects without waiting for the events also shouldn't be it.\n- The `EventQueue` should only return one event at a time. Only in this way it can be guaranteed that the event is valid in the moment it is passed to the user. \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32803782/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32806769",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-32806769",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 32806769,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODA2NzY5",
    "user": {
      "login": "Matthias247",
      "id": 6330334,
      "node_id": "MDQ6VXNlcjYzMzAzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthias247",
      "html_url": "https://github.com/Matthias247",
      "followers_url": "https://api.github.com/users/Matthias247/followers",
      "following_url": "https://api.github.com/users/Matthias247/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthias247/orgs",
      "repos_url": "https://api.github.com/users/Matthias247/repos",
      "events_url": "https://api.github.com/users/Matthias247/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthias247/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-20T23:18:10Z",
    "updated_at": "2014-01-20T23:18:10Z",
    "body": "# The implementation\n\nI currently only have a Linux 1:1 implementation, but also have some ideas of how it works in other environments.\nHere the `EventQueue` is based on epoll. The IO objects use fd's (timerfd, eventfd, socket fd) and register at the `EventQueue`. When a fd is readable a callback is invoked on the IO object which produces new events.\nFor the port/channel I'm currently doing 2way signalization. As long as the port is freestanding (not associated to an `EventQueue` I'm using a condition variable to wakeup the port from the channel. If it's associated I send a message through eventfd.\n\nThe hardest thing to get right are the sockets. The APIs differ here very much. I decided to give a high level view of what happend to the user, e.g. directly if and how many bytes are readable, if the connection was closed or what error occured. Might not be the highest performant, but all OSes can provide the information in some way and it gives an easy to understand API to the user.\n- For OSX the API is very good, because kqueue immediatly delivers all the information that is required for producing an event.\n- For Linux the API is not that good, because epoll doesn't deliver an information how many bytes are readable. It event doesn't tell whether the connection was closed. Only that the fd is readable. Delivering only the information that a socket is readable and not what will happen than on all OSes sounded less appealing, so I rejected it. As an result I need an extra `ioctl()` to receive the number of readable bytes. I think the performance drawback depends on the applications protocol. Some applications always want to read as much data as they can. These might suffer a little bit. Others might profit because they know from the start how many bytes can be safely read and thereby safe the cost for an unnecessary `read()` call.\n- On Windows the situation is the most complicated, because it won't give any direct information about readable data. There are 2 workarounds for this:\n  a) Start an asynchronous read for 0 bytes after the socket is connected. When that completes we know that there is data available for read. For the amount also an `ioctl` would be needed.\n  b) Create one or more socket internal buffers, start the asynchronous read with that one and if it completes you will know how many data is there. When the application reads, it would read from that buffer (and not from the socket buffer). Advantage of 2 is higher throughput and lower latency. Disadvantage is higher memory usage (you need to preallocate memory for each connection).\n  I'm in the favor of a) or propably a setting that allows b) optionally as a \"buffered mode\".\n\nA question that also arises from the last one is what should happen if the application calls `socket.read()` even when it didn't got a notification about readable bytes. It could either block until something is readable or it could return 0. I decided to go for the last one, because:\n- It eliminates possibly unintended blocking\n- It is easier to implement on Windows, because what should you do when you have a pending 0 byte read (that will be finished later in the same thread) and now must perform another read? I currently don't know whether such reads are cancellable.\n\nI also decided to automatically close connections after the first error, so that users don't get further spurious errors.\n\nWrites are currently blocking because that's the easiest thing to implement. You must not care about how to hold the data-to-send alive until a background write would be finished. That's propably suboptimal for applications which send lot's of data (which would cause the socket buffer to fill and thereby block). And also suboptimal if you would use it as a base for a M:N scheduler.\nMaybe an option would be to implement a nonblocking setting that still allows users to synchronously call the write but writes all data that could not be sent immediatly in the background.\n- For owned buffers the application could pass those to the socket and the socket queues these until they can be sent on following epoll calls. After they were fully sent a `MessageSentEvent(~[u8])` could be produced to give the buffer back to the application for reuse. That's similar to what libuv does.\n- For referenced buffers the socket would have to copy the data in the socket into an internal buffer for sending it later.\n  Basically it's an optimization thing, for the start I would think most people would be happy with blocking writes.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/32806769/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33162318",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-33162318",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 33162318,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTYyMzE4",
    "user": {
      "login": "thadguidry",
      "id": 986438,
      "node_id": "MDQ6VXNlcjk4NjQzOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/986438?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thadguidry",
      "html_url": "https://github.com/thadguidry",
      "followers_url": "https://api.github.com/users/thadguidry/followers",
      "following_url": "https://api.github.com/users/thadguidry/following{/other_user}",
      "gists_url": "https://api.github.com/users/thadguidry/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thadguidry/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thadguidry/subscriptions",
      "organizations_url": "https://api.github.com/users/thadguidry/orgs",
      "repos_url": "https://api.github.com/users/thadguidry/repos",
      "events_url": "https://api.github.com/users/thadguidry/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thadguidry/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-23T20:00:27Z",
    "updated_at": "2014-01-23T20:03:52Z",
    "body": "FYI,\n\nGetQueuedCompletionStatus has a big impact on Async I/O stream processing on Windows:\nhttp://msdn.microsoft.com/en-us/library/windows/desktop/aa365198(v=vs.85).aspx\n\nPart of Libuv usage is here:\nhttps://github.com/joyent/libuv/blob/7e68e6d895a9007736e53b592192fd9620a34ac6/src/win/timer.c#L31\nand\nhttps://github.com/joyent/libuv/blob/c0716b3d9f89e3557a482ce499e7abc8db686418/src/win/core.c\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33162318/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33293494",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-33293494",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 33293494,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjkzNDk0",
    "user": {
      "login": "Matthias247",
      "id": 6330334,
      "node_id": "MDQ6VXNlcjYzMzAzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthias247",
      "html_url": "https://github.com/Matthias247",
      "followers_url": "https://api.github.com/users/Matthias247/followers",
      "following_url": "https://api.github.com/users/Matthias247/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthias247/orgs",
      "repos_url": "https://api.github.com/users/Matthias247/repos",
      "events_url": "https://api.github.com/users/Matthias247/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthias247/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-25T16:52:49Z",
    "updated_at": "2014-01-25T16:52:49Z",
    "body": "Ok, I uploaded here what I currently have: https://github.com/Matthias247/revbio\n\nIt currently event-based TCP sockets (including asynchronous connects), Channels and Timers for Linux.\nMore to come - if anybody is interested and I have enough time for it.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33293494/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33337539",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-33337539",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 33337539,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzM3NTM5",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-27T01:52:09Z",
    "updated_at": "2014-01-27T01:52:09Z",
    "body": "How would others feel about all I/O returning `(XXXReader, XXXWriter)`, similarly to how channels work right now?\n\nThis would remove the `XXXStream` types, and would probably have top-level functional constructors (like we seem to be migrating towards with channels). Just a thought!\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33337539/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33337863",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-33337863",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 33337863,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzM3ODYz",
    "user": {
      "login": "sfackler",
      "id": 1455697,
      "node_id": "MDQ6VXNlcjE0NTU2OTc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sfackler",
      "html_url": "https://github.com/sfackler",
      "followers_url": "https://api.github.com/users/sfackler/followers",
      "following_url": "https://api.github.com/users/sfackler/following{/other_user}",
      "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions",
      "organizations_url": "https://api.github.com/users/sfackler/orgs",
      "repos_url": "https://api.github.com/users/sfackler/repos",
      "events_url": "https://api.github.com/users/sfackler/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sfackler/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-27T02:03:55Z",
    "updated_at": "2014-01-27T02:03:55Z",
    "body": "How about returning a lightweight struct instead?:\n\n``` rust\npub struct XXXStream {\n   reader: XXXReader,\n   writer: XXXWriter,\n}\n\nimpl Writer for XXXStream { ... }\n\nimpl Reader for XXXStream { ... }\n```\n\n`XXXStreams` are a bit distinct from channels in that channels will almost (always?) have distinct readers and writers. Using a lightweight wrapper makes makes the current use case continue to work while still making it easy to split the stream. You could do the same thing with a `(XXXReader, XXXWriter)` but that feels kind of hacky.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33337863/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33559174",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-33559174",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 33559174,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTU5MTc0",
    "user": {
      "login": "derekchiang",
      "id": 1535686,
      "node_id": "MDQ6VXNlcjE1MzU2ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535686?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/derekchiang",
      "html_url": "https://github.com/derekchiang",
      "followers_url": "https://api.github.com/users/derekchiang/followers",
      "following_url": "https://api.github.com/users/derekchiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/derekchiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/derekchiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/derekchiang/subscriptions",
      "organizations_url": "https://api.github.com/users/derekchiang/orgs",
      "repos_url": "https://api.github.com/users/derekchiang/repos",
      "events_url": "https://api.github.com/users/derekchiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/derekchiang/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-29T06:08:28Z",
    "updated_at": "2014-01-29T06:08:28Z",
    "body": "I can't imagine developing a programming language without people like @alexcrichton who keeps churning out amazing PRs :)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33559174/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33560739",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-33560739",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 33560739,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTYwNzM5",
    "user": {
      "login": "lilyball",
      "id": 714,
      "node_id": "MDQ6VXNlcjcxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lilyball",
      "html_url": "https://github.com/lilyball",
      "followers_url": "https://api.github.com/users/lilyball/followers",
      "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
      "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
      "organizations_url": "https://api.github.com/users/lilyball/orgs",
      "repos_url": "https://api.github.com/users/lilyball/repos",
      "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lilyball/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-29T06:51:47Z",
    "updated_at": "2014-01-29T07:39:18Z",
    "body": "@derekchiang Well, that is his job... ;)\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33560739/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33561807",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-33561807",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 33561807,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTYxODA3",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-29T07:20:52Z",
    "updated_at": "2014-01-29T07:20:52Z",
    "body": "Thanks @derekchiang! I'll try to keep them coming :)\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33561807/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33566177",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-33566177",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 33566177,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTY2MTc3",
    "user": {
      "login": "Matthias247",
      "id": 6330334,
      "node_id": "MDQ6VXNlcjYzMzAzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthias247",
      "html_url": "https://github.com/Matthias247",
      "followers_url": "https://api.github.com/users/Matthias247/followers",
      "following_url": "https://api.github.com/users/Matthias247/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthias247/orgs",
      "repos_url": "https://api.github.com/users/Matthias247/repos",
      "events_url": "https://api.github.com/users/Matthias247/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthias247/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-29T08:52:15Z",
    "updated_at": "2014-01-29T08:52:15Z",
    "body": "Hi everyone,\n\nwhen you go for the `clone()` route you really also have to add an explicit `close()` or `shutdown()` method. This is necessary for the write task to close the socket so that the read task get's an error and has the chance to return. Otherwise you still have a dead read task floating around.\nI have the opinion you nead that `close()` anyway, because RAII is cool, but it will not work as soon as anyone put's your Socket into a Gc<T>ed objected, which will happen for sure. You could argue that these all need to use Option<TcpStream> instead of TcpStream, but that adds yet another unnecessary workaround. I think that shuttding down the fd on one side while reading from another is no problem for native I/O. But I have no clue if it would work with libuv.\n\nHowever honestly I don't like the overall approach not too much at all, because in most advanced protocols the read task will not have the necessary context/state to interpret the data and will simply forward the data through a channel to the actual owner. Thereby your read-task get's converted into a pipe that forwards the data - with an unnecessary copy from the socket buffer to a temporary buffer. You could then go directly the way that Scala and Erlang do and make the TcpStream a seperate Actor(Task), which sends you all received data through a channel: http://doc.akka.io/docs/akka/snapshot/scala/io-tcp.html\nThat brings you pretty close to my solution, but you would only wait on channels instead of different typed objects.\n\nBesides that cloning the handle still don't solve problems like asynchronous connects (linux connect timeouts or ridicously long and the connect will block your task.) The standard workaround is to start a timer and a connect in parallel and see what finishes first.\nI mean you still could spawn more tasks to do another workaround. But that also means that the solution largely favours the green threads. Spawning `N` native threads just to handle a single connection doesn't look like the proper way to handle I/O for me in 2014.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33566177/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33761557",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-33761557",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 33761557,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNzYxNTU3",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-31T04:46:56Z",
    "updated_at": "2014-01-31T04:46:56Z",
    "body": "@Matthias247 In some cases it can be nice to have explicit dtors, and Rust has a really great pattern for it with by-value self. With shared I/O I could still imagine maintaining a reference count and only destroying the handle once all had called `.close()`, and not calling `.close()` fails in a dtor bomb.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33761557/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33796318",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-33796318",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 33796318,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNzk2MzE4",
    "user": {
      "login": "Matthias247",
      "id": 6330334,
      "node_id": "MDQ6VXNlcjYzMzAzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthias247",
      "html_url": "https://github.com/Matthias247",
      "followers_url": "https://api.github.com/users/Matthias247/followers",
      "following_url": "https://api.github.com/users/Matthias247/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthias247/orgs",
      "repos_url": "https://api.github.com/users/Matthias247/repos",
      "events_url": "https://api.github.com/users/Matthias247/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthias247/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-31T14:08:03Z",
    "updated_at": "2014-01-31T14:08:03Z",
    "body": "@brson I agree that the destruct-through-move-by-value semantics of Rust are a great pattern. However they don't help when your object is a member of another struct, which I assume to be often the case for TcpStream. You can't move out your stream without destroying the surrounding object. So a workaround is to use Option<TcpStream> to have a closeable stream, but then you have to pattern match each time you want to use it, which is quite bothersome.\n\nWith shared I/O you have many options to enable explicit `TcpStream::close()` and a destructor at the same time. They depend a little bit on how you implement the shared Stream:\n1. If you really use a cloned OS handle (like Alex currently) then you would most likely do a `shutdown(fd)` on an explicit `TcpStream::close()`. This would allow the receving socket to unblock and detect the requested disconnection. `free`ing the socket would not help because it would have no affect on cloned `fd`s. You would `close(fd)` the `fd`s in the destructor of each cloned element. That also guarantees that if nobody called `TcpStream::close()` the socket would still get closed when it is no longer referenced.\n2. If you use a single handle and put that into a ARC to support cloning then you can either `shutdown()` or `close(fd)` when the user calls `TcpStream::close()`.  Both will cause active reads to unblock. If you use `close(fd)` then you also have to check in other opations like `read` or `write` or `drop` if the socket was already closed and give an error. `drop` is also not hard: If the socket is already closed then you don't have to close it again. If it was not closed before then close it. I used that in my linked library and also a lot of my @work networking code.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33796318/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33798678",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-33798678",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 33798678,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNzk4Njc4",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-31T14:38:47Z",
    "updated_at": "2014-01-31T14:38:47Z",
    "body": "I don't think Rust should move away from using RAII... It's far worse to need a `close` call _everywhere_ than it is to need `Option` in very rare cases.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33798678/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33800771",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-33800771",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 33800771,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzODAwNzcx",
    "user": {
      "login": "Matthias247",
      "id": 6330334,
      "node_id": "MDQ6VXNlcjYzMzAzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthias247",
      "html_url": "https://github.com/Matthias247",
      "followers_url": "https://api.github.com/users/Matthias247/followers",
      "following_url": "https://api.github.com/users/Matthias247/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthias247/orgs",
      "repos_url": "https://api.github.com/users/Matthias247/repos",
      "events_url": "https://api.github.com/users/Matthias247/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthias247/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-31T15:02:44Z",
    "updated_at": "2014-01-31T15:02:44Z",
    "body": "RAII is still there. If you don't need an explicit `close()` you can omit it and wait for the destructor to do it. Nearly all C++ APIs are laid out in the same way. You can explicetly close when your use-case requires it or you can wait for the end-of-scope.\n\nAnd how would you prevent Zombie tasks without beeing able to explicitely shudown a socket otherwise?\nI mean of you had a split between Reader and Writer you could at least say that a destruction of the writer shuts down the socket. But for cloned sockets you can't be sure that the socket is no longer needed after only one of the cloned handles is destroyed.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33800771/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33801029",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-33801029",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 33801029,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzODAxMDI5",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-31T15:05:48Z",
    "updated_at": "2014-01-31T15:05:48Z",
    "body": "> RAII is still there.\n\nNo, it's not. It just becomes the same mess as finalizers in Java and Python.\n\nThe C++ standard library does not use RAII for I/O. It can't, as that part of the standard library was written before exceptions existed and had no way to report errors from constructors. It's a pretty bad example to use.\n\n> I mean of you had a split between Reader and Writer you could at least say that a destruction of the writer shuts down the socket. But for cloned sockets you can't be sure that the socket is no longer needed after only one of the cloned handles is destroyed.\n\nThat's a reason to move to splitting it instead of using `clone`, not an indication we should move away from RAII.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33801029/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33802880",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-33802880",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 33802880,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzODAyODgw",
    "user": {
      "login": "Matthias247",
      "id": 6330334,
      "node_id": "MDQ6VXNlcjYzMzAzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthias247",
      "html_url": "https://github.com/Matthias247",
      "followers_url": "https://api.github.com/users/Matthias247/followers",
      "following_url": "https://api.github.com/users/Matthias247/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthias247/orgs",
      "repos_url": "https://api.github.com/users/Matthias247/repos",
      "events_url": "https://api.github.com/users/Matthias247/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthias247/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-31T15:25:15Z",
    "updated_at": "2014-01-31T15:25:15Z",
    "body": "> No, it's not. It just becomes the same mess as finalizers in Java and Python.\n\nNo, it's not the same. They require you to write a finalizer. RAII when implemented like the following will work without anything explicit need to call `close()`\n\n``` rust\nimpl Drop for TcpStream {\n  fn drop(&mut self) { self.close(); }\n}\n```\n\nWhether that what C++ does is RAII depends on your definition of it. `std::fstream` for sure has an implicit close on destruct as well as explicit closes. Higher level libraries like ASIO or QT have it too. So when RAII means that you want to have a guarantee that if an object get's out of scope it is properly destructed then they have it. If you define it as \"if I have an object it is also guaranteed that the resource beneath it is alive\" then they don't have it. But for things like I/O you can't guarantee that anyway, because the resource can get closed without the influence of your application.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33802880/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33806403",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-33806403",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 33806403,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzODA2NDAz",
    "user": {
      "login": "thestinger",
      "id": 1505226,
      "node_id": "MDQ6VXNlcjE1MDUyMjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thestinger",
      "html_url": "https://github.com/thestinger",
      "followers_url": "https://api.github.com/users/thestinger/followers",
      "following_url": "https://api.github.com/users/thestinger/following{/other_user}",
      "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions",
      "organizations_url": "https://api.github.com/users/thestinger/orgs",
      "repos_url": "https://api.github.com/users/thestinger/repos",
      "events_url": "https://api.github.com/users/thestinger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thestinger/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-01-31T16:02:08Z",
    "updated_at": "2014-01-31T16:03:33Z",
    "body": "> They require you to write a finalizer.\n\nThey don't require you to write the finalizer each time. You implement the `__del__` method in Python one time, but it's not the comprehensive solution that RAII provides. Java is similar, but I don't know if it has an equivalent to the `del` statement.\n\n> RAII when implemented like the following will work without anything explicit need to call `close()`\n\nDestructors alone are not RAII. Resource Acquisition Is Initialization is a full resource management solution from construction to destruction.\n\n> So when RAII means that you want to have a guarantee that if an object get's out of scope it is properly destructed then they have it. If you define it as \"if I have an object it is also guaranteed that the resource beneath it is alive\" then they don't have it.\n\nThat's not what Resource Acquisition Is Initialization means.\n\n> But for things like I/O you can't guarantee that anyway, because the resource can get closed without the influence of your application.\n\nYou can guarantee it isn't _closed_. Whether a socket is still connected to the endpoint or the drive is broken is another story.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/33806403/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34587668",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-34587668",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 34587668,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTg3NjY4",
    "user": {
      "login": "dwrensha",
      "id": 495768,
      "node_id": "MDQ6VXNlcjQ5NTc2OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/495768?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dwrensha",
      "html_url": "https://github.com/dwrensha",
      "followers_url": "https://api.github.com/users/dwrensha/followers",
      "following_url": "https://api.github.com/users/dwrensha/following{/other_user}",
      "gists_url": "https://api.github.com/users/dwrensha/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dwrensha/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dwrensha/subscriptions",
      "organizations_url": "https://api.github.com/users/dwrensha/orgs",
      "repos_url": "https://api.github.com/users/dwrensha/repos",
      "events_url": "https://api.github.com/users/dwrensha/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dwrensha/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-09T21:37:34Z",
    "updated_at": "2014-02-09T21:38:50Z",
    "body": "I like the pattern of having a task whose only job is to read from a TcpStream and forward results to a Chan, and I agree with Matthias247 that we need a way to prevent that task from becoming a zombie, perhaps by adding some kind of shutdown() method to the TcpStream.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34587668/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34589834",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-34589834",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 34589834,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTg5ODM0",
    "user": {
      "login": "lilyball",
      "id": 714,
      "node_id": "MDQ6VXNlcjcxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lilyball",
      "html_url": "https://github.com/lilyball",
      "followers_url": "https://api.github.com/users/lilyball/followers",
      "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
      "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
      "organizations_url": "https://api.github.com/users/lilyball/orgs",
      "repos_url": "https://api.github.com/users/lilyball/repos",
      "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lilyball/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-09T22:41:28Z",
    "updated_at": "2014-02-09T22:41:28Z",
    "body": "@dwrensha That pattern works reasonably for green threading, but it's horrible for native threading. An entire OS thread should not be tied up just to block on I/O.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34589834/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34590082",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-34590082",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 34590082,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTkwMDgy",
    "user": {
      "login": "Matthias247",
      "id": 6330334,
      "node_id": "MDQ6VXNlcjYzMzAzMzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Matthias247",
      "html_url": "https://github.com/Matthias247",
      "followers_url": "https://api.github.com/users/Matthias247/followers",
      "following_url": "https://api.github.com/users/Matthias247/following{/other_user}",
      "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions",
      "organizations_url": "https://api.github.com/users/Matthias247/orgs",
      "repos_url": "https://api.github.com/users/Matthias247/repos",
      "events_url": "https://api.github.com/users/Matthias247/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Matthias247/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-09T22:49:36Z",
    "updated_at": "2014-02-09T22:49:36Z",
    "body": "@kballard But it's already implemented that way since merging of #11894 .\nEither the implementation needs to be fixed to work reliably in a real world application (e.g. by adding `shutdown()`) despite questionable performance with native threads or a complete redesign of the API is necessary.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34590082/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34657130",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-34657130",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 34657130,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NjU3MTMw",
    "user": {
      "login": "sw17ch",
      "id": 95705,
      "node_id": "MDQ6VXNlcjk1NzA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/95705?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sw17ch",
      "html_url": "https://github.com/sw17ch",
      "followers_url": "https://api.github.com/users/sw17ch/followers",
      "following_url": "https://api.github.com/users/sw17ch/following{/other_user}",
      "gists_url": "https://api.github.com/users/sw17ch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sw17ch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sw17ch/subscriptions",
      "organizations_url": "https://api.github.com/users/sw17ch/orgs",
      "repos_url": "https://api.github.com/users/sw17ch/repos",
      "events_url": "https://api.github.com/users/sw17ch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sw17ch/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-10T17:22:07Z",
    "updated_at": "2014-02-10T17:22:07Z",
    "body": "@Matthias247 @dwrensha @kballard \n\nI also like the single-reader-on-socket model, but only with green threads. Does the current API require the use of a native thread for the socket? I didn't read that into the implementation, but didn't look too hard.\n\nIs there something about the current model that doesn't behave nicely (other than the possibility of leaking the socket)?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34657130/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34664785",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-34664785",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 34664785,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NjY0Nzg1",
    "user": {
      "login": "lilyball",
      "id": 714,
      "node_id": "MDQ6VXNlcjcxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lilyball",
      "html_url": "https://github.com/lilyball",
      "followers_url": "https://api.github.com/users/lilyball/followers",
      "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
      "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
      "organizations_url": "https://api.github.com/users/lilyball/orgs",
      "repos_url": "https://api.github.com/users/lilyball/repos",
      "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lilyball/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-10T18:32:20Z",
    "updated_at": "2014-02-10T18:32:20Z",
    "body": "@sw17ch The current implementation does not require native threads for sockets. When using libgreen, sockets will go through libuv. The problem is that if you're writing library code, it can't control which threading model it's invoked in, and depending on your API you may not have the luxury of spinning up a libgreen thread pool for your socket tasks.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34664785/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34665744",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-34665744",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 34665744,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NjY1NzQ0",
    "user": {
      "login": "sw17ch",
      "id": 95705,
      "node_id": "MDQ6VXNlcjk1NzA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/95705?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sw17ch",
      "html_url": "https://github.com/sw17ch",
      "followers_url": "https://api.github.com/users/sw17ch/followers",
      "following_url": "https://api.github.com/users/sw17ch/following{/other_user}",
      "gists_url": "https://api.github.com/users/sw17ch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sw17ch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sw17ch/subscriptions",
      "organizations_url": "https://api.github.com/users/sw17ch/orgs",
      "repos_url": "https://api.github.com/users/sw17ch/repos",
      "events_url": "https://api.github.com/users/sw17ch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sw17ch/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-02-10T18:41:57Z",
    "updated_at": "2014-02-10T18:41:57Z",
    "body": "@kballard ah, thank you. This clears things up for me a lot.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/34665744/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/42526159",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-42526159",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 42526159,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTI2MTU5",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-05-08T08:48:10Z",
    "updated_at": "2014-05-08T08:48:10Z",
    "body": "Nominating for closure. We're in a much better state than when this was opened:\n1. I/O objects are cloneable (simultaneous reads/writes)\n2. I/O objects have timeouts\n3. I/O objects can close other ones (close_{read,write})\n\nI believe that this set of functionality encompasses the intent of this issue.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/42526159/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/42581487",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-42581487",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 42581487,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTgxNDg3",
    "user": {
      "login": "lilyball",
      "id": 714,
      "node_id": "MDQ6VXNlcjcxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lilyball",
      "html_url": "https://github.com/lilyball",
      "followers_url": "https://api.github.com/users/lilyball/followers",
      "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
      "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
      "organizations_url": "https://api.github.com/users/lilyball/orgs",
      "repos_url": "https://api.github.com/users/lilyball/repos",
      "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lilyball/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-05-08T17:45:17Z",
    "updated_at": "2014-05-08T17:45:17Z",
    "body": "@alexcrichton I believe that what you have listed does meet the original intent of this issue. But besides the ability to read/write simultaneously, there's a need for the ability to select over multiple I/O channels at once (or over the reading and writing halves of the same channel). Perhaps that should be covered under a separate ticket, but there was a lot of discussion in here already about doing just that.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/42581487/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/42606756",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-42606756",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 42606756,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNjA2NzU2",
    "user": {
      "login": "brson",
      "id": 147214,
      "node_id": "MDQ6VXNlcjE0NzIxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brson",
      "html_url": "https://github.com/brson",
      "followers_url": "https://api.github.com/users/brson/followers",
      "following_url": "https://api.github.com/users/brson/following{/other_user}",
      "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
      "organizations_url": "https://api.github.com/users/brson/orgs",
      "repos_url": "https://api.github.com/users/brson/repos",
      "events_url": "https://api.github.com/users/brson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-05-08T21:10:29Z",
    "updated_at": "2014-05-08T21:10:29Z",
    "body": "Closing! Yay!\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/42606756/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47062435",
    "html_url": "https://github.com/rust-lang/rust/issues/11165#issuecomment-47062435",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/11165",
    "id": 47062435,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MDYyNDM1",
    "user": {
      "login": "sw17ch",
      "id": 95705,
      "node_id": "MDQ6VXNlcjk1NzA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/95705?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sw17ch",
      "html_url": "https://github.com/sw17ch",
      "followers_url": "https://api.github.com/users/sw17ch/followers",
      "following_url": "https://api.github.com/users/sw17ch/following{/other_user}",
      "gists_url": "https://api.github.com/users/sw17ch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sw17ch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sw17ch/subscriptions",
      "organizations_url": "https://api.github.com/users/sw17ch/orgs",
      "repos_url": "https://api.github.com/users/sw17ch/repos",
      "events_url": "https://api.github.com/users/sw17ch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sw17ch/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2014-06-25T05:39:25Z",
    "updated_at": "2014-06-25T05:39:25Z",
    "body": ":clap: \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/47062435/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
