[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/129059459",
    "html_url": "https://github.com/rust-lang/rust/issues/27610#issuecomment-129059459",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/27610",
    "id": 129059459,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEyOTA1OTQ1OQ==",
    "user": {
      "login": "Gankra",
      "id": 1136864,
      "node_id": "MDQ6VXNlcjExMzY4NjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Gankra",
      "html_url": "https://github.com/Gankra",
      "followers_url": "https://api.github.com/users/Gankra/followers",
      "following_url": "https://api.github.com/users/Gankra/following{/other_user}",
      "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions",
      "organizations_url": "https://api.github.com/users/Gankra/orgs",
      "repos_url": "https://api.github.com/users/Gankra/repos",
      "events_url": "https://api.github.com/users/Gankra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Gankra/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-08-08T22:46:18Z",
    "updated_at": "2015-08-08T22:46:18Z",
    "body": "cc @aturon \n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/129059459/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/144827793",
    "html_url": "https://github.com/rust-lang/rust/issues/27610#issuecomment-144827793",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/27610",
    "id": 144827793,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE0NDgyNzc5Mw==",
    "user": {
      "login": "talchas",
      "id": 3578697,
      "node_id": "MDQ6VXNlcjM1Nzg2OTc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3578697?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/talchas",
      "html_url": "https://github.com/talchas",
      "followers_url": "https://api.github.com/users/talchas/followers",
      "following_url": "https://api.github.com/users/talchas/following{/other_user}",
      "gists_url": "https://api.github.com/users/talchas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/talchas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/talchas/subscriptions",
      "organizations_url": "https://api.github.com/users/talchas/orgs",
      "repos_url": "https://api.github.com/users/talchas/repos",
      "events_url": "https://api.github.com/users/talchas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/talchas/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-10-01T19:49:49Z",
    "updated_at": "2015-10-01T19:49:49Z",
    "body": "(mentioning this later, but load(SeqCst) doesn't actually emit a barrier on x86 since C11 is weird, so while things can be relaxed, it's far less of a problem than I thought)\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/144827793/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/240571813",
    "html_url": "https://github.com/rust-lang/rust/issues/27610#issuecomment-240571813",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/27610",
    "id": 240571813,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MDU3MTgxMw==",
    "user": {
      "login": "comex",
      "id": 47517,
      "node_id": "MDQ6VXNlcjQ3NTE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/47517?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/comex",
      "html_url": "https://github.com/comex",
      "followers_url": "https://api.github.com/users/comex/followers",
      "following_url": "https://api.github.com/users/comex/following{/other_user}",
      "gists_url": "https://api.github.com/users/comex/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/comex/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/comex/subscriptions",
      "organizations_url": "https://api.github.com/users/comex/orgs",
      "repos_url": "https://api.github.com/users/comex/repos",
      "events_url": "https://api.github.com/users/comex/events{/privacy}",
      "received_events_url": "https://api.github.com/users/comex/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-08-17T22:43:26Z",
    "updated_at": "2016-08-17T22:43:26Z",
    "body": "In some situations it's possible to implement Once with no memory barrier at all in the common case (except for a compiler barrier to preventing the compiler from reordering instructions across it).  This doesn't matter on x86, since as talchas noted, SeqCst loads don't require a barrier on x86 anyway, but on ARM it could help.  Since typical usage of 'once' executes the no-op case far more often than the initialization case, improving performance of the former may be justified even at the expense of adding quite a bit of overhead to the latter.\n\nThe first way to do this is to just get the OS to execute barriers on all other cores of the system.  Windows has had a syscall to do this since Vista (and thus on all ARM editions), `FlushProcessWriteBuffers`.  Linux has had a similar syscall, `membarrier`, only since late 2015, but [there are hacky ways](https://lists.lttng.org/pipermail/lttng-dev/2015-March/024261.html) to accomplish the same on older versions.  (The linked mailing list discussion occurred before the syscall was added; there is some skepticism of the hack there because of the potential for it to stop working on future versions of Linux, but since all future versions will now support the syscall, the hack should be fine as a fallback for old versions.)\n\nI don't believe iOS has such a syscall.  But in _some_ cases it's possible to do something different, because iOS only runs on Apple CPUs and Apple has a trick:\n\nhttps://www.mikeash.com/pyblog/friday-qa-2014-06-06-secrets-of-dispatch_once.html\n\n(The linked blog post refers to OS X and Intel CPUs, but as I said, the whole thing is redundant on x86; iOS, however, uses the same code.)\n\nI'm not suggesting that libstd implement this trick itself, at least on the write side: the library where Apple implements it is always dynamically linked and so Apple retains the option of having future CPUs require something else, and updating the OS to suit.  But the read side of `dispatch_once` is present as an inlineable (indeed, `always_inline`) function in a system C header, which more or less means it must keep working forever, and (combined with the reasonable storage requirement, `typedef long dispatch_once_t;`) also means that using it would be as efficient as the current reimplementation - so Once on OS X could just be a wrapper around `dispatch_once`.  Rust code can't properly inline it (without some fancy LTO stuff), but we could just reimplement the body in Rust to simulate the effect of inlining.  It looks like this:\n\n``` c\nDISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL_ALL DISPATCH_NOTHROW\nvoid\n_dispatch_once(dispatch_once_t *predicate,\n        DISPATCH_NOESCAPE dispatch_block_t block)\n{\n    if (DISPATCH_EXPECT(*predicate, ~0l) != ~0l) {\n        dispatch_once(predicate, block);\n    } else {\n        dispatch_compiler_barrier();\n    }\n    DISPATCH_COMPILER_CAN_ASSUME(*predicate == ~0l);\n}\n```\n\n...Except for one huge caveat that would make actually implementing this extremely difficult.  The [documentation for `dispatch_once_t`](https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/func/dispatch_get_global_queue) says:\n\n> Variables of this type must have global or static scope. The result of using this type with automatic or dynamic allocation is undefined.\n\nAnd of course `Once` has no such requirement.  I suppose it was added out of the fear that another core could load a stale cached value for the status word from before the `dispatch_once_t` was initialized, which in many cases is impossible for some other reason, but not all.  Therefore, this whole technique on iOS would only be useful if the compiler could statically detect whether a given `Once` object is stored as a global, and use a memory barrier if not, and I can't think of any existing mechanism that would allow such a thing.  Oh well.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/240571813/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/241934594",
    "html_url": "https://github.com/rust-lang/rust/issues/27610#issuecomment-241934594",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/27610",
    "id": 241934594,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MTkzNDU5NA==",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-08-24T01:44:38Z",
    "updated_at": "2016-08-24T01:44:38Z",
    "body": "> And of course Once has no such requirement.\n\nI'm not sure what you mean. This is the signature for `call_once`:\n\n``` rust\nfn call_once<F>(&'static self, f: F) \n```\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/241934594/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/242256114",
    "html_url": "https://github.com/rust-lang/rust/issues/27610#issuecomment-242256114",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/27610",
    "id": 242256114,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0MjI1NjExNA==",
    "user": {
      "login": "comex",
      "id": 47517,
      "node_id": "MDQ6VXNlcjQ3NTE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/47517?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/comex",
      "html_url": "https://github.com/comex",
      "followers_url": "https://api.github.com/users/comex/followers",
      "following_url": "https://api.github.com/users/comex/following{/other_user}",
      "gists_url": "https://api.github.com/users/comex/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/comex/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/comex/subscriptions",
      "organizations_url": "https://api.github.com/users/comex/orgs",
      "repos_url": "https://api.github.com/users/comex/repos",
      "events_url": "https://api.github.com/users/comex/events{/privacy}",
      "received_events_url": "https://api.github.com/users/comex/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-08-25T01:22:18Z",
    "updated_at": "2016-08-25T01:22:18Z",
    "body": "@briansmith Hrm... my mistake, I didn't notice that signature.  That's still technically a weaker guarantee than what the documentation requires, since functions like `leak<T: 'static>(Box<T>) -> &'static T` are considered to be safe, but using dispatch_once_t would probably be safe anyway.\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/242256114/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/254369954",
    "html_url": "https://github.com/rust-lang/rust/issues/27610#issuecomment-254369954",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/27610",
    "id": 254369954,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NDM2OTk1NA==",
    "user": {
      "login": "briansmith",
      "id": 16816,
      "node_id": "MDQ6VXNlcjE2ODE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/briansmith",
      "html_url": "https://github.com/briansmith",
      "followers_url": "https://api.github.com/users/briansmith/followers",
      "following_url": "https://api.github.com/users/briansmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/briansmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/briansmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/briansmith/subscriptions",
      "organizations_url": "https://api.github.com/users/briansmith/orgs",
      "repos_url": "https://api.github.com/users/briansmith/repos",
      "events_url": "https://api.github.com/users/briansmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/briansmith/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2016-10-18T00:05:48Z",
    "updated_at": "2016-10-18T00:05:48Z",
    "body": "> That's still technically a weaker guarantee than what the documentation requires, since functions like leak<T: 'static>(Box<T>) -> &'static T are considered to be safe, but using dispatch_once_t would probably be safe anyway.\n\nIf I understand you correctly, you are saying that there are some kinds of `'static` references to thinkgs that don't have actually have \"global or static\" lifetimes as `dispatch_once_t` requires, right? If so, perhaps we should define a new lifetime that has the \"global or static\" meaning, or perhaps we should replace the current use of `'static` for those lifetimes with something else, like `'_`?\n",
    "author_association": "CONTRIBUTOR",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/254369954/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/562877086",
    "html_url": "https://github.com/rust-lang/rust/issues/27610#issuecomment-562877086",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/27610",
    "id": 562877086,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2Mjg3NzA4Ng==",
    "user": {
      "login": "Mark-Simulacrum",
      "id": 5047365,
      "node_id": "MDQ6VXNlcjUwNDczNjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Mark-Simulacrum",
      "html_url": "https://github.com/Mark-Simulacrum",
      "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers",
      "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}",
      "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions",
      "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs",
      "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos",
      "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2019-12-07T18:56:18Z",
    "updated_at": "2019-12-07T18:56:18Z",
    "body": "We've since landed #52349 which moves the fast path to an acquire load (which according to the discussion on that PR is indeed likely the best possible); the cold path is intentionally left as SeqCst to avoid something going wrong unintentionally. As such, I'm going to close this issue as done (and further optimization being not worth it).",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/562877086/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
