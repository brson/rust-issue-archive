[
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/161154790",
    "html_url": "https://github.com/rust-lang/rust/issues/30147#issuecomment-161154790",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30147",
    "id": 161154790,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2MTE1NDc5MA==",
    "user": {
      "login": "alexchandel",
      "id": 637714,
      "node_id": "MDQ6VXNlcjYzNzcxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/637714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexchandel",
      "html_url": "https://github.com/alexchandel",
      "followers_url": "https://api.github.com/users/alexchandel/followers",
      "following_url": "https://api.github.com/users/alexchandel/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexchandel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexchandel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexchandel/subscriptions",
      "organizations_url": "https://api.github.com/users/alexchandel/orgs",
      "repos_url": "https://api.github.com/users/alexchandel/repos",
      "events_url": "https://api.github.com/users/alexchandel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexchandel/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-02T01:55:47Z",
    "updated_at": "2015-12-02T01:55:47Z",
    "body": "Normally `no_std` programs will import `libSystem` anyway because they need to make system calls, which are unsupported when made directly (though they're fairly stable). But it seems there's a corner case where a program could make no libc _or_ system calls and return a value in its exit status, and still need libSystem, since exiting requires a single syscall (although `hlt` or `jmp $0` might do in a pinch).\n\nIn the case of a Mountain Lion-style dynamic executable with an `LC_MAIN` Mach-O load command, `dyld` directly jumps to your `main` and spoofs the stack so you return to `_start` in `libdyld`, which is part of libSystem and which calls `exit()`. For an older dynamic executable with `LC_UNIXTHREAD`, `dyld` jumps to your `start` (presumably from a statically linked crt1.o). This is similar to a static `LC_UNIXTHREAD` executable, where the kernel jumps to your `start` (possibly from a statically linked crt0.o), except crt1.o will invoke `exit()` from libSystem, while crt0.o makes the system call itself.\n\nRust programs have an unarticulated dependency on the entry point, which on OS X can be either crt0.o (which has no dependencies but invokes `exit` and so is unsupported), dyld+crt1.o (which needs libSystem), or dyld+libSystem. Technically dyld by itself is also valid, since dyld doesn't require libSystem to be loaded (except with LC_MAIN), but the necessary exit system call makes this unsupported.\n\nAs a workaround, since your emitting a dynamic LC_MAIN executable, you could just `#[link(name = \"System\")] extern { fn extern dlsym(a: usize, b: usize) -> usize }` or something. Really, we need to handle entry points better, since they cause issues with the MSVC target(s) as well. A `libentry` crate that encoded the various dependencies would be ideal.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/161154790/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/161373912",
    "html_url": "https://github.com/rust-lang/rust/issues/30147#issuecomment-161373912",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30147",
    "id": 161373912,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2MTM3MzkxMg==",
    "user": {
      "login": "alexcrichton",
      "id": 64996,
      "node_id": "MDQ6VXNlcjY0OTk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexcrichton",
      "html_url": "https://github.com/alexcrichton",
      "followers_url": "https://api.github.com/users/alexcrichton/followers",
      "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions",
      "organizations_url": "https://api.github.com/users/alexcrichton/orgs",
      "repos_url": "https://api.github.com/users/alexcrichton/repos",
      "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexcrichton/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-02T17:32:59Z",
    "updated_at": "2015-12-02T17:32:59Z",
    "body": "What linker is in use should in theory just be an implementation detail of the compiler, so just because the default OSX linker requires libSystem to be linked by default doesn't mean that others have the same restriction (such as lld perhaps one day). Along those lines the current interface of the compiler is that the linker brings in no system libraries by default and requires crates to link them in to ensure that it all matches up (allowing usage to build low-level utilities and such).\n\nAlong those lines I think it's more useful to have a cross platform linker-independent model (e.g. no libs by default) and then using the standard library brings in all the appropriate libraries for each platform all the time.\n",
    "author_association": "MEMBER",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/161373912/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/165498482",
    "html_url": "https://github.com/rust-lang/rust/issues/30147#issuecomment-165498482",
    "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/30147",
    "id": 165498482,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NTQ5ODQ4Mg==",
    "user": {
      "login": "alexchandel",
      "id": 637714,
      "node_id": "MDQ6VXNlcjYzNzcxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/637714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexchandel",
      "html_url": "https://github.com/alexchandel",
      "followers_url": "https://api.github.com/users/alexchandel/followers",
      "following_url": "https://api.github.com/users/alexchandel/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexchandel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexchandel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexchandel/subscriptions",
      "organizations_url": "https://api.github.com/users/alexchandel/orgs",
      "repos_url": "https://api.github.com/users/alexchandel/repos",
      "events_url": "https://api.github.com/users/alexchandel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexchandel/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "created_at": "2015-12-17T16:17:36Z",
    "updated_at": "2016-08-29T22:34:38Z",
    "body": "@alexcrichton Consider the entry point/exit point combinations on OS X (where ellipses are user-supplied code):\n\nLacks `LC_LOAD_DYLINKER` load command (i.e. static executable):\n- `->LC_UNIXTHREAD->...(start)->...->...(start)->syscall`\n\nHas `LC_LOAD_DYLINKER` load command:\n- `->dyld->LC_UNIXTHREAD->...(start)->...->...(start)->syscall`\n- `->dyld->LC_UNIXTHREAD->...(start)->...->...(start)->libSystem(exit)`\n- `->dyld->LC_UNIXTHREAD->crt1.o(start)->...(main)->...->crt1.o(start)->libSystem(exit)`\n- `->dyld->LC_MAIN->...(main)->...->libSystem(start)->libSystem(exit)`. (the `libSystem(start)` symbol is actually in `libdyld`, but that's inside `libSystem` anyway)\n\nRust doesn't define its own entry point, limiting it to the last two by default. However, rust users can theoretically provide an entry point, so Rust shouldn't mandate libSystem. _However_, Comex also isn't providing an entry point, meaning he expects Rust's default entry point.\n\nYet when Rust invokes the linker requesting LC_MAIN (the default unless otherwise specified), it doesn't tell it to link libSystem (or an equivalent exit point for LC_MAIN). The linker should not link any libraries without being told to, so this is on Rust.\n\nI think ideally Rust would provide a `libentry`crate comex could use, even if he is using `no_std`, that encodes our dependency on libSystem as an exit point.\n",
    "author_association": "NONE",
    "reactions": {
      "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/165498482/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
