{
  "url": "https://api.github.com/repos/rust-lang/rust/issues/2409",
  "repository_url": "https://api.github.com/repos/rust-lang/rust",
  "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/2409/labels{/name}",
  "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/2409/comments",
  "events_url": "https://api.github.com/repos/rust-lang/rust/issues/2409/events",
  "html_url": "https://github.com/rust-lang/rust/pull/2409",
  "id": 4646100,
  "node_id": "MDExOlB1bGxSZXF1ZXN0MTM4MzIyMg==",
  "number": 2409,
  "title": "high-level tcp bindings for std",
  "user": {
    "login": "olsonjeffery",
    "id": 10408,
    "node_id": "MDQ6VXNlcjEwNDA4",
    "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/olsonjeffery",
    "html_url": "https://github.com/olsonjeffery",
    "followers_url": "https://api.github.com/users/olsonjeffery/followers",
    "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}",
    "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions",
    "organizations_url": "https://api.github.com/users/olsonjeffery/orgs",
    "repos_url": "https://api.github.com/users/olsonjeffery/repos",
    "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}",
    "received_events_url": "https://api.github.com/users/olsonjeffery/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 4,
  "created_at": "2012-05-18T17:28:56Z",
  "updated_at": "2014-06-14T21:50:10Z",
  "closed_at": "2012-05-27T00:41:52Z",
  "author_association": "CONTRIBUTOR",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/rust-lang/rust/pulls/2409",
    "html_url": "https://github.com/rust-lang/rust/pull/2409",
    "diff_url": "https://github.com/rust-lang/rust/pull/2409.diff",
    "patch_url": "https://github.com/rust-lang/rust/pull/2409.patch",
    "merged_at": null
  },
  "body": "### quick summary\n\nThis pull req includes high-level TCP/IP bindings for the rust stdlib (both server and client API), under the `std::net::tcp` module. I also did some reshuffling of the IP stuff and pushed it into the `net::ip` module.\n\nalso: adding `result::unwrap` (from a patch from @nmatsakis) and ignore'd a test on std::timer that is starting to fail more and more, as perf chokes due to valgrind and threading behavior (the test is time-sensitive, so probably poorly conceived to begin with)\n### only slightly more in-depth\n\nAn example demonstrating the TCP client/request API can be found [here](https://github.com/olsonjeffery/rust/blob/hl_tcp/src/libstd/net_tcp.rs#L1352).\n\nInterestingly, because of API-style friction between libuv and rust, I found it neccesary to expose two separate UIs to the TCP server API. Quickly, with examples, they are:\n- the `net::tcp::listen_for_conn` entry point, an example of which is [here](https://github.com/olsonjeffery/rust/blob/hl_tcp/src/libstd/net_tcp.rs#L1225). This call is blocking for the lifetime of the TCP server connection and uses a callback running on the libuv loop (!).\n- and the `net::tcp::new_listener` entry point, an example of which can be found [here](https://github.com/olsonjeffery/rust/blob/hl_tcp/src/libstd/net_tcp.rs#L1300). This bit of API, on successful setup, returns a (vaguely) `comm::port`-like object that uses can peek/recv on (using custom API), as needed, to get new connections.\n\nThe `new_listener` API varies, subtly, from the `listen_for_conn` entry point because it _accepts new connections immediately_ (with the overhead that this entails), while `listen_for_conn` gives a user the chance to manually `accept` a connection, or just drop it, in line with the default behavior of libuv.\n\nTo more fully articulate this, I'm just going to paste my commit msg from `95f0b90`:\n- we now have two interfaces for the TCP/IP server/listener workflow,\n  based on different user approaches surrounding how to deal with the\n  flow of accept a new tcp connection:\n1. the \"original\" API closely mimics the low-level libuv API, in that we\n   have an on_connect_cb that the user provides _that is ran on the libuv\n   thread_. In this callback, the user can accept() a connection, turning it\n   into a tcp_socket.. of course, before accepting, they have the option\n   of passing it to a new task, provided they _make the cb block until\n   the accept is done_ .. this is because, in libuv, you have to do the\n   uv_accept call in the span of that on_connect_cb callback that gets fired\n   when a new connection comes in. thems the breaks..\n\nI wanted to just get rid of this API, because the general proposition of\nusers always running code on the libuv thread sounds like an invitation\nfor many future headaches. the API restriction to have to choose to\nimmediately accept a connection (and allow the user to block libuv as\nneeded) isn't too bad for power users who could conceive of circumstances\nwhere they would drop an incoming TCP connection and know what they're\ndoing, in general.\n\nbut as a general API, I thought this was a bit cumbersome, so I ended up\ndevising..\n1. an API that is initiated with a call to `net::tcp::new_listener()` ..\n   has a similar signature to `net::tcp::listen()`, except that is just\n   returns an object that sort of behaves like a `comm::port`. Users can\n   block on the `tcp_conn_port` to receive new connections, either in the\n   current task or in a new task, depending on which API route they take\n   (`net::tcp::conn_recv` or `net::tcp::conn_recv_spawn` respectively).. there\n   is also a `net::tcp::conn_peek` function that will do a peek on the\n   underlying port to see if there are pending connections.\n\nThe main difference, with this API, is that the low-level libuv glue is\ngoing to _accept every connection attempt_, along with the overhead that\nthat brings. But, this is a much more hassle-free API for 95% of use\ncases and will probably be the one that most users will want to reach for.\n### what's needed to fill this out\n1. IPv6! I stubbed out the data structure, but parsing IPv6 addr strings is non-trivial, so I'm not sure how to tackle this from rust, just yet. If anyone wants to pitch in, that'd be swell.\n2. The other bits of the tcp API. I only added connection-establishment for clients/server and read/write over TCP streams.. so stuff like setting keep-alive, etc needs to be added.\n",
  "closed_by": {
    "login": "brson",
    "id": 147214,
    "node_id": "MDQ6VXNlcjE0NzIxNA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/brson",
    "html_url": "https://github.com/brson",
    "followers_url": "https://api.github.com/users/brson/followers",
    "following_url": "https://api.github.com/users/brson/following{/other_user}",
    "gists_url": "https://api.github.com/users/brson/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/brson/subscriptions",
    "organizations_url": "https://api.github.com/users/brson/orgs",
    "repos_url": "https://api.github.com/users/brson/repos",
    "events_url": "https://api.github.com/users/brson/events{/privacy}",
    "received_events_url": "https://api.github.com/users/brson/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/rust-lang/rust/issues/2409/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/2409/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "_meta": {
    "type": "pr"
  }
}
